---
title: TN022:標準コマンドの実装
ms.date: 11/04/2016
f1_keywords:
- vc.commands
helpviewer_keywords:
- ID_PREV_PANE command [MFC]
- ID_APP_EXIT command [MFC]
- ID_NEXT_PANE command [MFC]
- ID_INDICATOR_REC command [MFC]
- ID_WINDOW_SPLIT command [MFC]
- ID_FILE_PRINT_PREVIEW command [MFC]
- ID_WINDOW_CASCADE command [MFC]
- ID_FILE_CLOSE command [MFC]
- ID_FILE_SAVE_COPY_AS command [MFC]
- ID_WINDOW_ARRANGE command [MFC]
- ID_EDIT_FIND command [MFC]
- ID_FILE_OPEN command [MFC]
- ID_FILE_PAGE_SETUP command [MFC]
- ID_OLE_VERB_FIRST command [MFC]
- ID_EDIT_UNDO command [MFC]
- ID_EDIT_CLEAR command [MFC]
- ID_INDICATOR_CAPS command [MFC]
- ID_HELP_INDEX command [MFC]
- commands [MFC], standard
- ID_FILE_PRINT_SETUP command [MFC]
- ID_DEFAULT_HELP command [MFC]
- ID_INDICATOR_SCRL command [MFC]
- ID_FILE_PRINT command [MFC]
- ID_INDICATOR_OVR command [MFC]
- ID_INDICATOR_KANA command [MFC]
- ID_EDIT_COPY command [MFC]
- ID_EDIT_REDO command [MFC]
- ID_EDIT_PASTE command [MFC]
- ID_OLE_INSERT_NEW command [MFC]
- ID_OLE_EDIT_LINKS command [MFC]
- ID_EDIT_PASTE_SPECIAL command [MFC]
- ID_INDICATOR_EXT command [MFC]
- ID_HELP_USING command [MFC]
- standard commands
- ID_VIEW_STATUS_BAR command [MFC]
- ID_FILE_SAVE_AS command [MFC]
- ID_EDIT_CLEAR_ALL command [MFC]
- ID_WINDOW_NEW command [MFC]
- ID_CONTEXT_HELP command [MFC]
- ID_EDIT_REPLACE command [MFC]
- ID_WINDOW_TILE_HORZ command [MFC]
- ID_APP_ABOUT command [MFC]
- TN022
- ID_VIEW_TOOLBAR command [MFC]
- ID_HELP command [MFC]
- ID_WINDOW_TILE_VERT command [MFC]
- ID_EDIT_CUT command [MFC]
- ID_FILE_UPDATE command [MFC]
- ID_EDIT_REPEAT command [MFC]
- ID_FILE_SAVE command [MFC]
- ID_EDIT_PASTE_LINK command [MFC]
- ID_EDIT_SELECT_ALL command [MFC]
- ID_FILE_NEW command [MFC]
- ID_INDICATOR_NUM command
ms.assetid: a7883b46-23f7-4870-ac3a-804aed9258b5
ms.openlocfilehash: 8d568760cc75a4c1f2ddb6dd88108cc830783194
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2019
ms.locfileid: "62306052"
---
# <a name="tn022-standard-commands-implementation"></a>TN022:標準コマンドの実装

> [!NOTE]
>  次のテクニカル ノートは、最初にオンライン ドキュメントの一部とされてから更新されていません。 結果として、一部のプロシージャおよびトピックが最新でないか、不正になります。 最新の情報について、オンライン ドキュメントのキーワードで関係のあるトピックを検索することをお勧めします。

ここでは、MFC 2.0 によって提供される標準コマンドの実装について説明します。 読み取り[テクニカル ノート 21](../mfc/tn021-command-and-message-routing.md)最初ため、標準のコマンドの多くを実装するための機構について説明します。

この説明は、MFC のアーキテクチャ、Api、および一般的なプログラミングに関する知識を前提とします。 文書化されていると文書化されていない「の実装のみ」の Api が説明されています。 これは、機能または MFC のプログラミング方法について学習を開始する場所ではありません。 一般的な情報および文書化されている Api の詳細については、Visual C を参照してください。

## <a name="the-problem"></a>問題を

MFC は、ヘッダー ファイル コマで多くの標準コマンド Id を定義します。H. これらのコマンドのフレームワークのサポートは異なります。 Framework のクラスがこれらのコマンドを処理する場所と方法を理解することだけしか表示されません、framework の内部的な動作が標準的な実装をカスタマイズおよび実装するためのいくつかの手法について説明する方法に関する便利な情報を提供コマンド ハンドラーを独自にします。

## <a name="contents-of-this-technical-note"></a>このテクニカル ノートの内容

各コマンドの ID は 2 つのセクションで説明します。

- タイトル: (たとえば、「現在のドキュメントを保存します」) コマンドの目的は、続いてコマンド ID (たとえば、ID_FILE_SAVE) のシンボリック名がコロンで区切ります。

- コマンドと、既定の実装が何を実装するクラスを記述する 1 つまたは複数の段落

ほとんどの既定のコマンドの実装は、framework の基本クラスのメッセージ マップに既に結び付けられています。 派生クラスで明示的な接続を必要とするいくつかのコマンドの実装があります。 これらは、「メモ」で説明します。 AppWizard で適切なオプションを選択した場合は、生成されたスケルトン アプリケーションでのこれらの既定のハンドラーが接続されます。

## <a name="naming-convention"></a>名前付け規約

標準のコマンドでは、可能な場合に使用することをお勧めする単純な名前付け規則に従います。 ほとんどの標準のコマンドは、アプリケーションのメニュー バーで、標準的な場所に配置されます。 コマンドのシンボリック名は、「id _」の後に、メニュー項目の名前の後に、標準のポップアップ メニュー名で始まります。 シンボリック名がアンダー スコアで単語の分割と大文字にします。 標準メニュー項目の名前を持たないコマンドでは、id「_」(たとえば、ID_NEXT_PANE) で始まるコマンドが論理名が定義されます。

Id「_」プレフィックスを使用してメニュー項目、ツール バー ボタン、またはその他のコマンドのユーザー インターフェイス オブジェクトにバインドするように設計されたコマンドを表します。 Id「_」のコマンドを処理するコマンド ハンドラーは、MFC コマンド アーキテクチャの ON_COMMAND とメカニズムを使用する必要があります。

次のコマンドのアーキテクチャとメニューに固有のコードを有効にし、それらを無効にする必要がありますしないメニュー項目に標準の「idm _」プレフィックスを使用することをお勧めします。 もちろん] メニューの [特定のコマンドの数を小さい MFC コマンド アーキテクチャを次だけでなく、(ツールバーを使用) ので、コマンド ハンドラーのより強力なが再利用可能なコマンド ハンドラーのコードは、ためにがあります。

## <a name="id-ranges"></a>ID の範囲

参照してください[テクニカル ノート 20](../mfc/tn020-id-naming-and-numbering-conventions.md) MFC の ID 範囲の使用の詳細についてはします。

MFC の標準的なコマンドは、範囲 0 xefff に 0xE000 に収まります。 依存しないでくださいこれらの Id の特定の値には、ライブラリの今後のバージョンで変更されるためです。

アプリケーションでは、0x8000 から 0 xdfff の範囲でコマンドを定義する必要があります。

## <a name="standard-command-ids"></a>標準コマンド Id

各コマンド id は、ファイルの指示を記載する標準のメッセージ行プロンプト文字列です。RC です。 メニュー プロンプト文字列 ID はコマンド ID と同じである必要があります。

- ID_FILE_NEW は、新しい/空のドキュメントを作成します。

    > [!NOTE]
    >  これを接続する必要があります、 `CWinApp`-この機能を有効にするクラスのメッセージ マップを派生します。

   `CWinApp::OnFileNew` アプリケーションでは、ドキュメント テンプレートの数に応じて異なる方法では、このコマンドを実装します。 1 つしかない場合`CDocTemplate`、`CWinApp::OnFileNew`適切なフレームとビュー クラスと同様に、その型の新しいドキュメントが作成されます。

   1 つ以上を使用する必要がある場合`CDocTemplate`、`CWinApp::OnFileNew`を知らせるダイアログ ボックス (AFX_IDD_NEWTYPEDLG) がユーザーにドキュメントの種類を使用する選択を求められます。 選択した`CDocTemplate`ドキュメントを作成するために使用します。

   ID_FILE_NEW の 1 つの一般的なカスタマイズでは、ドキュメントの種類をグラフィカルに選択し、別の提供です。 ここで実装できます独自`CMyApp::OnFileNew`の代わりに、メッセージ マップに配置し、`CWinApp::OnFileNew`します。 基本クラス実装を呼び出す必要はありません。

   ID_FILE_NEW のもう 1 つの一般的なカスタマイズでは、各種類のドキュメントを作成するために個別のコマンドを提供します。 ここで新しいコマンド Id、ID_FILE_NEW_CHART と ID_FILE_NEW_SHEET などを定義する必要があります。

- ID_FILE_OPEN では、既存のドキュメントが開きます。

    > [!NOTE]
    >  これを接続する必要があります、 `CWinApp`-この機能を有効にするクラスのメッセージ マップを派生します。

   `CWinApp::OnFileOpen` 呼び出し元の非常に単純な実装が`CWinApp::DoPromptFileName`続けて`CWinApp::OpenDocumentFile`開くファイルのファイルまたはパスの名前に置き換えます。 `CWinApp`実装ルーチン`DoPromptFileName`標準開く ダイアログ ボックスが表示され、現在のドキュメント テンプレートから取得したファイル拡張子で塗りつぶします。

   ID_FILE_OPEN の 1 つの一般的なカスタマイズを開く ダイアログ ボックスをカスタマイズしたり、ファイル フィルターを追加します。 これをカスタマイズすることをお勧めの方法を開く ダイアログ ボックス、および呼び出しと既定の実装を置き換える`CWinApp::OpenDocumentFile`ドキュメントのファイルまたはパスの名前。 基本クラスを呼び出す必要はありません。

- ID_FILE_CLOSE では、現在開いているドキュメントを閉じます。

   `CDocument::OnFileClose` 呼び出し`CDocument::SaveModified`呼び出してが変更されている場合は、ドキュメントを保存するユーザー入力を求める`OnCloseDocument`します。 ドキュメントの破棄を含むのすべての終了ロジックはこれ、`OnCloseDocument`ルーチン。

    > [!NOTE]
    >  WM_CLOSE メッセージまたはドキュメント フレーム ウィンドウに送信される SC_CLOSE システム コマンドから異なる ID_FILE_CLOSE 機能します。 ウィンドウを閉じる場合は、最後のフレーム ウィンドウ、ドキュメントを表示する場合にのみ、ドキュメントが閉じられます。 ドキュメントを閉じる ID_FILE_CLOSE のみ、ドキュメントを終了できませんが、ドキュメントを示すすべてのフレーム ウィンドウを終了します。

- まずは、現在のドキュメントを保存します。

   実装は、ヘルパー ルーチンを使用して`CDocument::DoSave`両方に使用される`OnFileSave`と`OnFileSaveAs`します。 前に保存されていないドキュメントを保存するかどうか (つまりがないパス名では、という名前の場合と同様)、読み取り専用のドキュメントから読み取られたまたは、`OnFileSave`ロジックは、ID_FILE_SAVE_AS コマンドを実行し、新しいファイル名を提供するユーザーに確認するようになります. 実際のファイルを開くと、保存を行うプロセスの仮想関数を行う`OnSaveDocument`します。

   ID_FILE_SAVE をカスタマイズする 2 つの一般的な理由があります。 保存しないドキュメントでは、単に削除 ID_FILE_SAVE メニュー項目とツールバーのボタン ユーザー インターフェイスからします。 また、ドキュメントをダーティしないことを確認 (つまり、呼び出すことはありません`CDocument::SetModifiedFlag`) とフレームワークと、ドキュメントを保存することはありません。 ディスク ファイル以外の任意の場所に保存するドキュメントでは、その操作の新しいコマンドを定義します。

   場合、 `COleServerDoc`ID_FILE_SAVE が両方のファイル (通常のドキュメント) 用の保存とファイルの更新 (埋め込まれたドキュメント) 用に使用されます。

   ドキュメント データは、個々 のディスク ファイルに格納されますが、既定値を使用しない場合`CDocument`実装をシリアル化をオーバーライドする必要があります`CDocument::OnSaveDocument`の代わりに`OnFileSave`します。

- ID_FILE_SAVE_AS は、別のファイル名の下の現在のドキュメントを保存します。

   `CDocument::OnFileSaveAs`実装を使用して同じ`CDocument::DoSave`ヘルパー ルーチンとして`OnFileSave`します。 `OnFileSaveAs`ドキュメントには、保存する前にファイル名があるない場合、ID_FILE_SAVE と同様のコマンドが処理されます。 `COleServerDoc::OnFileSaveAs` 通常のドキュメントのデータ ファイルを保存するか、別のファイルとして他のアプリケーションに埋め込まれている OLE オブジェクトを表すサーバー ドキュメントを保存ロジックを実装します。

   ID_FILE_SAVE のロジックをカスタマイズする場合は、同様の方法で ID_FILE_SAVE_AS をカスタマイズする可能性があります。 またはの「名前を付けて保存」操作がドキュメントに適用します。 不要な場合は、メニュー バーからメニュー項目を削除できます。

- ID_FILE_SAVE_COPY_AS は、新しい名前でコピーを現在のドキュメントを保存します。

   `COleServerDoc::OnFileSaveCopyAs`実装に非常に似ています`CDocument::OnFileSaveAs`, ドキュメント オブジェクト"にアタッチされていない"基になるファイルの保存に点が異なります。 メモリ内のドキュメントは、保存する前に"modified"が場合に、まだ"modified"。 さらに、このコマンドでは、パス名やドキュメントに格納されているタイトルには影響はありません。

- ID_FILE_UPDATE embedded のドキュメントの保存先コンテナーを通知します。

   `COleServerDoc::OnUpdateDocument`実装 notifiies、埋め込みの保存先コンテナーだけです。 コンテナーは、埋め込みオブジェクトを保存するために、適切な OLE Api を呼び出します。

- ID_FILE_PAGE_SETUP では、アプリケーション固有のページ/レイアウトをセットアップ ダイアログ ボックスを呼び出します。

   現在、このダイアログ ボックスでの標準はありませんし、フレームワークには、このコマンドの既定の実装がありません。

   このコマンドを実装する場合は、このコマンド ID を使用してお勧めします。

- ID_FILE_PRINT_SETUP では、標準の印刷のセットアップ ダイアログ ボックスを呼び出します。

    > [!NOTE]
    >  これを接続する必要があります、 `CWinApp`-この機能を有効にするクラスのメッセージ マップを派生します。

   このコマンドは、ユーザーがプリンターをカスタマイズして、印刷の設定を少なくともにできる標準の印刷設定 ダイアログを起動します。 このドキュメントまたはこのアプリケーションでドキュメントの最大ですべてです。 コントロール パネルを使用して、システム全体の既定のプリンター設定を変更する必要があります。

   `CWinApp::OnFilePrintSetup` 非常に単純な実装を作成するには、`CPrintDialog`オブジェクトと呼び出し元、`CWinApp::DoPrintDialog`関数を実装します。 これには、アプリケーションの既定のプリンター設定を設定します。

   このコマンドをカスタマイズするための一般的な必要性は、保存するときに、ドキュメントと共に格納する必要があります - ドキュメントごとのプリンターの設定のようにすることです。 これを行うメッセージ マップのハンドラーを追加する必要があります、`CDocument`クラスを作成する、`CPrintDialog`オブジェクト、適切なプリンターの属性を持つことを初期化します (通常は*hDevMode*と*と*) を呼び出し、 `CPrintDialog::DoModal`、変更されたプリンターの設定を保存します。 堅牢な実装の実装を確認する必要があります`CWinApp::DoPrintDialog`エラーを検出するため、`CWinApp::UpdatePrinterSelection`実用的な既定値を処理すると、システム全体のプリンターの変更を追跡します。

- 現在のドキュメントの ID_FILE_PRINT 標準の印刷

    > [!NOTE]
    >  これを接続する必要があります、 `CView`-この機能を有効にするクラスのメッセージ マップを派生します。

   このコマンドは、現在のドキュメントを印刷したりより正確に標準印刷ダイアログ ボックスを呼び出すと、印刷のエンジンを実行しているのでは、印刷プロセスを起動します。

   `CView::OnFilePrint` このコマンドと印刷のメイン ループを実装します。 仮想呼び出し`CView::OnPreparePrinting`される印刷ダイアログ ボックスで、ユーザーのプロンプトにします。 プリンターへの出力を DC の準備、印刷の進行状況ダイアログ (AFX_IDD_PRINTDLG) が表示され、送信、`StartDoc`をプリンターにエスケープします。 `CView::OnFilePrint` また、メイン ページ指向印刷ループが含まれます。 各ページで、仮想呼び出し`CView::OnPrepareDC`続けて、`StartPage`エスケープし、仮想呼び出し`CView::OnPrint`そのページの。 完了すると、仮想`CView::OnEndPrinting`を呼び出すと、印刷の進行状況ダイアログが閉じられるとします。

   MFC の印刷アーキテクチャは、印刷と印刷プレビューのさまざまな方法でフック設計されています。 さまざまなを通常検索は`CView`オーバーライド可能な関数が、ページ指向の印刷タスクに適してします。 アプリケーションで非ページ指向の出力のプリンターを使用する場合は、場合にのみがわかったら、ID_FILE_PRINT 実装を置き換える必要があります。

- ID_FILE_PRINT_PREVIEW 入力の現在のドキュメント モードを印刷プレビュー。

    > [!NOTE]
    >  これを接続する必要があります、 `CView`-この機能を有効にするクラスのメッセージ マップを派生します。

   `CView::OnFilePrintPreview` 文書化されたヘルパー関数を呼び出して印刷プレビュー モードを開始`CView::DoPrintPreview`します。 `CView::DoPrintPreview` 同様、印刷プレビュー ループのメイン エンジンは、`OnFilePrint`は印刷ループのメイン エンジンです。

   さまざまな方法でに異なるパラメーターを渡すことによってカスタマイズできます。 印刷プレビュー操作`DoPrintPreview`します。 参照してください[テクニカル ノート 30:](../mfc/tn030-customizing-printing-and-print-preview.md)、印刷プレビューの詳細の一部が説明されていますおよびそれをカスタマイズする方法。

- ID_FILE_MRU_FILE1.FILE16 ファイル MRU のコマンド Id の範囲**一覧**します。

   `CWinApp::OnUpdateRecentFileMenu` ON_UPDATE_COMMAND_UI メカニズムのより高度な用途の 1 つは、更新コマンド UI ハンドラーです。 メニュー リソースで、のみ ID ID_FILE_MRU_FILE1 で単一のメニュー項目を定義する必要があります。 メニュー項目が最初に無効のままです。

   MRU 一覧が増すにつれて、その他のメニュー項目の一覧に追加されます。 標準`CWinApp`実装の既定値は 4 つの最近使用したファイルの標準的な制限です。 既定値を変更するには呼び出すことによって`CWinApp::LoadStdProfileSettings`値は、大きくまたは小さくします。 アプリケーションの MRU 一覧が格納されます。INI ファイルです。 アプリケーションの一覧が読み込まれる`InitInstance`関数を呼び出す場合`LoadStdProfileSettings`アプリケーションの終了時に保存されます。 また MRU 更新コマンド UI ハンドラーは、[ファイル] メニューの表示の相対パスに絶対パスが変換されます。

   `CWinApp::OnOpenRecentFile` 実際のコマンドを実行する ON_COMMAND ハンドラーです。 MRU 一覧と呼び出しから単にファイル名を取得`CWinApp::OpenDocumentFile`ファイルを開いて、MRU 一覧の更新のすべての作業を行います。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_EDIT_CLEAR は、現在の選択範囲をクリアします。

   現在このコマンドの標準の実装ではありません。 ごとにこれを実装する必要があります`CView`-クラスを派生します。

   `CEditView` 使用してこのコマンドの実装を提供`CEdit::Clear`します。 現在選択されていない場合、コマンドが無効です。

   このコマンドを実装する場合は、このコマンド ID を使用してお勧めします。

- ID_EDIT_CLEAR_ALL では、ドキュメント全体をクリアします。

   現在このコマンドの標準の実装ではありません。 ごとにこれを実装する必要があります`CView`-クラスを派生します。

   このコマンドを実装する場合は、このコマンド ID を使用してお勧めします。 MFC のチュートリアルのサンプルを参照して[SCRIBBLE](../overview/visual-cpp-samples.md)実装例についてはします。

- ID_EDIT_COPY は、現在の選択範囲をクリップボードにコピーします。

   現在このコマンドの標準の実装ではありません。 ごとにこれを実装する必要があります`CView`-クラスを派生します。

   `CEditView` このコマンドは、現在選択されているテキストをされているテキストを使用してクリップボードにコピーの実装を提供`CEdit::Copy`します。 現在選択されていない場合、コマンドが無効です。

   このコマンドを実装する場合は、このコマンド ID を使用してお勧めします。

- ID_EDIT_CUT は、現在の選択範囲をクリップボードに切り取ります。

   現在このコマンドの標準の実装ではありません。 ごとにこれを実装する必要があります`CView`-クラスを派生します。

   `CEditView` 現在選択されているテキストを切り取り、クリップボードされているテキストを使用して、このコマンドの実装を提供します`CEdit::Cut`します。 現在選択されていない場合、コマンドが無効です。

   このコマンドを実装する場合は、このコマンド ID を使用してお勧めします。

- ID_EDIT_FIND 開始、検索操作は、モードレスの検索 ダイアログ ボックスが表示されます。

   現在このコマンドの標準の実装ではありません。 ごとにこれを実装する必要があります`CView`-クラスを派生します。

   `CEditView` このコマンドは、この実装のヘルパー関数を呼び出すの実装を提供`OnEditFindReplace`を使用して、以前の検索/置換の設定をプライベート変数に格納します。 `CFindReplaceDialog`クラスは、ユーザーに確認のモードレス ダイアログ ボックスの管理に使用されます。

   このコマンドを実装する場合は、このコマンド ID を使用してお勧めします。

- ID_EDIT_PASTE では、現在のクリップボードの内容を挿入します。

   現在このコマンドの標準の実装ではありません。 ごとにこれを実装する必要があります`CView`-クラスを派生します。

   `CEditView` このコマンドを使用して、選択したテキストを置き換える現在クリップボード データのコピーの実装を提供`CEdit::Paste`します。 ある場合、コマンドが無効にしない**エディット**をクリップボードにします。

   `COleClientDoc` だけこのコマンドの更新コマンド UI ハンドラーを提供します。 クリップボードに埋め込み可能な OLE 項目/オブジェクトが含まれていない場合は、コマンドが無効になります。 実際に貼り付けを行うには、実際のコマンドのハンドラーを記述するためにあります。 OLE アプリケーションでは、その他の形式を貼り付けることも場合、は、ビューまたはドキュメントでは独自の更新コマンド UI ハンドラーを指定する必要があります (つまり、どこかにする前に`COleClientDoc`コマンド ターゲットのルーティングで)。

   このコマンドを実装する場合は、このコマンド ID を使用してお勧めします。

   OLE の標準実装を置き換えるため使用`COleClientItem::CanPaste`します。

- ID_EDIT_PASTE_LINK は、現在のクリップボードの内容からのリンクを挿入します。

   現在このコマンドの標準の実装ではありません。 ごとにこれを実装する必要があります`CView`-クラスを派生します。

   `COleDocument` だけこのコマンドの更新コマンド UI ハンドラーを提供します。 クリップボードにリンク可能 OLE 項目/オブジェクトが含まれていない場合は、コマンドが無効になります。 実際に貼り付けを行うには、実際のコマンドのハンドラーを記述するためにあります。 OLE アプリケーションでは、その他の形式を貼り付けることも場合、は、ビューまたはドキュメントでは独自の更新コマンド UI ハンドラーを指定する必要があります (つまり、どこかにする前に`COleDocument`コマンド ターゲットのルーティングで)。

   このコマンドを実装する場合は、このコマンド ID を使用してお勧めします。

   OLE の標準実装を置き換えるため使用`COleClientItem::CanPasteLink`します。

- ID_EDIT_PASTE_SPECIAL は、オプションを使用して現在のクリップボードの内容を挿入します。

   現在このコマンドの標準の実装ではありません。 ごとにこれを実装する必要があります`CView`-クラスを派生します。 MFC では、このダイアログ ボックスは提供されません。

   このコマンドを実装する場合は、このコマンド ID を使用してお勧めします。

- ID_EDIT_REPEAT には、最後の操作が繰り返されます。

   現在このコマンドの標準の実装ではありません。 ごとにこれを実装する必要があります`CView`-クラスを派生します。

   `CEditView` 最後の検索操作を繰り返すには、このコマンドの実装を提供します。 最後の検索の変数ではプライベートな実装が使用されます。 検索を試行できない場合、コマンドが無効です。

   このコマンドを実装する場合は、このコマンド ID を使用してお勧めします。

- ID_EDIT_REPLACE 開始、置換操作は、置換のモードレス ダイアログが表示されます。

   現在このコマンドの標準の実装ではありません。 ごとにこれを実装する必要があります`CView`-クラスを派生します。

   `CEditView` このコマンドは、この実装のヘルパー関数を呼び出すの実装を提供`OnEditFindReplace`を使用して、以前の検索/置換の設定をプライベート変数に格納します。 `CFindReplaceDialog`をユーザーに求めるモードレスのダイアログを管理するクラスを使用します。

   このコマンドを実装する場合は、このコマンド ID を使用してお勧めします。

- ID_EDIT_SELECT_ALL は、ドキュメント全体を選択します。

   現在このコマンドの標準の実装ではありません。 ごとにこれを実装する必要があります`CView`-クラスを派生します。

   `CEditView` このコマンドは、ドキュメント内のすべてのテキストの選択の実装を提供します。 テキストを選択することがない場合は、コマンドが無効です。

   このコマンドを実装する場合は、このコマンド ID を使用してお勧めします。

- ID_EDIT_UNDO 最後の操作を元に戻します。

   現在このコマンドの標準の実装ではありません。 ごとにこれを実装する必要があります`CView`-クラスを派生します。

   `CEditView` この実装を提供します。 コマンドを使用して`CEdit::Undo`します。 場合、コマンドが無効になっている`CEdit::CanUndo`FALSE を返します。

   このコマンドを実装する場合は、このコマンド ID を使用してお勧めします。

- ID_EDIT_REDO では、最後の操作をやり直します。

   現在このコマンドの標準の実装ではありません。 ごとにこれを実装する必要があります`CView`-クラスを派生します。

   このコマンドを実装する場合は、このコマンド ID を使用してお勧めします。

- ID_WINDOW_NEW では、アクティブなドキュメントに別のウィンドウが開きます。

   `CMDIFrameWnd::OnWindowNew` 現在のドキュメントのドキュメント テンプレートを使用して、現在のドキュメントの別のビューを含む別のフレームを作成するには、この強力な機能を実装します。

   複数ドキュメント インターフェイス (MDI) ウィンドウ メニュー、ほとんどのコマンドのようにアクティブな MDI 子ウィンドウがない場合、コマンドが無効になります。

   このコマンド ハンドラーのカスタマイズは推奨されません。 追加のビューまたはフレーム ウィンドウを作成するコマンドを提供する場合は、独自のコマンドを考え出すことをお勧めします。 コードを複製する`CMDIFrameWnd::OnWindowNew`し、好みの特定のフレームとビュー クラスに変更します。

- MDI ウィンドウの下部にあるアイコンを ID_WINDOW_ARRANGE を整列します。

   `CMDIFrameWnd` 実装のヘルパー関数にこの標準の MDI コマンドを実装して`OnMDIWindowCmd`します。 このヘルパーは、MDI Windows メッセージをコマンド Id をマップし、したがって、多くのコードを共有できます。

   ほとんどのウィンドウの MDI メニュー コマンドと同様には、アクティブな MDI 子ウィンドウがない場合、コマンドが無効です。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- 重なるように windows を ID_WINDOW_CASCADE 連鎖します。

   `CMDIFrameWnd` 実装のヘルパー関数にこの標準の MDI コマンドを実装して`OnMDIWindowCmd`します。 このヘルパーは、MDI Windows メッセージをコマンド Id をマップし、したがって、多くのコードを共有できます。

   ほとんどのウィンドウの MDI メニュー コマンドと同様には、アクティブな MDI 子ウィンドウがない場合、コマンドが無効です。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_WINDOW_TILE_HORZ タイル windows 水平方向にします。

   このコマンドは`CMDIFrameWnd`ID_WINDOW_CASCADE と同様、別の MDI Windows メッセージは、操作に使用される点が異なります。

   アプリケーションの既定のタイルの向きを選択してください。 ID_WINDOW_TILE_HORZ または ID_WINDOW_TILE_VERT ウィンドウ「タイル」メニュー項目の ID を変更することで、これを行うことができます。

- ID_WINDOW_TILE_VERT タイル windows 垂直方向にします。

   このコマンドは`CMDIFrameWnd`ID_WINDOW_CASCADE と同様、別の MDI Windows メッセージは、操作に使用される点が異なります。

   アプリケーションの既定のタイルの向きを選択してください。 ID_WINDOW_TILE_HORZ または ID_WINDOW_TILE_VERT ウィンドウ「タイル」メニュー項目の ID を変更することで、これを行うことができます。

- スプリッター ID_WINDOW_SPLIT キーボード インターフェイスです。

   `CView` このコマンドは、処理、`CSplitterWnd`実装します。 このコマンドは実装関数を委任されているビューが分割ウィンドウの一部である場合は、`CSplitterWnd::DoKeyboardSplit`します。 これにより、スプリッターが分割またはスプリッター ウィンドウの分割を解除するキーボード ユーザーができるモードに配置されます。

   分割ウィンドウで、ビューがない場合は、このコマンドが無効です。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_APP_ABOUT では、バージョン情報 ダイアログ ボックスを呼び出します。

   アプリケーションの詳細 ボックスの標準の実装ではありません。 既定 AppWizard で作成したアプリケーション、アプリケーションのカスタム ダイアログ クラスが作成され、についてボックスとして使用します。 このコマンドを処理し、ダイアログを起動するコマンド ハンドラー AppWizard も記述します。

   ほとんどの場合、このコマンドを実装します。

- ID_APP_EXIT では、アプリケーションを終了します。

   `CWinApp::OnAppExit` このコマンドは、WM_CLOSE メッセージをアプリケーションのメイン ウィンドウに送信して処理します。 標準の (これにダーティ ファイルのプロンプト)、アプリケーションのシャット ダウンがによって処理される、`CFrameWnd`実装します。

   このコマンド ハンドラーのカスタマイズは推奨されません。 オーバーライドする`CWinApp::SaveAllModified`または`CFrameWnd`クロージング ロジックをお勧めします。

   このコマンドを実装する場合は、このコマンド ID を使用してお勧めします。

- ID_HELP_INDEX を一覧表示ヘルプからトピック。HLP ファイルです。

    > [!NOTE]
    >  これを接続する必要があります、 `CWinApp`-この機能を有効にするクラスのメッセージ マップを派生します。

   `CWinApp::OnHelpIndex` 普通に呼び出すことによって、このコマンドを処理`CWinApp::WinHelp`します。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ヘルプを使用する方法のヘルプを ID_HELP_USING 表示します。

    > [!NOTE]
    >  これを接続する必要があります、 `CWinApp`-この機能を有効にするクラスのメッセージ マップを派生します。

   `CWinApp::OnHelpUsing` 普通に呼び出すことによって、このコマンドを処理`CWinApp::WinHelp`します。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_CONTEXT_HELP 入力 shift キーを押しながら F1 ヘルプ モード。

    > [!NOTE]
    >  これを接続する必要があります、 `CWinApp`-この機能を有効にするクラスのメッセージ マップを派生します。

   `CWinApp::OnContextHelp` このコマンドを処理するには、ヘルプ モードのカーソルを設定して、モーダル ループを開始し、ユーザーのヘルプを表示するウィンドウを選択するまで待機します。 参照してください[テクニカル ノート 28:](../mfc/tn028-context-sensitive-help-support.md) MFC のヘルプの実装の詳細についてはします。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- 現在のコンテキストに Id_help ヘルプ

    > [!NOTE]
    >  これを接続する必要があります、 `CWinApp`-この機能を有効にするクラスのメッセージ マップを派生します。

   `CWinApp::OnHelp` 現在のアプリケーション コンテキストのヘルプ コンテキストを取得することによって、このコマンドを処理します。 これは、簡単なの F1 ヘルプを処理、これにメッセージ ボックスのヘルプします。 参照してください[テクニカル ノート 28:](../mfc/tn028-context-sensitive-help-support.md)の詳細については、mfc を使うための実装。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- コンテキストの既定のヘルプを ID_DEFAULT_HELP 表示

    > [!NOTE]
    >  これを接続する必要があります、 `CWinApp`-この機能を有効にするクラスのメッセージ マップを派生します。

   このコマンドは、通常`CWinApp::OnHelpIndex`します。

   既定のヘルプとヘルプのキーワードを区別が必要な場合は、さまざまなコマンド ハンドラーを指定できます。

- ID_NEXT_PANE は [次へ] ペインに表示

   `CView` このコマンドは、処理、`CSplitterWnd`実装します。 このコマンドは実装関数を委任されているビューが分割ウィンドウの一部である場合は、`CSplitterWnd::OnNextPaneCmd`します。 アクティブなビューは、分割ウィンドウの隣のウィンドウにこの移行されます。

   このコマンドは無効です、分割にビューがないか次のペインに移動するのにはありません。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_PREV_PANE が前のペインには

   `CView` このコマンドは、処理、`CSplitterWnd`実装します。 このコマンドは実装関数を委任されているビューが分割ウィンドウの一部である場合は、`CSplitterWnd::OnNextPaneCmd`します。 これにより、アクティブなビューが分割ウィンドウの前のペインに移動されます。

   このコマンドは無効です、分割にビューがないか前のペインに移動するのにはありません。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_OLE_INSERT_NEW は新しい OLE オブジェクトを挿入します。

   現在このコマンドの標準の実装ではありません。 これを実装する必要があります、 `CView`-現在の選択範囲に新しい OLE 項目/オブジェクトを挿入するクラスを派生します。

   すべての OLE クライアント アプリケーションでは、このコマンドを実装する必要があります。 AppWizard、OLE のオプションでは、スケルトンの実装を作成`OnInsertObject`ビュー クラスを完了する必要があります。

   MFC OLE サンプルを参照して[OCLIENT](../overview/visual-cpp-samples.md)このコマンドの完全な実装の例です。

- ID_OLE_EDIT_LINKS 編集 OLE リンク

   `COleDocument` 標準の OLE リンク ダイアログの MFC で提供される実装を使用して、このコマンドを処理します。 このダイアログ ボックスの実装は、`COleLinksDialog`クラス。 現在のドキュメントに任意のリンクが含まれていない場合、コマンドが無効です。

   このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_OLE_VERB_FIRST.OLE の動詞の最後の ID 範囲

   `COleDocument` 現在選択されている OLE 項目/オブジェクトでサポートされている動詞には、このコマンドの ID 範囲を使用します。 指定した OLE 項目/オブジェクトの種類は、0 個以上のカスタム動詞をサポートできるので、範囲があります。 アプリケーションのメニューで、ID_OLE_VERB_FIRST の ID を 1 つのメニュー項目が必要です。 プログラムの実行時に、適切なメニューの動詞の説明 (または多くの動詞でポップアップ メニュー) で、メニューが更新されます。 OLE のメニューの管理は`AfxOleSetEditMenu`、このコマンドの更新コマンド UI ハンドラーで元に戻す。

   この範囲内のコマンド ID の各を処理するための明示的なコマンド ハンドラーはありません。 `COleDocument::OnCmdMsg` オーバーライドすることで、この範囲内のすべてのコマンド Id をトラップ、動詞の 0 から始まる数字の場合に変えること、およびその動詞のサーバーを起動 (を使用して`COleClientItem::DoVerb`)。

   カスタマイズまたはこのコマンドの ID 範囲の他の使用は推奨されません。

- ID_VIEW_TOOLBAR オンとオフをツールバーを切り替え

   `CFrameWnd` ツールバーの表示状態を切り替えるには、このコマンドと、更新コマンド UI ハンドラーを処理します。 ツールバーは、子ウィンドウ AFX_IDW_TOOLBAR の ID を使用したフレームの子ウィンドウにある必要があります。 コマンド ハンドラーは、実際には、ツールバー、ウィンドウの表示を切り替えます。 `CFrameWnd::RecalcLayout` 新しい状態で、ツールバーを含むフレーム ウィンドウを再描画に使用されます。 更新コマンド UI ハンドラーは、ツールバーが表示されるメニュー項目を確認します。

   このコマンド ハンドラーのカスタマイズは推奨されません。 ツールバーを追加する場合は、複製し、コマンド ハンドラーと、このコマンドの更新コマンド UI ハンドラーを変更するは。

- ID_VIEW_STATUS_BAR がオンとオフ、ステータス バーを切り替えます

   このコマンドは`CFrameWnd`ID (AFX_IDW_STATUS_BAR) が使用されるさまざまな子ウィンドウを除く、ID_VIEW_TOOLBAR と同様です。

## <a name="update-only-command-handlers"></a>更新専用のコマンド ハンドラー

いくつかの標準コマンド Id は、ステータス バーのインジケーターとして使用されます。 これらを使用して同じ処理機構の更新コマンド UI アプリケーションのアイドル時間中に、現在の状態を表示します。 ユーザーが選択できないので (つまり、ステータス バー ペインをプッシュできません、) これらのコマンド Id、ON_COMMAND ハンドラーを指定しても意味ができなくなります。

- ID_INDICATOR_CAPS:CAP ロック インジケーター。

- ID_INDICATOR_NUM:NUM lock インジケーター。

- ID_INDICATOR_SCRL:SCRL ロック インジケーター。

- ID_INDICATOR_KANA:ひらがなは、インジケーター (日本語のシステムにのみ適用) をロックします。

これらの 3 つすべてがで実装された`CFrameWnd::OnUpdateKeyIndicator`、コマンド ID を使用して、適切な仮想キーにマップする実装ヘルパー。 一般的な実装を有効または無効にします (状態のペインが無効になっている = なしテキスト)、`CCmdUI`仮想キーが現在ロックされているかどうかに依存するオブジェクト。

このコマンド ハンドラーのカスタマイズは推奨されません。

- ID_INDICATOR_EXT :拡張選択インジケーター。

- ID_INDICATOR_OVR:上書きインジケーター。

- ID_INDICATOR_REC:録画のインジケーター。

現在これらのインジケーターの標準の実装ではありません。

これらのインジケーターの Id と、ステータス バー、インジケーターの順序を使用するをお勧めこれらのインジケーターを実装するために選択した場合 (つまり、この順序で。EXT、CAP、NUM、SCRL、上書、推奨値)。

## <a name="see-also"></a>関連項目

[番号順テクニカル ノート](../mfc/technical-notes-by-number.md)<br/>
[カテゴリ別テクニカル ノート](../mfc/technical-notes-by-category.md)
