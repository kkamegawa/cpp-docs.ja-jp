---
title: TN021:コマンドとメッセージのルーティング
ms.date: 06/28/2018
f1_keywords:
- vc.routing
helpviewer_keywords:
- TN021
- command routing [MFC], technical note TN021
- Windows messages [MFC], routing
ms.assetid: b5952c8b-123e-406c-a36d-a6ac7c6df307
ms.openlocfilehash: ce8aa2013c8f2f351ca1028f0d6103135ba5ecd8
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2019
ms.locfileid: "62306182"
---
# <a name="tn021-command-and-message-routing"></a>TN021:コマンドとメッセージのルーティング

> [!NOTE]
>  次のテクニカル ノートは、最初にオンライン ドキュメントの一部とされてから更新されていません。 結果として、一部のプロシージャおよびトピックが最新でないか、不正になります。 最新の情報について、オンライン ドキュメントのキーワードで関係のあるトピックを検索することをお勧めします。

ここでは、コマンドのルーティングとディスパッチのアーキテクチャと全般的なウィンドウのメッセージのルーティングでの高度なトピックについて説明します。

参照してください Visual C 全般の詳細について、ここで説明するアーキテクチャの Windows メッセージ、コントロールの通知、およびコマンドの違いでは特にです。 このノートには、印刷されたドキュメントで説明されている問題をよく理解して、非常に高度なトピックについてのみ説明前提としています。

## <a name="command-routing-and-dispatch-mfc-10-functionality-evolves-to-mfc-20-architecture"></a>MFC 2.0 にコマンド ルーティングとディスパッチの MFC 1.0 機能の進化のアーキテクチャ

Windows では、メニュー コマンド、アクセラレータ キー、およびダイアログ コントロールの通知の通知を提供するオーバー ロードは WM_COMMAND メッセージがあります。

MFC 1.0 上に構築されたを少しにより、コマンド ハンドラー (たとえば、"OnFileNew")、`CWnd`特定 WM_COMMAND への応答が呼び出されるクラスを派生します。 これは、メッセージ マップと呼ばれるデータ構造と共に接着し、領域を非常に効率よくコマンド メカニズムになります。

MFC の 1.0 では、コマンド メッセージからのコントロールの通知を分離するための追加機能も提供されます。 コマンドはコマンド ID とも呼ばれる、16 ビットの ID で表されます。 コマンドは、通常から開始、 `CFrameWnd` (つまり、メニューの またはアクセラレータ) と、さまざまな他のウィンドウにルーティングされます。

MFC の 1.0 では、マルチ ドキュメント インターフェイス (MDI) の実装の制限の意味でのコマンド ルーティングを使用します。 (MDI フレーム ウィンドウは、アクティブな MDI 子ウィンドウにコマンドを委任します)。

この機能は一般化され、広範なオブジェクト (ウィンドウ オブジェクトだけでなく) によって処理されるコマンドを許可するには MFC 2.0 で拡張します。 形式的を提供し、ルーティングの拡張可能なアーキテクチャがメッセージをコマンド、コマンドの処理だけでなく、コマンドの現在の状況を反映するように、(メニュー項目やツールバーのボタン) などの UI オブジェクトを更新するためもルーティングされているターゲットを再利用.

## <a name="command-ids"></a>コマンド ID

コマンドのルーティングとバインド プロセスの詳細については、Visual C を参照してください。 [テクニカル ノート 20](../mfc/tn020-id-naming-and-numbering-conventions.md) ID の名前付けに関する情報が含まれます。

ジェネリックのプレフィックス id「_」は、コマンド Id を使用します。 コマンド Id は > = 0x8000 です。 メッセージ行やステータス バーは、コマンドの説明文字列を表示はコマンド ID と同じ Id を持つ STRINGTABLE リソースがあるかどうか

アプリケーションのリソースでは、複数の場所でコマンド ID が表示されます。

- STRINGTABLE の 1 つのリソースでは、メッセージ行プロンプトと同じ ID を持ちます。

- で多くのメニュー リソースを同じコマンドを呼び出すメニュー項目にアタッチされています。

- (詳細) GOSUB コマンドのダイアログ ボタンをクリックします。

アプリケーションのソース コードでは、複数の場所でコマンド ID が表示されます。

- リソース。H (または他のメイン シンボル ヘッダー ファイル) をアプリケーションに固有のコマンド Id を定義します。

- おそらく ID 配列にツールバーを作成するために使用します。

- ON_COMMAND マクロでは。

- おそらくで an ON_UPDATE_COMMAND_UI マクロ。

現時点ではコマンド Id を必要とする MFC での唯一の実装で > = 0x8000 は GOSUB ダイアログ]/[コマンドの実装。

## <a name="gosub-commands-using-command-architecture-in-dialogs"></a>ダイアログ ボックスでコマンド アーキテクチャを使用して、GOSUB コマンド

ルーティングと有効にするコマンドのコマンドのアーキテクチャはフレーム ウィンドウ、メニュー項目、ツール バー ボタン、ダイアログ バーのボタン、その他のコントロール バー、およびその他のユーザー インターフェイス要素をコマンドで更新または Id を主に制御するように設計に連動コマンド ターゲット (通常はメイン フレーム ウィンドウ)。 メイン コマンド ターゲットは、必要に応じてその他のコマンド ターゲット オブジェクトにコマンドまたはコントロールの通知をルーティングする可能性があります。

適切なコマンド ID に、ダイアログ コントロールのコントロール ID を割り当てた場合、ダイアログ ボックス (モーダルまたはモードレス) がコマンドのアーキテクチャの機能の一部を活用できます。 ダイアログのサポートは自動ではないため、追加コードを記述する必要があります。

これらすべての機能を適切に機能では、コマンドは、Id があることに注意してください > 0x8000 を = です。 共有コマンドがする必要がありますので、多くのダイアログと同じフレームにルーティングされる可能性があります、> = 0x8000、特定のダイアログで、非共有の Idc をする必要があります < 0x7FFF を = です。

通常のボタンを配置するには適切なコマンド ID に設定 ボタンの IDC で標準のモーダル ダイアログ ボックス ユーザーがボタンを選択 ダイアログ ボックス (通常はメイン フレーム ウィンドウ) の所有者は、他のコマンドと同様のコマンドを取得します。 別のダイアログ ボックス (最初のダイアログ ボックスの GOSUB) を表示、通常使用されるため GOSUB コマンドが呼び出されます。

関数を呼び出すこともできます`CWnd::UpdateDialogControls`ダイアログ ボックスで、メイン フレーム ウィンドウのアドレスを渡します。 この関数を有効にするまたはフレーム内にコマンド ハンドラーがあるかどうかに基づいて、ダイアログのコントロールを無効にします。 この関数は自動的に呼び出されますが、アプリケーションのアイドル状態のループ内にコントロール バーが、この機能が必要な通常のダイアログ ボックスの直接呼び出す必要があります。

## <a name="when-onupdatecommandui-is-called"></a>ON_UPDATE_COMMAND_UI が呼び出された場合

プログラムのすべてのメニュー項目の有効になっているチェック状態のすべての時間を維持する計算コストが高い問題になることができます。 一般的な手法は、ユーザーが、ポップアップを選択した場合にのみ有効にする/メニュー項目をチェック. MFC 2.0 実装`CFrameWnd`ポインター メッセージを処理し、ON_UPDATE_COMMAND_UI ハンドラーを使用してメニューの状態を特定のコマンド ルーティングのアーキテクチャを使用します。

`CFrameWnd` また、ステータス バー (メッセージ行とも呼ばれます) で選択したアイテムの現在のメニューを記述する WM_ENTERIDLE メッセージを処理します。

ビジュアル編集アプリケーションのメニュー構造C++は、潜在的なコマンドを表すために使用します。 ON_UPDATE_COMMAND_UI ハンドラーでは、状態や、メニューのテキストを変更したり、(ファイルの MRU 一覧や OLE 動詞のポップアップ メニュー) などの高度な用途のため実際には、構造の変更 メニューのメニューが描画される前にすることができます。

ツールバー (およびその他のコントロール バー) の ON_UPDATE_COMMAND_UI 処理の同じ並べ替えを行います、アプリケーションがアイドル状態のループに入ったとき。 参照してください、*クラス ライブラリ リファレンス*と[テクニカル ノート 31](../mfc/tn031-control-bars.md)コントロール バーの詳細についてはします。

## <a name="nested-pop-up-menus"></a>入れ子になったポップアップ メニュー

入れ子になったメニュー構造を使用している場合、ポップアップ メニューの最初のメニュー項目に対するが 2 つの異なるケースと呼ばれることがわかります。

最初に、ポップアップ メニュー自体に呼び出されます。 これは、機能は、ポップアップ メニュー Id がないと、ポップアップ メニューの最初のメニュー項目の ID を使用して、全体のポップアップ メニューを参照したため必要です。 ここで、*コマンドを示して*のメンバー変数、`CCmdUI`オブジェクトが非 NULL になり、ポップアップ メニューをポイントします。

次に、ポップアップ メニューにメニュー項目が描画される直前に呼び出されます。 この場合、最初のメニュー項目にこの ID は、*コマンドを示して*のメンバー変数、`CCmdUI`オブジェクトは NULL になります。

これにより、そのメニュー項目から個別のポップアップ メニューを有効にすることができますが、メニューが認識するいくつかのコードを記述する必要があります。 たとえば、次の構造で入れ子になったメニュー: で

```Output
File>
    New>
    Sheet (ID_NEW_SHEET)
    Chart (ID_NEW_CHART)
```

ID_NEW_SHEET と ID_NEW_CHART コマンドを個別に有効または無効にできます。 **新規**2 つのいずれかが有効な場合、ポップアップ メニューが有効にする必要があります。

ID_NEW_SHEET (ポップアップ ウィンドウでの最初のコマンド) のコマンド ハンドラーのようになります。

```cpp
void CMyApp::OnUpdateNewSheet(CCmdUI* pCmdUI)
{
    if (pCmdUI->m_pSubMenu != NULL)
    {
        // enable entire pop-up for "New" sheet and chart
        BOOL bEnable = m_bCanCreateSheet || m_bCanCreateChart;
        // CCmdUI::Enable is a no-op for this case, so we
        // must do what it would have done.
        pCmdUI->m_pMenu->EnableMenuItem(pCmdUI->m_nIndex,
            MF_BYPOSITION |
            (bEnable  MF_ENABLED : (MF_DISABLED | MF_GRAYED)));

        return;
    }
    // otherwise just the New Sheet command
    pCmdUI->Enable(m_bCanCreateSheet);
}
```

ID_NEW_CHART に対するコマンド ハンドラーは、通常の更新コマンド ハンドラーと以下のような外観になります。

```cpp
void CMyApp::OnUpdateNewChart(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_bCanCreateChart);
}
```

## <a name="oncommand-and-onbnclicked"></a>ON_COMMAND と ON_BN_CLICKED

メッセージ マップ マクロ**ON_COMMAND**と**ON_BN_CLICKED**は同じです。 MFC コマンドとコントロール通知ルーティング メカニズムは、のみをルーティングするのに場所を決定するのにコマンド ID を使用します。 0 のコントロール通知コードを使用した通知の制御 (**BN_CLICKED**) はコマンドとして解釈されます。

> [!NOTE]
> 実際には、すべてのコントロールの通知メッセージは、コマンド ハンドラーのチェーンを通過します。 たとえば、コントロール通知ハンドラーを記述するための技術的に可能は**EN_CHANGE**ドキュメント クラスにします。 この機能の実際のアプリケーションがいくつかで、ClassWizard では、機能はサポートされていない機能の使用、脆弱なコードのため一般に賢明ではないです。

## <a name="disabling-the-automatic-disabling-of-button-controls"></a>ボタン コントロールの自動無効化を無効にします。

ダイアログ バーのボタン コントロールを配置するか、where を使用する ダイアログ ボックスを呼び出す場合**ダイアログ**がの場合、そのボタンがない注目してください**ON_COMMAND**または **。ON_UPDATE_COMMAND_UI**ハンドラーが自動的に無効になりますが、フレームワークによって。 場合によってで、ハンドラーが存在する必要はありませんが、ボタンを有効にしておく必要があります。 これを実現する最も簡単な方法がダミー コマンド ハンドラー (ClassWizard で行う簡単な) を追加するには何も操作を行います。

## <a name="window-message-routing"></a>ウィンドウ メッセージのルーティング

次の MFC クラスと Windows メッセージのルーティングおよびその他のトピックに及ぼす影響にいくつかのより高度なトピックについて説明します。 ここにある情報が簡単に説明のみです。 参照してください、*クラス ライブラリ リファレンス*詳細については、パブリック Api。 実装の詳細についての詳細については、MFC ライブラリのソース コードを参照してください。

参照してください[テクニカル ノート 17:](../mfc/tn017-destroying-window-objects.md)詳細ウィンドウのクリーンアップについては、すべての非常に重要なトピックの**CWnd**-クラスを派生します。

## <a name="cwnd-issues"></a>CWnd の問題

実装メンバー関数は、 **CWnd::OnChildNotify**をフックまたはそれ以外の場合に通知するメッセージ、コマンド、およびコントロールの子ウィンドウ (コントロールとも呼ばれます) の強力で拡張可能なアーキテクチャを提供します。親 (または「所有者」) に通知します。 場合子ウィンドウ (/制御) が C++ **CWnd**オブジェクト自体には、仮想関数**OnChildNotify**パラメーターを使用して、元のメッセージから最初に呼び出される (つまり、 **MSG**構造)。 子ウィンドウは、メッセージをそのまま、食べ、または (まれな) の親のメッセージを変更します。

既定の**CWnd**実装は、次のメッセージを処理しを使用して、 **OnChildNotify**フックのメッセージを最初のアクセスに windows (コントロール) を子に許可します。

- **よう**と**WM_DRAWITEM** (自己描画)

- **WM_COMPAREITEM**と**WM_DELETEITEM** (自己描画)

- **兄弟**と**WM_VSCROLL**

- **WM_CTLCOLOR**

- **WM_PARENTNOTIFY**

**OnChildNotify**フックが自己描画メッセージをオーナー描画メッセージを変更するためです。

加え、 **OnChildNotify**フック、スクロール メッセージがある動作をさらにルーティングします。 スクロール バーとのソースの詳細については以下をご覧ください**し**と**WM_VSCROLL**メッセージ。

## <a name="cframewnd-issues"></a>CFrameWnd の問題

**CFrameWnd**クラスのほとんどのユーザー インターフェイスとコマンドのルーティングを提供する実装を更新します。 これは主に、アプリケーションのメイン フレーム ウィンドウの使用 (**:m_pmainwnd**) がすべてのフレーム ウィンドウに適用されます。

メイン フレーム ウィンドウ、メニュー バーで、ウィンドウ、ステータス バーの親であるか、メッセージの行。 上記のコマンド ルーティングについての説明を参照してくださいと**ポインター。**

**CFrameWnd**クラスは、アクティブなビューの管理を提供します。 次のメッセージは、アクティブなビューを介してルーティングされます。

- すべてのコマンド メッセージ (アクティブなビューでは、それらへの最初のアクセスを取得します)。

- **兄弟**と**WM_VSCROLL**兄弟からのメッセージのスクロール バー (下記参照)。

- **WM_ACTIVATE** (と**WM_MDIACTIVATE** MDI の) 仮想関数の呼び出しに**CView::OnActivateView**します。

## <a name="cmdiframewndcmdichildwnd-issues"></a>CMDIFrameWnd/CMDIChildWnd の問題

両方の MDI フレーム ウィンドウ クラスから派生**CFrameWnd**で提供されるユーザー インターフェイスの更新とそのため、両方を有効に同様のコマンド ルーティングの**CFrameWnd**します。 一般的な MDI アプリケーションでは、メイン フレーム ウィンドウのみ (つまり、 **CMDIFrameWnd**オブジェクト) メニュー バーおよびステータス バーを保持し、コマンド ルーティングの実装の主なソースであるため。

一般的なルーティング スキームは、アクティブな MDI 子ウィンドウがコマンドの最初のアクセスを取得します。 既定の**PreTranslateMessage**関数 (最初) に両方の MDI 子ウィンドウのアクセラレータ テーブルを処理して MDI フレーム (秒) と通常によって処理される標準の MDI システム コマンド アクセラレータ**TranslateMDISysAccel** (最後)。

## <a name="scroll-bar-issues"></a>スクロール バーの問題

スクロール メッセージを処理するときに (**し**/**OnHScroll**や**WM_VSCROLL**/**OnVScroll**)、スクロール バーのメッセージが元に依存しないため、ハンドラーのコードを記述しようとする必要があります。 これにはスクロール メッセージには true。 スクロール バー コントロールから由来するので、[全般] の Windows 問題だけではありません**WS_HSCROLL**/**WS_VSCROLL**スクロール バーのスクロール バー コントロールではないです。

MFC の拡張を子または兄弟スクロールされるウィンドウのスクロール バー コントロールできるようにすること (実際には、スクロール バーとスクロールされるウィンドウ間の親/子リレーションシップ何でもかまいません)。 これは、分割ウィンドウで、共有のスクロール バーの特に重要です。 参照してください[テクニカル ノート 29:](../mfc/tn029-splitter-windows.md)の実装について詳しく**CSplitterWnd**で詳細を含むスクロール バーの問題を共有します。

ちなみにには、2 つ**CWnd**で指定されたスクロール バーのスタイル作成時の派生クラスがトラップされ、Windows には渡されません。 作成ルーチンに渡される**WS_HSCROLL**と**WS_VSCROLL**個別に設定できますは作成を変更することはできません。 もちろん、テストや、自分で作成したウィンドウの WS_SCROLL スタイル ビットを設定する必要があります直接的にではありません。

**CMDIFrameWnd**スクロール バーのスタイルに渡す**作成**または**LoadFrame** クイック ウォッチの作成に使用します。 スクロール バーのスタイルの両方で、スクロール可能な MDICLIENT 領域 (など、Windows プログラム マネージャー) を設定することを確認する必要がある場合 (**WS_HSCROLL** &#124; **WS_VSCROLL**)、を作成するために使用したスタイルの**CMDIFrameWnd**します。

**CSplitterWnd**スプリッター リージョンの特別な共有のスクロール バーにスクロール バーのスタイルを適用します。 静的分割ウィンドウでは、通常は、どちらのスクロール バー スタイルを設定します。 動的分割ウィンドウでは、スクロール バー スタイルのセットに分割する、つまり、方向は、通常必要が**WS_HSCROLL** 、行を分割することができる場合**WS_VSCROLL**列を分割する場合。

## <a name="see-also"></a>関連項目

[番号順テクニカル ノート](../mfc/technical-notes-by-number.md)<br/>
[カテゴリ別テクニカル ノート](../mfc/technical-notes-by-category.md)
