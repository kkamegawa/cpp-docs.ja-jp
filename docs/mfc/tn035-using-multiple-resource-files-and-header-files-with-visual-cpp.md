---
title: 'テクニカル ノート 35: Visual C++ における複数のリソース ファイルとヘッダー ファイルの使用'
ms.date: 11/04/2016
f1_keywords:
- vc.resources
helpviewer_keywords:
- resource files, multiple
- TN035
ms.assetid: 1f08ce5e-a912-44cc-ac56-7dd93ad73fb6
ms.openlocfilehash: 23d4fdeb82ed7eea97a104e111cd022a87626df4
ms.sourcegitcommit: a5fa9c6f4f0c239ac23be7de116066a978511de7
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/20/2019
ms.locfileid: "75302173"
---
# <a name="tn035-using-multiple-resource-files-and-header-files-with-visual-c"></a>テクニカル ノート 35: Visual C++ における複数のリソース ファイルとヘッダー ファイルの使用

> [!NOTE]
> 次のテクニカル ノートは、最初にオンライン ドキュメントの一部とされてから更新されていません。 結果として、一部のプロシージャおよびトピックが最新でないか、不正になります。 最新の情報について、オンライン ドキュメントのキーワードで関係のあるトピックを検索することをお勧めします。

このノートでは、Visual C++ のリソース エディターが、単一プロジェクト内または複数のプロジェクト間で共有されている複数のリソース ファイルとヘッダー ファイルをサポートする方法と、そのサポートを活用する方法について説明します。 このノートでは、次の質問に回答します。

- プロジェクトを複数のリソースファイルやヘッダーファイル、あるいはその両方に分割する必要がある場合

- 共通ヘッダーを共有する方法。H ファイルの2つです。RC ファイル

- プロジェクトリソースを複数のに分割するにはどうすればよいでしょうか。RC ファイル

- (およびツール) では、との間でビルドの依存関係を管理します。RC、。CPP、および。H ファイル

プロジェクトに追加のリソース ファイルを追加した場合は、追加されたファイル内のリソースを ClassWizard が認識しないことに注意してください。

このノートは、上記の質問に回答するために次のように構成されています。

- **Visual C++がリソースファイルとヘッダーファイル**をどのように管理するかの概要について説明しますC++ 。これにより、visual のリソースセットインクルードコマンドで、同じプロジェクト内の複数のリソースファイルとヘッダーファイルを使用できるようになります。

- **AppWizard で作成された分析。RC と。H ファイル**は、AppWizard で作成されたアプリケーションによって使用される複数のリソースファイルとヘッダーファイルを参照します。 これらのファイルは、プロジェクトに追加する可能性のあるリソース ファイルやヘッダー ファイルの適切なモデルとして機能します。

- **ヘッダーファイルを追加**すると、複数のヘッダーファイルを含める必要がある場所が記述され、詳細が示されます。

- **ヘッダーファイルを2つの間で共有する。RC ファイル**は、1つのヘッダーファイルを複数の間で共有する方法を示しています。異なるプロジェクト内または同じプロジェクト内の RC ファイル。

- **同じプロジェクト内の複数のリソースファイルを使用**すると、プロジェクトを複数のに分割する場所が記述されます。RC ファイルを提供し、その方法について詳しく説明します。

- **編集できないビジュアルC++ファイルの適用**によって、ビジュアルC++がカスタムリソースを編集したり、意図せずに再フォーマットしたりしないようにする方法について説明します。

- **複数のビジュアルC++編集によって共有されるシンボルの管理。RC ファイル**では、複数ので同じシンボルを共有する方法を説明します。RC ファイルと、重複する ID 数値の割り当てを回避する方法について説明します。

- **間の依存関係の管理RC、。CPP、および。H ファイル**は、Visual C++が不要な再コンパイルを回避する方法を説明します。リソースシンボルファイルに依存する CPP ファイル。

- **ビジュアルC++** でのインクルードの設定の詳細についてはC++ 、ビジュアルが複数の (入れ子になった) を追跡する方法に関する技術的な詳細情報を提供します。RC ファイルと、によって #include される複数のヘッダーファイル。RC ファイル。

## <a name="overview-of-how-visual-c-manages-resource-files-and-header-files"></a>Visual C++ がリソース ファイルとヘッダー ファイルを管理する方法の概要

Visual C++ では、単一の .RC リソース ファイルとそれに対応する .H ヘッダー ファイルを、緊密に結合されたファイル ペアとして管理します。 .RC ファイル内でリソースを編集および保存すると、対応する .H ファイル内でシンボルを間接的に編集および保存することになります。 (Visual C++ の MDI ユーザー インターフェイスを使用して) 一度に複数の .RC ファイルを開いて編集することができますが、任意の .RC ファイルを対象として、ただ 1 つの対応するヘッダー ファイルを間接的に編集していることになります。

### <a name="symbol-header-file"></a>[シンボル用のヘッダー ファイル]

既定では、リソース ファイル (たとえば、MYAPP.RC) の名前にかかわりなく、Visual C++ は対応するヘッダー ファイルに必ず RESOURCE.H という名前を付けます。 **[表示]** メニュー C++の **[リソースのインクルード]** コマンドを使用して、このヘッダーファイルの名前を変更するには、インクルードファイルの **[設定]** ダイアログボックスでシンボルヘッダーファイルファイルを更新します。

### <a name="read-only-symbol-directives"></a>[読み取り専用ヘッダー ファイル]

Visual C++ はどの特定の .RC ファイルに対しても 1 つのヘッダー ファイルのみを編集しますが、Visual C++ では追加の読み取り専用ヘッダー ファイル内で定義されているシンボルへの参照をサポートします。 ビジュアルC++の **[表示]** メニューの **[リソースのインクルード]** コマンドを使用すると、追加の読み取り専用ヘッダーファイルを読み取り専用のシンボルディレクティブとして指定できます。 "読み取り専用" という制限は .RC ファイル内で新しいリソースを追加するときに、読み取り専用ヘッダー ファイル内で定義されたシンボルを使用できること、ただし、リソースを削除した場合でも、シンボルは引き続き読み取り専用ヘッダー ファイル内で定義されたままになることを意味します。 読み取り専用シンボルに対して割り当てられた数値を変更することはできません。

### <a name="compile-time-directives"></a>[コンパイル時に追加するファイル]

Visual C++ ではリソース ファイルの入れ子、つまり .RC ファイルの中で #include を使用し、他の .RC ファイルをインクルードする方法をサポートしています。 Visual C++ を使用して特定の .RC ファイルを編集すると、#include によってインクルードされたファイル内のどのリソースも表示されません。 ただし、その .RC ファイルをコンパイルするときに、#include によってインクルードされたファイルもコンパイルされます。 Visual C++の **[表示]** メニューの **[リソースのインクルード]** コマンドを使用すると、任意の数の #include を指定できます。コンパイル時のディレクティブとしての RC ファイル。

ビジュアルC++を読み込むとどうなるかに注意してください。RC ファイルは別の #include ます。コンパイル時のディレクティブとして指定されて*いない*RC ファイル。 この状況は、以前にテキスト エディターを使用して手動で保守していた .RC ファイルを、Visual C++ に読み込む場合に発生する可能性があります。 Visual C++ は インクルードされた .RC ファイルを読み取る場合は、インクルードされたリソースを親 .RC ファイルにマージします。 親 .RC ファイルを保存するときに、#include ステートメントは実際には、インクルードされたリソースで置き換えられます。 このマージが行われないようにするには、#include ステートメントを親から削除する必要があります。RC ファイルをビジュアルC++に読み込む前に、次に、 C++ビジュアルを使用して、コンパイル時のディレクティブと同じ #include ステートメントを再び追加します。

ビジュアルC++はに保存されます。RC ファイル: 上記の3種類のセットには、#include ディレクティブ*および*textinclude リソースの情報 (シンボルヘッダーファイル、読み取り専用のシンボルディレクティブ、およびコンパイル時のディレクティブ) が含まれています。 TEXTINCLUDE リソースには、通常は対処する必要のない実装の詳細が記載されています。詳細については、「[ビジュアルC++管理の設定に関する情報](#_mfcnotes_tn035_set_includes)」を参照してください。

## <a name="analysis-of-appwizard-created-rc-and-h-files"></a>AppWizard で作成した .RC ファイルと .H ファイルの分析

AppWizard が生成したアプリケーション コードを調べると、Visual C++ が複数のリソース ファイルとヘッダー ファイルを管理する方法を把握できます。 以下で検討するコードは、既定のオプションを使用して AppWizard で生成した MYAPP アプリケーションから抜粋したものです。

AppWizard で作成したアプリケーションは、次の図に要約するように、複数のリソース ファイルと複数のヘッダー ファイルを使用します。

```Diagram
   RESOURCE.H     AFXRES.H
          \       /
           \     /
          MYAPP.RC
              |
              |
        RES\MYAPP.RC2
        AFXRES.RC
        AFXPRINT.RC
```

Visual C++ の [ファイル] - [インクルード ファイルの設定] コマンドを使用して、これら複数のファイルの関係を表示できます。

MYAPP.EXE.リターン
Visual C++ を使用して編集する、アプリケーションのリソース ファイル。

RESOURCE.H は、アプリケーション固有のヘッダー ファイルです。 Visual C++ のヘッダー ファイルの既定の名前付けに整合した方法で、このファイルに対して AppWizard によって必ず RESOURCE.H という名前が付けられます。 このヘッダー ファイルに対応する #include は、リソース ファイル (MYAPP.RC) 内の最初のステートメントです。

```rc
//Microsoft Visual C++ generated resource script
//
#include "resource.h"
```

RES\MYAPP.Rc
Visual C++ の編集対象にならないが、最後にコンパイルされる .EXE ファイルに含まれることになるリソースが格納されています。 Visual C++ は (このリリースの新しい機能である) バージョン リソースを含め、標準のリソースすべてを編集できるため、AppWizard は既定ではこのようなリソースを作成しません。 開発者が独自のカスタム形式リソースをこのファイルに追加しようとする場合は、AppWizard によって空のファイルが生成されます。

カスタム形式リソースを使用する場合は、そのリソースを RES\MYAPP.RC2 に追加し、Visual C++ のテキスト エディターを使用して編集することができます。

AFXRES.RC と AFXPRINT.RC には、フレームワークの一部の機能で必要とされる標準的なリソースが含まれます。 RES\MYAPP.RC2 と同様に、フレームワークによって提供されるこれらの 2 つは MYAPP.RC の最後にインクルードされるリソース ファイルです。またこれらは、[インクルード ファイルの設定] ダイアログ ボックスの [コンパイル時に追加するファイル] で指定されます。 したがって、Visual C++ で MYAPP.RC を編集するときに、これらのフレームワーク リソースを直接表示または編集することはありませんが、これらはアプリケーションのバイナリ .RES ファイルと最終的な .EXE ファイルにコンパイルされます。 標準フレームワークリソースの変更手順などの詳細については、「[テクニカルノート 23](../mfc/tn023-standard-mfc-resources.md)」を参照してください。

AFXRES.H は、フレームワークによって使用され、特に AFXRES.RC 内で使用される、`ID_FILE_NEW` のような標準的なシンボルを定義します。 また、AFXRES.H 内の #include で指定されている WINRES.H には、WINDOWS.H のサブセットが含まれていて、これらは AFXRES.RC と同様、Visual C++ によって生成される .RC ファイルで必要とされるものです。 AFXRES.H 内で定義されたシンボルは、アプリケーションのリソース ファイル (MYAPP.RC) を編集するときに使用できます。 たとえば、`ID_FILE_NEW` は MYAPP.RC 内のメニュー リソースにある File New メニュー項目に関連して使用されます。 フレームワークで定義されたこれらのシンボルを変更または削除することはできません。

## <a name="_mfcnotes_tn035_including"></a>追加のヘッダーファイルを含める

AppWizard で作成したアプリケーションには、RESOURCE.H、および AFXRES.H という 2 つのヘッダー ファイルのみが含まれています。 RESOURCE.H のみがアプリケーション固有です。 次の状況では、追加の読み取り専用なヘッダー ファイルをインクルードする必要が生じることがあります。

ヘッダー ファイルは、外部ソースから提供することがあります。または、複数のプロジェクト間でヘッダー ファイルを共有するか、同じプロジェクトの複数の部分で共有することもあります。

ヘッダー ファイルには形式とコメントがあり、そのファイルを保存するときに、Visual C++ がこれらに変更を加えるか除外することは望ましくありません。 たとえば、次のようにシンボル算術演算を使用する #define を保持したいとします。

```h
#define RED 0
#define BLUE 1
#define GREEN 2
#define ID_COLOR_BUTTON 1001
#define ID_RED_BUTTON (ID_COLOR_BUTTON + RED)
#define ID_BLUE_BUTTON (ID_COLOR_BUTTON + BLUE)
#define ID_GREEN_BUTTON (ID_COLOR_BUTTON + GREEN)
```

次のように、**リソースインクルード**コマンドを使用して、#include ステートメントを2番目の読み取り専用シンボルディレクティブとして指定することにより、追加の読み取り専用ヘッダーファイルを含めることができます。

```rc
#include "afxres.h"
#include "second.h"
```

ファイル関係の新しい図は次のようになります。

```Diagram
                   AFXRES.H
    RESOURCE.H     SECOND.H
          \       /
           \     /
          MYAPP.RC
              |
              |
        RES\MYAPP.RC2  
        AFXRES.RC
        AFXPRINT.RC
```

## <a name="sharing-a-header-file-between-two-rc-files"></a>2 つの .RC ファイル間でのヘッダー ファイルの共有

異なるプロジェクト内、または多くの状況では同じプロジェクト内にある、2 つの .RC ファイル間で 1 つのヘッダー ファイルを共有したいと考えることがあります。 この作業を行うには、既に説明した [読み取り専用ヘッダー ファイル] の手法を両方の .RC ファイルに適用します。 2 つの .RC ファイルが別のアプリケーション (別のプロジェクト) に対応している場合は、結果は次の図に示すとおりです。

```Diagram
     RESOURCE.H   AFXRES.H   RESOURCE.H  
    (for MYAPP1)  SECOND.H   (for MYAPP2)
          \       /     \       /
           \     /       \     /
          MYAPP1.RC      MYAPP2.RC
           /    \        /     \
          /      \      /       \
RES\MYAPP1.RC2  AFXRES.RC     RES\MYAPP2.RC2
                AFXPRINT.RC
```

2 番目のヘッダー ファイルが、同じアプリケーション (プロジェクト) 内の 2 つの .RC ファイルによって共有される状況は、後で説明します。

## <a name="using-multiple-resource-files-in-the-same-project"></a>同じプロジェクト内での複数のリソース ファイルの使用

Visual C++ およびリソース コンパイラは、1 つの .RC ファイル内で #include を使用して別の .RC ファイルをインクルードする方法で、同じプロジェクト内で複数の .RC ファイルをサポートします。 複数の入れ子も許可されます。 プロジェクトのリソースを複数の .RC ファイルに分割するさまざまな理由があります。

- リソース ファイルを複数の .RC ファイルに分割した場合は、複数のプロジェクト チーム メンバーの間で多数のリソースを容易に管理できるようになります。 ファイルのチェックアウトおよび変更のチェックインの目的でソース管理パッケージを使用する場合は、リソースを複数の .RC ファイルに分割すると、リソースに対する変更の管理全体をより詳細に制御できるようになります。

- #ifdef、#endif、#define のようなプリプロセッサ ディレクティブを使用する場合は、リソースの一部を対象として、リソース コンパイラによってコンパイルされる読み取り専用リソースの中にそれらを分離する必要があります。

- Visual C++ の中で、複数のコンポーネント .RC ファイルの読み込みと保存は、1 つの複合 .RC ファイルより高速に実行されます。

- テキスト エディターを使用して、人間が認識できる形式のリソースを維持することを希望する場合は、Visual C++ で編集する .RC ファイルとは別の .RC ファイルを用意し、その中で維持する必要があります。

- ユーザー定義のリソースを、別の特殊なデータ エディターで解釈できるバイナリまたはテキスト形式で保持する必要がある場合は、別の .RC ファイルでそのリソースを維持する必要があります。その結果、Visual C++ が形式を 16 進データに変更することはありません。 、.「MFC の高度な概念」サンプル[SPEAKN](../overview/visual-cpp-samples.md)の WAV (サウンド) ファイルリソースは、良い例です。

[インクルード ファイルの設定] ダイアログ ボックス内の [コンパイル時に追加するファイル] で、SECOND.RC の #include を指定できます。

```h
#include "res\myapp.rc2"  // non-Visual C++ edited resources
#include "second.rc"  // THE SECOND .RC FILE

#include "afxres.rc"  // Standard components
#include "afxprint.rc"  // printing/print preview resources
```

結果は次の図のようになります。

```Diagram
   RESOURCE.H     AFXRES.H
          \       /
           \     /
          MYAPP.RC
              |
              |
        RES\MYAPP.RC2
        SECOND.RC  
        AFXRES.RC
        AFXPRINT.RC
```

[コンパイル時に追加するファイル] を使用して、Visual C++ で編集可能なリソースと編集不可能なリソースを複数の .RC ファイルに編成することができます。ここで、"マスター" の MYAPP.RC は、他の .RC ファイルの #include を行うだけで、それ以外は何もしません。 Visual Studio C++プロジェクトを使用している場合。MAK ファイルの場合は、"マスター" を含める必要があります。すべての #include リソースがアプリケーションと共にコンパイルされるように、プロジェクト内の RC ファイル。

## <a name="enforcement-of-noneditable-visual-c-files"></a>編集不可能な Visual C++ ファイルの適用

AppWizard で作成した RES\MYAPP.RC2 ファイルは、誤ってビジュアルC++に読み取らず、書式情報が失われて書き戻す必要の*ない*リソースを含むファイルの例です。 このような事態を防止するには、RES\MYAPP.RC2 ファイルの先頭に次の行を記述します。

```rc2
#ifdef APSTUDIO_INVOKED
    #error this file is not editable by Visual C++
#endif //APSTUDIO_INVOKED
```

がをC++コンパイルするとき。RC ファイルは、`APSTUDIO_INVOKED` と `RC_INVOKED`を定義します。 仮に AppWizard で作成したファイル構造が破損していて、Visual C++ が上記の #error 行を読み取った場合は、Visual C++ は致命的なエラーを報告し、.RC ファイルの読み取りを中止します。

## <a name="managing-symbols-shared-by-multiple-visual-c-edited-rc-files"></a>Visual C++ で編集した複数の .RC ファイルで共有されるシンボルの管理

リソースを複数の .RC ファイルに分割し、それらを Visual C++ で個別に編集する場合は、2 つの問題が生じます。

- 複数の .RC ファイル間で同じシンボルを共有したいと考えることがあります。

- 個別のリソース (シンボル) に同じ ID 数値を割り当てることを避けるために、Visual C++ を支援する必要があります。

次の図に、最初の問題に対処するための .RC ファイルと .H ファイルの構成を示します。

```Diagram
              MYAPP.RC
             /         \
            /           \
MYSTRS.H   / MYSHARED.H  \  MYMENUS.H
     \    /    /      \   \    \
      \  /    /        \   \    \
      MYSTRS.RC         MYMENUS.RC
```

この例では、文字列リソースを 1 つのリソース ファイル、MYSTRS.RC に保存し、メニューを別のファイル、MYMENUS.RC で保持します。 コマンドなどに対応する一部のシンボルは、2 つのファイル間で共有する必要が生じることがあります。 たとえば、ID_TOOLS_SPELL は、[ツール] メニューの [スペル] 項目に対応するメニュー コマンド ID である可能性があります。または、これは、アプリケーションのメイン ウィンドウのステータス バー内で、フレームワークによって表示されるコマンド プロンプトの文字列 ID である可能性もあります。

ID_TOOLS_SPELL シンボルは、共有ヘッダー ファイル、MYSHARED.H 内で保持されます。 開発者はテキスト エディターを使用し、この共有ヘッダー ファイルを手動で保守します。Visual C++ がこのファイルを直接編集することはありません。 2つのリソースファイル (MYSTRS)。RC と MYMENUS。RC では #include MYSHARED を指定します。MYAPP の読み取り専用ディレクティブの H。RC では、前に説明したように、**リソースインクルード**コマンドを使用します。

リソースを識別するために使用する前に、共有するシンボルを予測すると最も便利です。 シンボルを共有ヘッダー ファイルに追加します.RC ファイルに対応する [読み取り専用のヘッダー ファイル] の中でまだ共有ヘッダー ファイルをインクルードしていない場合は、そのシンボルを使用する前に、#include を指定します。 シンボルをこの方法で共有することを想定していない場合は、たとえばシンボルを MYSTRS.RC 内で使用する前に、シンボルに対応する #define ステートメントを (テキスト エディターを使用して) 手動で MYMENUS.H から MYSHARED.H に移動する必要が生じます。

複数の .RC ファイル内でシンボルを管理する場合も、個別のリソース (シンボル) に対して同じ ID 数値を割り当てることを防止するために、Visual C++ を支援する必要があります。 特定の .RC ファイルに対して、Visual C++ は 4 つの ID ドメインのそれぞれで、インクリメンタル形式で ID を割り当てます。 複数の編集セッションの間も、Visual C++ は .RC ファイルに対応するシンボル ヘッダー ファイルの各ドメインで自らが最後に割り当てた ID を追跡しています。 次に、空の (新しい) .RC ファイルに対応する APS_NEXT の値を示します。

```rc
#define _APS_NEXT_RESOURCE_VALUE  101
#define _APS_NEXT_COMMAND_VALUE   40001
#define _APS_NEXT_CONTROL_VALUE   1000
#define _APS_NEXT_SYMED_VALUE     101
```

`_APS_NEXT_RESOURCE_VALUE` は、ダイアログリソース、メニューリソースなどに対して使用される次のシンボル値です。 リソース シンボル値の有効な値の範囲は 1 ～ 0x6FFF です。

`_APS_NEXT_COMMAND_VALUE` は、コマンド id に使用される次のシンボル値です。 コマンド シンボル値の有効な値の範囲は 0x8000 ～ xDFFF です。

`_APS_NEXT_CONTROL_VALUE` は、ダイアログコントロールに使用される次のシンボル値です。 ダイアログ コントロール値の有効な値の範囲は 8 ～ 0xDFFF です。

`_APS_NEXT_SYMED_VALUE` は、シンボルブラウザーで新しいコマンドを使用してシンボル値を手動で割り当てるときに発行される次のシンボル値です。

Visual C++ は、新しい .RC ファイルを作成するときに、最小の有効な値より少し大きい値を使用して割り当てを開始します。 AppWizard も、これらの値を、MFC アプリケーションに適切な値より少し大きい値に初期化します。 ID 値の範囲の詳細については、「[テクニカルノート 20](../mfc/tn020-id-naming-and-numbering-conventions.md)」を参照してください。

新しいリソースファイルを作成するたびに、同じプロジェクトであっても、Visual C++は同じ `_APS_NEXT_` 値を定義します。 これは、たとえば 2 つの異なる .RC ファイルの中で複数のダイアログを追加する場合に、異なるダイアログに対して #define の同じ値が割り当てられる可能性が非常に高いことを意味します。 たとえば、最初の .RC ファイル内の IDD_MY_DLG1 は、2 番目の .RC ファイル内にあるIDD_MY_DLG2 と同じ番号 101 を割り当てられる可能性があります。

これを回避するには、各 .RC ファイル内の 4 つの ID ドメインのそれぞれで、個別の数値範囲を予約する必要があります。 この操作を行うには、各の `_APS_NEXT` 値を手動で更新します。リソースの追加を開始する**前に**、RC ファイルを作成します。 たとえば、最初の場合はです。RC ファイルでは既定の `_APS_NEXT` 値を使用するため、次の `_APS_NEXT` 値を2番目の値に割り当てることができます。RC ファイル:

```rc
#define _APS_NEXT_RESOURCE_VALUE  2000
#define _APS_NEXT_COMMAND_VALUE   42000
#define _APS_NEXT_CONTROL_VALUE   2000
#define _APS_NEXT_SYMED_VALUE     2000
```

もちろん、Visual C++ が最初の .RC ファイル内で多数の ID を割り当て、その結果、2 番目の .RC ファイル用に予約した ID 数値との重複が始まる可能性はあります。 この現象が発生しないように、十分に大きい範囲を予約する必要があります。

## <a name="managing-dependencies-between-rc-cpp-and-h-files"></a>.RC、.CPP、.H ファイル間の依存関係の管理

Visual C++ は .RC ファイルを保存するときに、シンボルに対する変更を、対応する RESOURCE.H ファイルに保存します。 .RC ファイル内のリソースを参照するあらゆる .CPP ファイルは、RESOURCE.H ファイルの #include を行う必要があります。これは通常、プロジェクトのマスター ヘッダー ファイル内で行うことになります。 この結果、ソース ファイル内でヘッダーの依存関係をスキャンする開発環境の内部プロジェクト管理が原因で、望ましくない副作用につながります。 ビジュアルC++に新しい記号を追加するたびに、すべてのが表示されます。リソースを #include する CPP ファイル。H を再コンパイルする必要があります。

Visual C++ では、RESOURCE.H ファイルの最初の行として次のコメントを含めることにより、RESOURCE.H の依存関係を回避できます。

```h
//{{NO_DEPENDENCIES}}
```

開発環境では RESOURCE.H に対する変更を無視することによってこのコメントを解釈し、依存先の .CPP ファイルの再コンパイルを不要にします。

Visual C++ は .RC ファイルを保存するときに必ず、.RC ファイルに//{{NO_DEPENDENCIES}} コメント行を追加します。 特定の状況では、RESOURCE.H に対するビルド依存関係を回避することが原因で、リンク時に検出されない実行時エラーが発生する可能性があります。 たとえば、再コンパイルされないリソースを .CPP ファイルが参照している状況で、シンボル ブラウザーを使用して、リソースのシンボルに対して割り当てられる数値を変更する場合は、そのリソースを正しく見つけることができず、アプリケーションの実行時にリソースが読み込まれません。 このような場合は、を明示的に再コンパイルする必要があります。使用していることがわかっている CPP ファイルは、リソースのシンボルの変更の影響を受けます。H または **[すべてリビルド]** を選択します。 特定のリソースグループのシンボル値を頻繁に変更する必要がある場合は、上記のセクションで説明したように、これらのシンボルを別の読み取り専用ヘッダーファイルに分割する方が便利で安全です。[その他のヘッダーファイルも含ま](#_mfcnotes_tn035_including)れます。

## <a name="_mfcnotes_tn035_set_includes"></a>ビジュアルC++管理に含まれる情報の設定

前述のように、[ファイル] メニューの [インクルード ファイルの設定] コマンドで 3 種類の情報を指定できます。

- [シンボル用のヘッダー ファイル]

- [読み取り専用ヘッダー ファイル]

- [コンパイル時に追加するファイル]

次に、Visual C++ がこれらの情報を .RC ファイル内で保持する方法について説明します。 Visual C++ を使用するうえでこの情報は必須ではありませんが、[インクルード ファイルの設定] に関する理解を深め、より自信を持ってこの機能を使用できるようになる可能性があります。

[インクルード ファイルの設定] の上記の 3 種類の情報それぞれは、.RC ファイル内に 2 つの形式で格納されます。(1) #include、またはリソース コンパイラで解釈可能な他のディレクティブ。および、(2) Visual C++ でのみ解釈買おうな特殊な TEXTINCLUDE リソース。

TEXTINCLUDE リソースの目的は、ビジュアルC++の [インクルードの**設定**] ダイアログボックスで簡単に表示できる形式で、設定されたインクルード情報を安全に格納することです。 TEXTINCLUDE は、ビジュアルC++によって定義されたリソースの種類です。 Visual C++ は、リソース ID 番号 1、2、および 3 を持つ、3 つの特定の TEXTINCLUDE リソースを認識します。

|TEXTINCLUDE のリソース ID|[インクルード ファイルの設定] 情報の種類|
|-----------------------------|--------------------------------------|
|1|[シンボル用のヘッダー ファイル]|
|2|[読み取り専用ヘッダー ファイル]|
|3|[コンパイル時に追加するファイル]|

[インクルード ファイルの設定] 情報のそれぞれは、以下で説明するように、AppWizard で作成した既定の MYAPP.RC および RESOURCE.H ファイルによって表現されます。 BEGIN および END ブロックの間にある追加の \0 および "" トークンは、0 で終端された文字列と二重引用符のそれぞれを指定する RC の構文にとって必須です。

### <a name="symbol-header-file"></a>[シンボル用のヘッダー ファイル]

リソース コンパイラによって解釈される [シンボル用のヘッダー ファイル] 情報の形式は、単純な #include ステートメントです。

```rc
#include "resource.h"
```

対応する TEXTINCLUDE リソースは次のとおりです。

```rc
1 TEXTINCLUDE DISCARDABLE
BEGIN
    "resource.h\0"
END
```

### <a name="read-only-symbol-directives"></a>[読み取り専用ヘッダー ファイル]

[読み取り専用ヘッダー ファイル] は、リソース コンパイラによる解釈が可能な次の形式で、MYAPP.RC の先頭でインクルードされます。

```rc
#include "afxres.h"
```

対応する TEXTINCLUDE リソースは次のとおりです。

```rc
2 TEXTINCLUDE DISCARDABLE
BEGIN
   "#include ""afxres.h""\r\n"
   "\0"
END
```

### <a name="compile-time-directives"></a>[コンパイル時に追加するファイル]

[コンパイル時に追加するファイル] は、リソース コンパイラによる解釈が可能な次の形式で、MYAPP.RC の最後でインクルードされます。

```rc
#ifndef APSTUDIO_INVOKED
///////////////////////
//
// From TEXTINCLUDE 3
//
#include "res\myapp.rc2"  // non-Visual C++ edited resources

#include "afxres.rc"  // Standard components
#include "afxprint.rc"  // printing/print preview resources
#endif  // not APSTUDIO_INVOKED
```

#ifndef APSTUDIO_INVOKED ディレクティブは、[コンパイル時に追加するファイル] をスキップするように Visual C++ に指示します。

対応する TEXTINCLUDE リソースは次のとおりです。

```rc
3 TEXTINCLUDE DISCARDABLE
BEGIN
"#include ""res\myapp.rc2""  // non-Visual C++ edited resources\r\n"
"\r\n"
"#include ""afxres.rc""  // Standard components\r\n"
"#include ""afxprint.rc""  // printing/print preview resources\r\n"
"\0"
END
```

## <a name="see-also"></a>関連項目

[番号\ 別のテクニカルノート](../mfc/technical-notes-by-number.md)
[カテゴリ別テクニカル ノート](../mfc/technical-notes-by-category.md)
