---
title: イベント (C++/CX)
description: /Cx を使用C++して、Windows ランタイムでイベントハンドラーを作成および使用する方法について説明します。
ms.date: 02/03/2020
ms.assetid: 31c8e08a-00ad-40f9-8f7e-124864aaad58
ms.openlocfilehash: 45f9a7bc17d9a695613ce551dae796b2cd2e0e6f
ms.sourcegitcommit: ba4180a2d79d7e391f2f705797505d4aedbc2a5e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/03/2020
ms.locfileid: "76972197"
---
# <a name="events-ccx"></a>イベント (C++/CX)

Windows ランタイム型は、イベントを宣言 (つまり、発行) できます。また、同じコンポーネントまたは他のコンポーネント内のクライアントコードは、イベント*ハンドラー*と呼ばれるメソッドをイベントに関連付けることによって、それらのイベントをサブスクライブできます。 複数のイベント ハンドラーを単一のイベントに関連付けることもできます。 発行オブジェクトがイベントを発生させた時点で、すべてのイベント ハンドラーが呼び出される結果になります。 この方法で、発行側がイベントを発生させたときに、サブスクライブ側クラスはあらゆる適切なカスタム アクションを実行できます。 各イベントには、そのイベントにサブスクライブしようとするすべてのイベント ハンドラーが所有している必要があるシグネチャを指定するデリゲート型があります。

## <a name="consuming-events-in-windows-components"></a>Windows コンポーネントでのイベントの利用

Windows ランタイムの多くのコンポーネントは、イベントを公開します。 たとえば、LightSensor オブジェクトは、センサーが新しい発光値を報告すると ReadingChanged イベントを発生させます。 プログラム内で LightSensor オブジェクトを使用する場合、ReadingChanged イベントが発生したときに呼び出されるメソッドを定義できます。 メソッドは、任意の処理を実行できます。唯一の要件は、その署名が呼び出されたデリゲートのシグネチャと一致する必要があることです。 デリゲートイベントハンドラーを作成し、イベントをサブスクライブする方法の詳細については、「[デリゲート](../cppcx/delegates-c-cx.md)」を参照してください。

## <a name="creating-custom-events"></a>カスタム イベントの作成

### <a name="declaration"></a>宣言

ref クラスまたはインターフェイスでイベントを宣言できます。イベントは、public、internal (public/private)、public protected、protected、private protected、または private のアクセシビリティを持つことができます。 イベントを宣言する場合、コンパイラは内部で、add および remove という 2 つのアクセサー メソッドを公開するオブジェクトを作成します。 サブスクライブ側のオブジェクトがイベント ハンドラーを登録した時点で、イベント オブジェクトはそれらのイベント ハンドラーをコレクションに格納します。 イベントが発生すると、イベント オブジェクトはリスト内のすべてのハンドラーを順番に呼び出します。 次の例のような単純なイベントには、暗黙のバッキング ストアと共に暗黙の `add` および `remove` アクセサー メソッドがあります。 また、プロパティにカスタムの `get` アクセサーと `set` アクセサーを指定するのと同じ方法で、独自のアクセサーを指定することもできます。  実装するクラスは、単純なイベントのイベント サブスクライバーの一覧内を手動で循環することはできません。

次の例に、イベントを宣言して発生させる方法を示します。 イベントはデリゲート型を持ち、"^" シンボルを使用して宣言されることに注意してください。

[!code-cpp[cx_events#01](../cppcx/codesnippet/CPP/cx_events/class1.h#01)]

### <a name="usage"></a>使用状況

次の例では、サブスクライブ側のクラスが `+=` 演算子を使用してイベントにサブスクライブし、イベントが発生したときに呼び出されるイベント ハンドラーを指定する方法を示します。 指定された関数が、 `EventTest` 名前空間でパブリッシャー側で定義されたデリゲートの署名と一致していることに注目してください。

[!code-cpp[cx_events#02](../cppcx/codesnippet/CPP/eventsupportinvs/eventclientclass.h#02)]

> [!WARNING]
> 細心の注意を払って循環参照を回避する場合を除き、一般にイベント ハンドラーにはラムダではなく名前付き関数を使用する方が適しています。 名前付き関数では弱い参照によって "this" ポインターをキャプチャするのに対し、ラムダでは強い参照によってこのポインターをキャプチャし、循環参照を作成します。 詳細については、「 [Weak references and breaking cycles (C++/CX) (弱参照と循環の解除 (C++/CX))](../cppcx/weak-references-and-breaking-cycles-c-cx.md)」を参照してください。

### <a name="custom-add-and-remove-methods"></a>カスタムの add メソッドと remove メソッド

内部的には、イベントには add メソッド、remove メソッド、および raise メソッドがあります。 クライアント コードがイベントにサブスクライブすると、add メソッドが呼び出され、渡されたデリゲートが、イベントの呼び出しリストに追加されます。 パブリッシャー クラスがイベントを呼び出します。すると、raise() メソッドが呼び出され、リスト内の各デリゲートが順番に呼び出されます。 サブスクライバーは、デリゲートの一覧から自身を削除できます。これにより、イベントの remove メソッドが呼び出されます。 ユーザーがコードでこれらのメソッドを定義していない場合に備えて、コンパイラには、既定バージョンのメソッドが用意されています。これらは単純なイベントと呼ばれます。 多くの場合、単純なイベント以外に必要とされることはありません。

サブスクライバーの追加または削除に応じてカスタム ロジックを実行する必要がある場合に、イベントのカスタム add、remove、および raise メソッドを指定できます。 たとえば、イベントのレポートにのみ必要な負荷の高いオブジェクトがある場合、クライアントがイベントを実際にサブスクライブするまでオブジェクトの作成を延期できます。

次の例は、カスタムの add、remove、および raise メソッドをイベントに追加する方法を示しています。

[!code-cpp[cx_events#03](../cppcx/codesnippet/CPP/cx_events/class1.h#03)]

## <a name="removing-an-event-handler-from-the-subscriber-side"></a>サブスクライバー側からのイベント ハンドラーの削除

まれに、前にサブスクライブしたイベントのイベント ハンドラーを削除する必要が生じることがあります。 たとえば、他のイベント ハンドラーに置き換える場合や、ハンドラーが保持するリソースを削除する場合です。 ハンドラーを削除するには、 `+=` 演算から返される EventRegistrationToken を保存しておく必要があります。 その後、トークンの `-=` 演算子を使用してイベント ハンドラーを削除します。  ただし、元のハンドラーは削除した後でも呼び出すことができます。 たとえば、イベントソースがハンドラーのリストを取得して呼び出しを開始したときに、競合状態が発生する可能性があります。 このエラーが発生したときにイベントハンドラーが削除された場合、リストは最新ではなくなります。 そのため、イベントハンドラーを削除する場合は、メンバーフラグを作成します。 イベントが削除された場合はそれを設定し、イベントハンドラーでフラグをチェックして、設定されている場合はすぐに制御を戻します。 次の例に、基本的なパターンを示します。

[!code-cpp[cx_events#04](../cppcx/codesnippet/CPP/eventsupportinvs/eventclientclass.h#04)]

### <a name="remarks"></a>コメント

複数のハンドラーが、同じイベントに関連付けられている場合があります。 イベント ソースは、同じスレッドからすべてのイベント ハンドラーを順番に呼び出します。 イベント ハンドラー メソッド内でイベント レシーバーがブロックする場合、このイベントに対する他のイベント ハンドラーの呼び出しからイベント ソースをブロックします。

イベント ソースがイベント レシーバーのイベント ハンドラーを呼び出す順序は保証されず、呼び出しごとに異なる可能性があります。

## <a name="see-also"></a>関連項目

[型システム](../cppcx/type-system-c-cx.md)<br/>
[デリゲート](../cppcx/delegates-c-cx.md)<br/>
[C++/CX 言語リファレンス](../cppcx/visual-c-language-reference-c-cx.md)<br/>
[名前空間参照](../cppcx/namespaces-reference-c-cx.md)
