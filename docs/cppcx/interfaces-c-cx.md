---
title: インターフェイス (C++/CX)
ms.date: 01/22/2017
ms.assetid: 11034314-d54a-426d-923b-5ab7a6b9f8ce
ms.openlocfilehash: 263feb7b9c8a472a6077236596107bdeff26a5a4
ms.sourcegitcommit: 180f63704f6ddd07a4172a93b179cf0733fd952d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/06/2019
ms.locfileid: "70740186"
---
# <a name="interfaces-ccx"></a>インターフェイス (C++/CX)

ref クラスは多くても 1 つの具象基底クラスからしか継承できませんが、任意の数のインターフェイス クラスを実装できます。 インターフェイス クラス (インターフェイス構造体) 自体は、複数のインターフェイス クラスを継承 (または要求) でき、メンバー関数をオーバーロードすることができ、型パラメーターを持つことができます。

## <a name="characteristics"></a>特性

インターフェイスには、以下の特性があります。

- インターフェイス クラス (または構造体) は、名前空間内部で宣言される必要があり、その名前空間内で public または private のアクセシビリティを持つことができます。 パブリック インターフェイスだけがメタデータに出力されます。

- インターフェイスのメンバーには、プロパティ、メソッド、およびイベントを含めることができます。

- すべてのインターフェイス メンバーは、暗黙的にパブリックであり、仮想です。

- フィールドおよび静的メンバーは使用できません。

- プロパティ、メソッドパラメーター、または戻り値として使用される型は Windows ランタイム型に限定されます。これには、基本型と列挙型クラス型が含まれます。

## <a name="declaration-and-usage"></a>宣言と使用法

インターフェイスの宣言方法を次に示します。 インターフェイスはクラス型または構造体型として宣言できます。

[!code-cpp[cx_interfaces#01](../cppcx/codesnippet/CPP/interfacestest/class1.h#01)]

インターフェイスを実装するには、ref クラスまたは ref 構造体で仮想メソッドと仮想プロパティを宣言し、実装します。 インターフェイスおよび ref クラスの実装では、この例に示すように、同じメソッド パラメーター名を使用する必要があります。

[!code-cpp[cx_interfaces#02](../cppcx/codesnippet/CPP/interfacestest/class1.h#02)]

## <a name="interface-inheritance-hierarchies"></a>インターフェイス継承階層

インターフェイスは、1 つ以上のインターフェイスから継承できます。 ただし、ref クラスまたは ref 構造体とは異なり、インターフェイスは継承インターフェイス メンバーを宣言しません。 インターフェイス B がインターフェイス A から継承し、ref クラス C が B から継承する場合、C は A と B の両方を実装する必要があります。これを次の例に示します。

[!code-cpp[cx_interfaces#03](../cppcx/codesnippet/CPP/interfacestest/class1.h#03)]

## <a name="implementing-interface-properties-and-events"></a>インターフェイスのプロパティとイベントの実装

前の例に示したように、単純な仮想プロパティを使用してインターフェイスのプロパティを実装できます。 また、実装するクラスでカスタムの get アクセス操作子および set アクセス操作子を提供できます。  インターフェイス プロパティで、get および set アクセス操作子が両方ともパブリックである必要があります。

[!code-cpp[cx_interfaces#04](../cppcx/codesnippet/CPP/interfacestest/class1.h#04)]

インターフェイスで取得専用または設定専用のプロパティを宣言する場合、実装するクラスは明示的に get または set アクセス操作子を提供する必要があります。

[!code-cpp[cx_interfaces#05](../cppcx/codesnippet/CPP/interfacestest/class1.h#05)]

また、実装するクラスでイベントのカスタムの追加および削除メソッドを実装できます。

## <a name="explicit-interface-implementation"></a>明示的なインターフェイスの実装

ref クラスが複数のインターフェイスを実装し、それらのインターフェイスに名前と署名がコンパイラと同じメソッドがある場合、次の構文を使用して、クラス メソッドが実装しているインターフェイス メソッドを明示的に示すことができます。

[!code-cpp[cx_interfaces#06](../cppcx/codesnippet/CPP/interfacestest/class1.h#06)]

## <a name="generic-interfaces"></a>ジェネリック インターフェイス

/Cx C++では、 `generic`キーワードを使用して、パラメーター化された型 Windows ランタイムを表します。 パラメーター化された型は、メタデータに出力され、型パラメーターをサポートする言語で記述されたコードで利用できます。 Windows ランタイムでは、 [Windows:: Foundation:: Collections:: ivector\<T >](Windows::Foundation::Collections::IVector)など、いくつかのジェネリックインターフェイスが定義されていますが、/cxでC++のパブリックユーザー定義ジェネリックインターフェイスの作成はサポートしていません。 ただし、プライベート ジェネリック インターフェイスは作成できます。

Windows ランタイム型を使用してジェネリックインターフェイスを作成する方法を次に示します。

- コンポーネント内のジェネリック ユーザー定義 `interface class` を Windows メタデータ ファイルに出力することはできません。したがって、パブリック アクセシビリティを持つことはできず、他の .winmd ファイル内のクライアント コードでは実装できません。 実装するには、同じコンポーネント内の非パブリック ref クラスを使用することが必要です。 パブリック ref クラスは、プライベート メンバーとしてジェネリック インターフェイス型を持つことができます。

   次のコード スニペットは、ジェネリック `interface class` を宣言してから、プライベート ref クラスに実装し、その ref クラスをパブリック ref クラスのプライベート メンバーとして使用する方法を示します。

   [!code-cpp[cx_interfaces#07](../cppcx/codesnippet/CPP/interfacestest/class1.h#07)]

- ジェネリック インターフェイスは、アクセシビリティ、メンバー、 *要求* リレーションシップ、基底クラスなどを管理する標準インターフェイス規則に従う必要があります。

- ジェネリック インターフェイスは、 `typename` または `class`を指定する 1 つ以上のジェネリック型パラメーターを受け取ることができます。 非型パラメーターはサポートされていません。

- 型パラメーターは任意の Windows ランタイム型にすることができます。 つまり、型パラメーターには、参照型、値の型、インターフェイス クラス、デリゲート、基本型、またはパブリック列挙型クラスを指定できます。

- *クローズ ジェネリック インターフェイス* は、ジェネリック インターフェイスから継承し、すべての型パラメーターに対して具象型引数を指定するインターフェイスです。 これは、非ジェネリック プライベート インターフェイスを使用できる場所のどこにでも使用できます。

- *オープン ジェネリック インターフェイス* は、具象型がまだ提供されていない 1 つ以上の型パラメーターを持つインターフェイスです。 これは型を使用できる場所のどこにでも使用できます。これには、別のジェネリック インターフェイスの型引数としての使用も含まれます。

- パラメーター化できるのは、個々のメソッドではなくインターフェイス全体だけです。

- 型パラメーターを制約することはできません。

- クローズ ジェネリック インターフェイスには、暗黙的に生成される UUID があります。 ユーザーは UUID を指定できません。

- インターフェイスでは、メソッド パラメーター、戻り値、またはプロパティでの現在のインターフェイスへの参照は、現在のインスタンス化への参照と見なされます。 たとえば、 *IMyIntf*は、 *IMyIntf\<T >* を意味します。

- メソッド パラメーターの型が型パラメーターのとき、そのパラメーターまたは変数の宣言では、ポインター、ネイティブ参照、またはハンドル宣言子なしで型パラメーターの名前を使用します。 つまり、"T^" を作成することはありません。

- template 宣言された ref クラスは、プライベートである必要があります。 ジェネリックインターフェイスを実装し、テンプレートパラメーター *t*をジェネリック引数*t*に渡すことができます。テンプレート化された ref クラスの各インスタンス化は、それ自体が ref クラスです。

## <a name="see-also"></a>関連項目

[型システム](../cppcx/type-system-c-cx.md)<br/>
[C++/CX 言語リファレンス](../cppcx/visual-c-language-reference-c-cx.md)<br/>
[名前空間参照](../cppcx/namespaces-reference-c-cx.md)
