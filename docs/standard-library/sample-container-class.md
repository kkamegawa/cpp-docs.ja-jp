---
title: サンプル コンテナー クラス
ms.date: 11/04/2016
helpviewer_keywords:
- container classes [C++]
ms.assetid: 5b1451f2-c708-45da-bbf0-9e42fd687a1a
ms.openlocfilehash: 404e372e65af8b93ae4f6f2827a73ef64336690a
ms.sourcegitcommit: 590e488e51389066a4da4aa06d32d4c362c23393
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/21/2019
ms.locfileid: "72688971"
---
# <a name="sample-container-class"></a>サンプル コンテナー クラス

> [!NOTE]
> このトピックは、 C++ C++標準ライブラリで使用されているコンテナーの非機能例として、Microsoft ドキュメントに記載されています。 詳細については、「[C++ Standard Library Containers (C++ 標準ライブラリ コンテナ―)](../standard-library/stl-containers.md)」をご覧ください。

要素の可変長シーケンスを制御するオブジェクトを記述します。通常は `Ty` 型です。 シーケンスは、実際のコンテナーに応じて、さまざまな方法で格納されます。

コンテナーのコンストラクターまたはメンバー関数がコンストラクター **Ty**(**const Ty&** ) または関数 **Ty::operator=** (**const Ty&** ) を呼び出す場合があります。 このような呼び出しで例外がスローされた場合、コンテナー オブジェクトは、その整合性を維持し、すべての例外をキャッチして再スローする必要があります。 コンテナー オブジェクトによっていずれか 1 つの例外がスローされた後に、コンテナー オブジェクトを安全にスワップ、消去、または破棄できます。 ただし、通常、それ以外の場合はコンテナー オブジェクトによって制御されるシーケンスの状態を予測できません。

その他の注意点:

- 式 `~Ty` が例外をスローした場合、コンテナーオブジェクトの結果の状態は未定義になります。

- コンテナーがアロケーターオブジェクト*al*を格納し、 *al*が `al.allocate` の呼び出しの結果としてではなく例外をスローした場合、コンテナーオブジェクトの結果の状態は未定義になります。

- コンテナーが被制御シーケンスの順序付け方法を指定する関数オブジェクト *comp* を格納し、*comp* がいずれかの例外をスローする場合、コンテナー オブジェクトの結果の状態は未定義です。

C++ 標準ライブラリで定義されているコンテナー クラスは、次に説明するいくつかの追加要件を満たします。

コンテナークラステンプレート[リスト](../standard-library/list-class.md)は、上記の例外が存在する場合でも、決定的で便利な動作を提供します。 たとえば、1 つまたは複数の要素の挿入時に例外がスローされた場合、コンテナーは変更されず、再度例外がスローされます。

標準ライブラリでC++定義されているすべてのコンテナークラスについて、次のメンバー関数、`insert`、`push_back`、または `push_front` の呼び出し中に例外がスローされた場合、コンテナーは変更されず、例外が再スローされます。

標準ライブラリで定義されてC++いるすべてのコンテナークラスでは、次のメンバー関数の呼び出し中に例外がスローされることはありません: `pop_back`、`pop_front`。

メンバー関数 [erase](../standard-library/container-class-erase.md) は、コピー操作 (割り当てまたはコピーの構築) が例外をスローする場合にのみ例外をスローします。

さらに、メンバー関数によって返される反復子のコピー中に例外はスローされません。

メンバー関数 [swap](../standard-library/container-class-swap.md) は、C++ 標準ライブラリで定義されている*すべての*コンテナー クラスに対する追加の確実性を実現します。

- コンテナーがアロケーター オブジェクト al を格納し、`al` がコピーされるときに例外をスローする場合にのみ、メンバー関数が例外をスローします。

- スワップされる被制御シーケンスの要素を指定する参照、ポインター、および反復子は有効なままです。

C++ 標準ライブラリで定義されたコンテナー クラスのオブジェクトが、`Alloc` 型の格納されているオブジェクトによって制御するシーケンスの記憶域の割り当ておよび解放を行います (これは通常、テンプレート パラメーターです)。 このようなアロケーターオブジェクトは、`allocator<Ty>` クラスのオブジェクトと同じ外部インターフェイスを持っている必要があります。 特に、`Alloc` はと同じ型である必要があり `Alloc::rebind<value_type>::other`

標準ライブラリでC++定義されているすべてのコンテナークラスについて、メンバー関数 `Alloc get_allocator const;` は、格納されているアロケーターオブジェクトのコピーを返します。 コンテナー オブジェクトを代入しても、格納されているアロケーター オブジェクトはコピー*されない*点に注意してください。 コンストラクターにアロケーターパラメーターが含まれていない場合、すべてのコンストラクターは `allocator` に格納されている値を初期化し、`Alloc` します。

C++ 標準に従って、C++ 標準ライブラリで定義されたコンテナー クラスは次を想定できます。

- クラス `Alloc` のすべてのオブジェクトの比較結果が同じになります。

- 型 `Alloc::const_pointer` は `const Ty *` と同じです。

- 型 `Alloc::const_reference` は `const Ty&` と同じです。

- 型 `Alloc::pointer` は `Ty *` と同じです。

- 型 `Alloc::reference` は `Ty&` と同じです。

ただし、この実装では、コンテナーはこのような単純な想定を行いません。 このため、コンテナーはより意欲的なアロケーター オブジェクトと共に適切に動作します。

- クラス `Alloc` のすべてのオブジェクトの比較結果が同じである必要はありません。 (記憶域の複数のプールを維持することができます。)

- 型 `Alloc::const_pointer` は `const Ty *` と同じである必要はありません。 (const ポインターには、クラスを指定できます。)

- 型 `Alloc::pointer` は `Ty *` と同じである必要はありません。 (ポインターには、クラスを指定できます。)

## <a name="requirements"></a>［要件］

**ヘッダー**: \<sample container>

## <a name="see-also"></a>関連項目

[\<sample container>](../standard-library/sample-container.md)
