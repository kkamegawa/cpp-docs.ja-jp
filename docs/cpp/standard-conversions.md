---
title: 標準変換
ms.date: 10/02/2019
helpviewer_keywords:
- standard conversions, categories of
- L-values [C++]
- conversions, standard
ms.assetid: ce7ac8d3-5c99-4674-8229-0672de05528d
ms.openlocfilehash: c51a5ea5aaabb27babb9e4cd355721742088d31e
ms.sourcegitcommit: c51b2c665849479fa995bc3323a22ebe79d9d7ce
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/07/2019
ms.locfileid: "71998900"
---
# <a name="standard-conversions"></a>標準変換

C++ 言語では、基本型間での変換が定義されています。 また、ポインター、参照、およびメンバーへのポインターの派生型についても変換が定義されています。 これらの変換は、*標準変換*と呼ばれます。

このセクションでは、次の標準変換について説明します。

- 整数の上位変換

- 整数の変換

- 浮動小数点の変換

- 浮動小数点と整数の変換

- 算術変換

- ポインター変換

- 参照変換

- メンバーへのポインター変換

  > [!NOTE]
  > ユーザー定義型では独自の変換を指定できます。 ユーザー定義型の変換については、「[コンストラクター](../cpp/constructors-cpp.md)と[変換](../cpp/user-defined-type-conversions-cpp.md)」で説明されています。

次のコードは、変換 (この例では整数の上位変換) の実行例を示しています。

```cpp
long  long_num1, long_num2;
int   int_num;

// int_num promoted to type long prior to assignment.
long_num1 = int_num;

// int_num promoted to type long prior to multiplication.
long_num2 = int_num * long_num2;
```

参照型を生成する場合のみ、変換の結果が左辺値になります。 たとえば、`operator int&()` として宣言されたユーザー定義変換は参照を返し、は左辺値です。 ただし、`operator int()` として宣言された変換はオブジェクトを返し、左辺値ではありません。

## <a name="integral-promotions"></a>整数の上位変換

整数型のオブジェクトは、より大きな整数型、つまり、より大きな値のセットを表すことができる型に変換できます。 この拡大型の変換は、*整数の上位*変換と呼ばれます。 整数の上位変換では、別の整数型を使用できる場所であれば、式で次の型を使用できます。

- **Char**および**short int**型のオブジェクト、リテラル、および定数

- 列挙型

- **int**ビットフィールド

- 列挙子

C++上位変換は、昇格後の値が上位変換前の値と同じであることが保証されます。 値を保持する昇格では、 **int**が元の型の完全な範囲を表すことができる場合、短い整数型 (ビットフィールドや**char**型のオブジェクトなど) のオブジェクトは、 **int**型に昇格されます。 **Int**が値の全範囲を表すことができない場合、オブジェクトは**unsigned int**型に昇格されます。 この方法は、標準 C で使用される方法と同じですが、値を維持する変換では、オブジェクトの "有無" が保持されません。

値保持の上位変換および符号の有無を保持する上位変換は、通常、同じ結果を生成します。 ただし、昇格したオブジェクトが次のように表示されると、異なる結果が生成される可能性があります。

- `/`、`%`、`/=`、`%=`、`<`、`<=`、`>`、または `>=` のオペランド

   これらの演算子は、結果を判断するために符号に依存します。 このようなオペランドに適用した場合、値を維持し、符号を維持する昇格によって異なる結果が生成されます。

- `>>` または `>>=` の左オペランド

   これらの演算子は、シフト演算で符号付きと符号なしの数量を別々に扱います。 符号付きの数量の場合、右シフト演算では符号ビットが空いているビット位置に伝達されますが、空いたビット位置は符号なしの数量でゼロで埋められます。

- オーバーロードされた関数の引数、またはオーバーロードされた演算子のオペランド。引数の一致のオペランド型の有無に依存します。 オーバーロードされた演算子の定義の詳細については、「オーバーロードされた[演算子](../cpp/operator-overloading.md)」を参照してください。

## <a name="integral-conversions"></a>整数の変換

*整数変換*は、整数型の間の変換です。 整数型は、 **char**、 **short** (または**short int**)、 **int**、 **long**、 **long long**です。 これらの型は**signed**または**unsigned**で修飾され、unsigned **int**の短縮形として使用すること**ができます**。

### <a name="signed-to-unsigned"></a>signed から unsigned へ

符号付き整数型のオブジェクトは、対応する符号なし型に変換できます。 これらの変換が発生した場合、実際のビットパターンは変わりません。 ただし、データの解釈は変わります。 次のコードを考えてみます。

```cpp
#include <iostream>

using namespace std;
int main()
{
    short  i = -3;
    unsigned short u;

    cout << (u = i) << "\n";
}
// Output: 65533
```

前の例では、**符号付き short**、`i`が定義され、負の数に初期化されます。 式 `(u = i)` によって、`i` は `u`への代入の前に、 **unsigned short**に変換されます。

### <a name="unsigned-to-signed"></a>unsigned から signed へ

符号なし整数型のオブジェクトは、対応する符号付き型に変換できます。 ただし、符号なしの値が符号付きの型の表現可能な範囲外の場合、次の例に示すように、結果に正しい値が設定されません。

```cpp
#include <iostream>

using namespace std;
int main()
{
short  i;
unsigned short u = 65533;

cout << (i = u) << "\n";
}
//Output: -3
```

前の例では、`u` は、式  **を評価するために符号付きの数量に変換する必要がある**unsigned short`(i = u)`整数オブジェクトです。 **signed**ので値を正しく表すことができないため、データが誤って表示されます。

## <a name="floating-point-conversions"></a>浮動小数点の変換

浮動小数点型のオブジェクトは、より精度の高い浮動小数点型に安全に変換できます。つまり、変換で精度は低下しません。 たとえば、 **float**から**double**または**double**から**long double**への変換は安全であり、値は変更されません。

また、浮動小数点型のオブジェクトは、その型で表現できる範囲内にある場合は、より精度の低い型に変換することもできます。 (浮動小数点型の範囲については、「[浮動小数点値の制限](../cpp/floating-limits.md)」を参照してください)。元の値が正確に表現できない場合は、次に大きい値または次に小さい表現可能値のいずれかに変換できます。 そのような値が存在しない場合、結果は未定義になります。 次に例を示します。

```cpp
cout << (float)1E300 << endl;
```

**Float**型で表現可能な最大値は 3.402823466 e38 です。これは1e300 よりもはるかに小さい数値です。 そのため、数値は無限大に変換され、結果は "inf" になります。

## <a name="conversions-between-integral-and-floating-point-types"></a>整数型と浮動小数点型の変換

特定の式は、浮動小数点型のオブジェクトから整数型のオブジェクトへの変換、またはその逆の変換が発生する場合があります。 整数型のオブジェクトが浮動小数点型に変換され、元の値が正確に表現できない場合、結果は次の上位または次に表現可能な値のいずれかになります。

浮動小数点型のオブジェクトを整数型に変換すると、小数部分が*切り捨てら*れるか、ゼロに丸められます。 1\.3 のような数値が1に変換され、-1.3 が-1 に変換されます。 切り捨てられた値が表現可能な最大値より大きい場合、または表現可能な最小値より小さい場合、結果は未定義になります。

## <a name="arithmetic-conversions"></a>算術変換

多くの二項演算子 (「[二項演算子を使用した式](../cpp/expressions-with-binary-operators.md)」で説明されています) は、オペランドの変換を実行し、同じように結果を生成します。 これらの演算子の原因となる変換は、*通常の算術変換*と呼ばれます。 次の表に示すように、ネイティブ型が異なるオペランドの算術変換が実行されます。 typedef 型は、基になるネイティブ型に従って動作します。

### <a name="conditions-for-type-conversion"></a>型変換の条件

|満たされる条件|変換|
|--------------------|----------------|
|どちらのオペランドも**long double**型です。|その他のオペランドは**long double**型に変換されます。|
|前の条件が満たされておらず、いずれかのオペランドの型が**double**です。|その他のオペランドは**double**型に変換されます。|
|前の条件が満たされておらず、いずれかのオペランドが**float**型です。|その他のオペランドは**float**型に変換されます。|
|上の条件が満たされていない (どちらのオペランドも浮動小数点型ではない)|オペランドは、次のように整数の上位変換を取得します。<br /><br />-いずれかのオペランドが**unsigned long**型の場合、もう一方のオペランドは**unsigned long**型に変換されます。<br />-前の条件が満たされず、どちらかのオペランドが**long**型で、もう一方が**unsigned int**型の場合、両方のオペランドが**unsigned long**型に変換されます。<br />-前の2つの条件が満たされず、どちらかのオペランドが**long**型の場合、もう一方のオペランドは**long**型に変換されます。<br />-上記の3つの条件が満たされず、どちらかのオペランドが**unsigned int**型の場合、もう一方のオペランドは**unsigned int**型に変換されます。<br />-上記のいずれの条件も満たされない場合、両方のオペランドが**int**型に変換されます。|

次のコードは、表で説明している変換規則を示しています。

```cpp
double dVal;
float fVal;
int iVal;
unsigned long ulVal;

int main() {
   // iVal converted to unsigned long
   // result of multiplication converted to double
   dVal = iVal * ulVal;

   // ulVal converted to float
   // result of addition converted to double
   dVal = ulVal + fVal;
}
```

上記の例の最初のステートメントは、2 つの整数型、`iVal` と `ulVal` の乗算を示しています。 満たされる条件は、どちらのオペランドも浮動小数点型ではないことと、1つのオペランドが**符号なし int**型であることです。そのため、もう1つのオペランドである `iVal`は、**符号なし int**型に変換されます。その後、結果が `dVal`に割り当てられます。 ここで条件を満たすのは、1つのオペランドが**double**型であるため、乗算の**符号なし整数**の結果が**double**型に変換されることです。

前の例の2番目のステートメントは、 **float**型と整数型の加算を示しています。 `fVal` と `ulVal`です。 `ulVal` 変数は**float**型 (テーブルの3番目の条件) に変換されます。 加算の結果は**double**型 (テーブルの2番目の条件) に変換され、`dVal`に割り当てられます。

## <a name="pointer-conversions"></a>ポインター変換

ポインターは、代入、初期化、比較、および他の式の中で変換できます。

### <a name="pointer-to-classes"></a>クラスへのポインター

クラスへのポインターを基底クラスへのポインターに変換できる 2 つのケースがあります。

最初のケースは、指定した基底クラスがアクセス可能であり、変換が明確である場合です。 あいまいな基底クラス参照の詳細については、「[複数の基底クラス](../cpp/multiple-base-classes.md)」を参照してください。

基底クラスにアクセスできるかどうかは、派生で使用される継承の種類によって決まります。 次の図に示す継承を考えます。

![&#45;]基底クラスのアクセシビリティを示す基底クラスのアクセシビリティ(../cpp/media/vc38xa1.gif "継承グラフ&#45;")を示す継承グラフ <br/>
基底クラスのアクセシビリティを示す継承グラフ

次の表は、図で示す状況に対する基底クラスのアクセシビリティを示します。

|関数の型|派生|変換 (<br /><br /> B * を\* 法的に|
|----------------------|----------------|-------------------------------------------|
|外部 (非クラス スコープ) 関数|プライベート|いいえ|
||プロテクト|いいえ|
||パブリック|はい|
|B のメンバー関数 (B のスコープ内)|プライベート|はい|
||プロテクト|はい|
||パブリック|はい|
|C のメンバー関数 (C のスコープ内)|プライベート|いいえ|
||プロテクト|はい|
||パブリック|はい|

クラスへのポインターを基底クラスへのポインターに変換できる 2 番目のケースは、明示的な型変換を使用する場合です 明示的な型変換の詳細については、「[明示的な型変換演算子](explicit-type-conversion-operator-parens.md)」を参照してください。

このような変換の結果として、基底クラスによって完全に記述されているオブジェクトの*部分である*サブオブジェクトへのポインターが返されます。

次のコードでは、2 つのクラス `A` と `B` を定義しています。`B` は `A` から派生しています。 (継承の詳細については、「[派生クラス](../cpp/inheritance-cpp.md)」を参照してください)。次に、`bObject`、`B`型のオブジェクト、およびオブジェクトを指す2つのポインター (`pA` と `pB`) を定義します。

```cpp
// C2039 expected
class A
{
public:
    int AComponent;
    int AMemberFunc();
};

class B : public A
{
public:
    int BComponent;
    int BMemberFunc();
};
int main()
{
   B bObject;
   A *pA = &bObject;
   B *pB = &bObject;

   pA->AMemberFunc();   // OK in class A
   pB->AMemberFunc();   // OK: inherited from class A
   pA->BMemberFunc();   // Error: not in class A
}
```

ポインター `pA` は、型 `A *` へのポインターを意味するものとして解釈できる型 `A` です。 `bObject` のメンバー (`BComponent` や `BMemberFunc`など) は `B` 型に固有であるため、`pA`を使用してアクセスすることはできません。 `pA` ポインターは、クラス `A` で定義されているオブジェクトのこれらの特性 (メンバー関数とデータ) にのみアクセスを許可します。

### <a name="pointer-to-function"></a>関数へのポインター

型 `void *` がそのポインターを保持するのに十分な大きさである場合は、関数へのポインターを `void *`型に変換できます。

### <a name="pointer-to-void"></a>void へのポインター

**Void**型へのポインターは、他の型へのポインターに変換できますが、明示的な型キャスト (C の場合とは異なります) を使用する場合に限ります。 任意の型へのポインターは、暗黙的に**void**型へのポインターに変換できます。 型の不完全なオブジェクトへのポインターは、 **void** (暗黙的に) および back (明示的に) へのポインターに変換できます。 このような変換の結果は、元のポインターの値と同じです。 オブジェクトは宣言されている場合は不完全と見なされますが、サイズまたは基本クラスを決定するのに十分な情報がありません。

**Const**または**volatile**でないオブジェクトへのポインターは、暗黙的に `void *`型のポインターに変換できます。

### <a name="const-and-volatile-pointers"></a>const ポインターと volatile ポインター

C++**const または** **volatile**型から**const**または**volatile**ではない型への標準変換を提供しません。 ただし、どの種類の変換も、明示的な型キャストを使用して指定できます (安全でない変換も含む)。

> [!NOTE]
> C++静的メンバーへのポインターを除くメンバーへのポインターは、通常のポインターとは異なり、標準変換は同じではありません。 静的メンバーへのポインターは通常のポインターであり、通常のポインターと同じ変換を持ちます。

### <a name="null-pointer-conversions"></a>null ポインターの変換

0に評価される整数定数式、またはポインター型にキャストされる式は、 *null ポインター*と呼ばれるポインターに変換されます。 このポインターは、常に、任意の有効なオブジェクトまたは関数へのポインターと等しくないことを比較します。 例外とは、ベースのオブジェクトへのポインターであり、同じオフセットを持つことができ、別のオブジェクトを指す場合もあります。

C++ 11 では、 [nullptr](../cpp/nullptr.md)型が C スタイルの null ポインターに優先される必要があります。

### <a name="pointer-expression-conversions"></a>ポインター式の変換

配列型の式は、同じ型のポインターに変換できます。 変換の結果は最初の配列要素へのポインターです。 次のコードは、この変換を示す例です。

```cpp
char szPath[_MAX_PATH]; // Array of type char.
char *pszPath = szPath; // Equals &szPath[0].
```

特定の型を返す関数となる式は、次の場合を除き、その型を返す関数へのポインターに変換されます。

- 式は、アドレス演算子 ( **&** ) のオペランドとして使用されます。

- 式が関数呼び出し演算子のオペランドとして使用されています。

## <a name="reference-conversions"></a>参照変換

このような場合は、クラスへの参照を基底クラスへの参照に変換できます。

- 指定された基底クラスにアクセスできます。

- 変換は明確です。 (あいまいな基底クラス参照の詳細については、「[複数の基底クラス](../cpp/multiple-base-classes.md)」を参照してください)。

変換の結果は、基底クラスを表すサブオブジェクトへのポインターです。

## <a name="pointer-to-member"></a>メンバーへのポインター

クラス メンバーへのポインターは、代入、初期化、比較、および他の式の中で変換できます。 このセクションでは、以下のポインターからメンバーへの変換について説明します。

### <a name="pointer-to-base-class-member"></a>基底クラスのメンバーへのポインター

基底クラスのメンバーへのポインターは、次の条件を満たす場合に、そのクラスから派生したクラスのメンバーへのポインターに変換できます。

- 派生クラスへのポインターから基底クラスへのポインターへの逆変換がアクセス可能である。

- 派生クラスが基底クラスからの仮想的な継承でない。

左のオペランドがメンバーへのポインターである場合、右のオペランドはメンバーへのポインター型であるか、0 に評価される定数式である必要があります。 この代入は、次の場合にのみ有効です。

- 右のオペランドが、左のオペランドと同じクラスのメンバーへのポインターである。

- 左のオペランドが、右のオペランドのクラスからパブリックかつ明確に派生したクラスのメンバーへのポインターである。

### <a name="null-pointer-to-member-conversions"></a>メンバー変換への null ポインター

0に評価される整数定数式は、null ポインターに変換されます。 このポインターは、常に、任意の有効なオブジェクトまたは関数へのポインターと等しくないことを比較します。 例外とは、ベースのオブジェクトへのポインターであり、同じオフセットを持つことができ、別のオブジェクトを指す場合もあります。

次のコードは、クラス `i` のメンバー `A` へのポインターの定義を示しています。 ポインター `pai` が 0、つまり null ポインターに初期化されます。

```cpp
class A
{
public:
int i;
};

int A::*pai = 0;

int main()
{
}
```

## <a name="see-also"></a>参照

[C++言語リファレンス](../cpp/cpp-language-reference.md)