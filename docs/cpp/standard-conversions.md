---
title: 標準変換
ms.date: 11/19/2018
helpviewer_keywords:
- standard conversions, categories of
- L-values [C++]
- conversions, standard
ms.assetid: ce7ac8d3-5c99-4674-8229-0672de05528d
ms.openlocfilehash: aee100bdc7e8ba6dd7d06c6bca9ed39c09cf2d97
ms.sourcegitcommit: 9e891eb17b73d98f9086d9d4bfe9ca50415d9a37
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/20/2018
ms.locfileid: "52176979"
---
# <a name="standard-conversions"></a>標準変換

C++ 言語では、基本型間での変換が定義されています。 また、ポインター、参照、およびメンバーへのポインターの派生型についても変換が定義されています。 これらの変換と呼びます*標準変換*します。

このセクションでは、次の標準変換について説明します。

- 整数の上位変換

- 整数の変換

- 浮動小数点の変換

- 浮動小数点と整数の変換

- 算術変換

- ポインター変換

- 参照変換

- メンバーへのポインター変換

    > [!NOTE]
    >  ユーザー定義型では独自の変換を指定できます。 ユーザー定義型の変換は、「[コンス トラクター](../cpp/constructors-cpp.md)と[変換](../cpp/user-defined-type-conversions-cpp.md)します。

次のコードは、変換 (この例では整数の上位変換) の実行例を示しています。

```cpp
long  long_num1, long_num2;
int   int_num;

// int_num promoted to type long prior to assignment.
long_num1 = int_num;

// int_num promoted to type long prior to multiplication.
long_num2 = int_num * long_num2;
```

参照型を生成する場合のみ、変換の結果が左辺値になります。 たとえば、ユーザー定義の変換として宣言されている`operator int&()`の参照を返し、左辺値です。 ただし、変換として宣言した`operator int()`オブジェクトを返し、左辺値ではありません。

## <a name="integral-promotions"></a>整数の上位変換

整数型のオブジェクトは別の大きな整数型 (つまり、より大きな値のセットを表現できる型) に変換できます。 この拡大型の変換は、"整数の上位変換" と呼ばれます。 整数の上位変換を使用すると、式で他の整数型を使用できる任意の場所で、次のものを使用できます。

- オブジェクト、リテラル、および型の定数**char**と**short int**

- 列挙型

- **int**ビット フィールド

- 列挙子

C++ の上位変換では "値保持" されます。 つまり、上位変換後の値が上位変換前の値と同じであることが保証されます。 値保持のプロモーションより短い整数型のオブジェクト (ビット フィールドまたは型のオブジェクトなど**char**) 型に上位変換は**int**場合**int**完全に表すことができます元の型の範囲です。 場合**int**オブジェクトが型に昇格し、値の完全な範囲を表すことはできません**符号なし int**します。この方法は ANSI C によって使用される方法と同じですが、値を保持する変換はオブジェクトの "符号の有無" を保持しません。

値保持の上位変換および符号の有無を保持する上位変換は、通常、同じ結果を生成します。 ただし、昇格されたオブジェクトが次のいずれかである場合は、異なる結果になる可能性があります。

- オペランド **/**、 `%`、 `/=`、 `%=`、 **<**、 **\<=**、 **>**、または **>=**

   これらの演算子は、結果を判断するために符号に依存します。 したがって、これらのオペランドに適用した場合、値保持と符号保持の上位変換により、異なる結果が生成されます。

- 左オペランド **>>** または **>>=**

   これらの演算子は、シフト演算を実行するときに符号付き数量と符号なし数量を別々に扱います。 符号付きの数量の場合、数量を右にシフトすると、符号は空いたビット位置に移されます。 符号なし数量の場合、空いたビット位置は 0 で埋められます。

- 引数の一致のためにそのオペランドの型の符号の有無に依存する、オーバーロードされた演算子のオーバーロードされた関数またはオペランドへの引数 (を参照してください[オーバー ロードされた演算子](../cpp/operator-overloading.md)オーバー ロードされた演算子の定義の詳細について)。

## <a name="integral-conversions"></a>整数の変換

整数変換は整数型間で実行されます。 整数型には**char**、 **int**、および**長い**(および**短い**、**署名**、および**符号なし**これらの型のバージョン)。

**Signed から unsigned**

符号付き整数型のオブジェクトは、対応する符号なし型に変換できます。 これらの変換が発生しても実際のビット パターンは変わりませんが、データの解釈が変わります。 次のコードを考えてみます。

```cpp
#include <iostream>

using namespace std;
int main()
{
    short  i = -3;
    unsigned short u;

    cout << (u = i) << "\n";
}
// Output: 65533
```

前の例では、**つまり署名**、`i`が定義され、負の数に初期化します。 式`(u = i)`により`i`に変換する、 **unsigned short**への代入する前に`u`します。

**Unsigned から signed**

符号なし整数型のオブジェクトは、対応する符号付き型に変換できます。 ただし、次の例に示すように、符号なしオブジェクトの値が符号付き型で表現できる範囲を超えている場合、このような変換によりデータが誤って解釈される可能性があります。

```cpp
#include <iostream>

using namespace std;
int main()
{
short  i;
unsigned short u = 65533;

cout << (i = u) << "\n";
}
//Output: -3
```

前の例では、`u`は、 **unsigned short**整数オブジェクト式を評価する符号付き数量に変換する必要があります`(i = u)`します。 その値を正しく表現できないため、**つまり署名**に示すように、データが誤って解釈します。

## <a name="floating-point-conversions"></a>浮動小数点の変換

浮動小数点型のオブジェクトは、より精度の高い浮動小数点型に安全に変換できます。つまり、変換で精度は低下しません。 変換など、 **float**に**二重**またはから**二重**に**long double**は安全であり、値は変更されません。

浮動小数点型のオブジェクトは、より精度の低い型で表現できる範囲にある場合はその型に変換できます。 (を参照してください[浮動小数点の制限](../cpp/floating-limits.md)の浮動小数点型の範囲)。元の値を正確に表すことができない場合、その値は次に大きくまたは次に小さく表現できる値に変換できます。 このような値がない場合、結果は未定義です。 次に例を示します。

```cpp
cout << (float)1E300 << endl;
```

型で表現できる最大値**float**は 3.402823466 e 38-1E300 よりもはるかに小さい数。 そのため、数は無限大に変換し、"inf"になります。

## <a name="conversions-between-integral-and-floating-point-types"></a>整数型と浮動小数点型の変換

特定の式は、浮動小数点型のオブジェクトから整数型のオブジェクトへの変換、またはその逆の変換が発生する場合があります。 整数型のオブジェクトが浮動小数点型に変換され、元の値を正確に表すことができない場合、結果はそれより大きいか小さくて最も近い表現可能な値になります。

浮動小数点型のオブジェクトが整数型に変換されるときは、小数部分が切り捨てられます。 変換プロセスで丸めは発生しません。 切り捨ては、1、および-1.3 に変換されます 1.3 などの数値は-1 に変換されていることを意味します。

## <a name="arithmetic-conversions"></a>算術変換

多くの二項演算子 (で説明した[二項演算子を含む式](../cpp/expressions-with-binary-operators.md)) のオペランドの変換が発生し、結果を生成するには、同じ方法です。 これらの演算子で変換が発生する方法は、"通常の算術変換" と呼ばれます。 異なるネイティブ型のオペランドの算術変換は、次の表に示すように実行されます。 typedef 型は、基になるネイティブ型に従って動作します。

### <a name="conditions-for-type-conversion"></a>型変換の条件

|満たされる条件|変換|
|--------------------|----------------|
|いずれかのオペランドの型は**long double**します。|もう一方のオペランドを型に変換されます**long double**します。|
|上の条件が満たされていない、いずれかのオペランドの型が**二重**します。|もう一方のオペランドを型に変換されます**二重**します。|
|型の上の条件が満たされず、どちらかのオペランドが**float**します。|もう一方のオペランドを型に変換されます**float**します。|
|上の条件が満たされていない (どちらのオペランドも浮動小数点型ではない)|オペランドに次のように整数の上位変換が実行されます。<br /><br />-どちらかのオペランドが型の場合**unsigned long**、もう一方のオペランドを型に変換されます**unsigned long**します。<br />、いずれかのオペランドの型の場合と上の条件が満たされない場合**長い**およびその他の種類の**符号なし int**、両方のオペランドを型に変換されます**unsigned long**します。<br />-前の 2 つの条件が満たされていない場合、いずれかのオペランドの型の場合**長い**、もう一方のオペランドを型に変換されます**長い**します。<br />-前の 3 つの条件が満たされていない場合、いずれかのオペランドの型の場合**符号なし int**、もう一方のオペランドを型に変換されます**符号なし int**します。<br />-両方のオペランドを型に変換されます上記の条件のいずれも満たされる場合**int**します。|

次のコードは、表で説明している変換規則を示しています。

```cpp
double dVal;
float fVal;
int iVal;
unsigned long ulVal;

int main() {
   // iVal converted to unsigned long
   // result of multiplication converted to double
   dVal = iVal * ulVal;

   // ulVal converted to float
   // result of addition converted to double
   dVal = ulVal + fVal;
}
```

上記の例の最初のステートメントは、2 つの整数型、`iVal` と `ulVal` の乗算を示しています。 満たされる条件は、どちらのオペランドが浮動小数点型は、1 つのオペランドの型は**符号なし int**します。そのため、もう一方のオペランド、 `iVal`、型に変換されます**符号なし int**します。結果は `dVal` に代入されます。 満たされる条件がその 1 つのオペランドの型は**二重**。 したがって、、**符号なし int**乗算の結果を型に変換されます**二重**します。

前の例では、2 番目のステートメントの追加を示しています、 **float**と整数型、`fVal`と`ulVal`します。 `ulVal`変数は、型に変換されます**float** (テーブルの 3 番目の条件)。 加算の結果を型に変換されます**二重**(2 番目のテーブルの条件) に割り当てられていると`dVal`します。

## <a name="pointer-conversions"></a>ポインター変換

ポインターは、代入、初期化、比較、および他の式の中で変換できます。

### <a name="pointer-to-classes"></a>クラスへのポインター

クラスへのポインターを基底クラスへのポインターに変換できる 2 つのケースがあります。

最初のケースは、指定した基底クラスがアクセス可能であり、変換が明確である場合です。 (を参照してください[複数の基底クラス](../cpp/multiple-base-classes.md)あいまいな基底クラスの参照の詳細についてはします)。

基底クラスにアクセスできるかどうかは、派生で使用される継承の種類によって決まります。 次の図に示す継承を考えます。

![基本を示す継承グラフ&#45;クラス アクセシビリティ](../cpp/media/vc38xa1.gif "ベースを示す継承グラフ&#45;クラス アクセシビリティ") <br/>
基底クラスのアクセシビリティを示す継承グラフ

次の表は、図で示す状況に対する基底クラスのアクセシビリティを示します。

### <a name="base-class-accessibility"></a>基底クラスのアクセシビリティ

|関数の型|派生|変換 (<br /><br /> B * A から\*法的でしょうか。|
|----------------------|----------------|-------------------------------------------|
|外部 (非クラス スコープ) 関数|Private|いいえ|
||プロテクト|いいえ|
||Public|はい|
|B のメンバー関数 (B のスコープ内)|Private|はい|
||プロテクト|はい|
||パブリック|はい|
|C のメンバー関数 (C のスコープ内)|プライベート|いいえ|
||プロテクト|はい|
||パブリック|はい|

クラスへのポインターを基底クラスへのポインターに変換できる 2 番目のケースは、明示的な型変換を使用する場合です  (を参照してください[明示的な型変換演算子](explicit-type-conversion-operator-parens.md)明示的な型変換の詳細についてはします)。

このような変換の結果は「サブオブジェクト」へのポインターです。サブオブジェクトは、基底クラスによって完全に記述されたオブジェクトの一部です。

次のコードでは、2 つのクラス `A` と `B` を定義しています。`B` は `A` から派生しています。 (継承の詳細については、次を参照してください[派生クラスの](../cpp/inheritance-cpp.md)。)。次に、`bObject`、型 `B` のオブジェクト、およびオブジェクトを指す 2 つのポインター (`pA` と `pB`) を定義します

```cpp
// C2039 expected
class A
{
public:
    int AComponent;
    int AMemberFunc();
};

class B : public A
{
public:
    int BComponent;
    int BMemberFunc();
};
int main()
{
   B bObject;
   A *pA = &bObject;
   B *pB = &bObject;

   pA->AMemberFunc();   // OK in class A
   pB->AMemberFunc();   // OK: inherited from class A
   pA->BMemberFunc();   // Error: not in class A
}
```

ポインター `pA` は、型 `A *` へのポインターを意味するものとして解釈できる型 `A` です。 メンバー `bObject` `(`など`BComponent`と`BMemberFunc`) は、型において一意`B`はこれにを通してアクセスできないと`pA`します。 `pA` ポインターは、クラス `A` で定義されているオブジェクトのこれらの特性 (メンバー関数とデータ) にのみアクセスを許可します。

### <a name="pointer-to-function"></a>関数へのポインター

関数へのポインターは型に変換できます`void *`場合は、型`void *`そのポインターを保持するために十分な大きさです。

### <a name="pointer-to-void"></a>void へのポインター

型へのポインター **void**は明示的な型キャストのみが、他の型にはポインターに変換できます (とは異なり C で)。 任意の型へのポインターは型へのポインターに暗黙的に変換できる**void**します。型の不完全オブジェクトへのポインターへのポインターに変換できる**void** (暗黙) し、バックアップを (明示的)。 このような変換の結果は、元のポインターの値と同じです。 オブジェクトを宣言しても、サイズまたは基底クラスを決定するための十分な情報がない場合は、オブジェクトは不完全であると見なされます。

任意のオブジェクトへのポインター **const**または**揮発性**型のポインターに暗黙的に変換できる`void *`します。

### <a name="const-and-volatile-pointers"></a>const ポインターと volatile ポインター

C++ では標準で変換が用意されていません、 **const**または**揮発性**型でない型へ**const**または**揮発性**します。 ただし、どの種類の変換も、明示的な型キャストを使用して指定できます (安全でない変換も含む)。

> [!NOTE]
>  静的メンバーへのポインターを除く、メンバーへの C++ のポインターは、通常のポインターとは異なり、同じ標準変換がありません。 静的メンバーへのポインターは通常のポインターであり、通常のポインターと同じ変換を持ちます。

### <a name="null-pointer-conversions"></a>null ポインターの変換

評価するとゼロになる整数定数式、またはそのような式をポインター型にキャストした結果は、"null ポインター" というポインターに変換されます。 このポインターは、すべての有効なオブジェクトまたは関数へのポインターと等しくないと判定されることが保証されます (同じオフセットを持っていても別のオブジェクトを指すことができる、ベース付きのオブジェクトへのポインターを除く)。

C++ 11 で、 [nullptr](../cpp/nullptr.md)型は、C スタイルの null ポインターを優先する必要があります。

### <a name="pointer-expression-conversions"></a>ポインター式の変換

配列型の式は、同じ型のポインターに変換できます。 変換の結果は最初の配列要素へのポインターです。 次のコードは、この変換を示す例です。

```cpp
char szPath[_MAX_PATH]; // Array of type char.
char *pszPath = szPath; // Equals &szPath[0].
```

特定の型を返す関数となる式は、次の場合を除き、その型を返す関数へのポインターに変換されます。

- 式は、address-of 演算子のオペランドとして使用されます (**&**)。

- 式が関数呼び出し演算子のオペランドとして使用されています。

## <a name="reference-conversions"></a>参照変換

次のケースでは、クラスへの参照を基底クラスへの参照に変換できます。

- 指定された基底クラスはアクセスできます。

- 変換は明確です。 (を参照してください[複数の基底クラス](../cpp/multiple-base-classes.md)あいまいな基底クラスの参照の詳細についてはします)。

変換の結果は、基底クラスを表すサブオブジェクトへのポインターです。

## <a name="pointer-to-member"></a>メンバーへのポインター

クラス メンバーへのポインターは、代入、初期化、比較、および他の式の中で変換できます。 このセクションでは、以下のポインターからメンバーへの変換について説明します。

## <a name="pointer-to-base-class-member"></a>基底クラスのメンバーへのポインター

基底クラスのメンバーへのポインターは、次の条件を満たす場合に、そのクラスから派生したクラスのメンバーへのポインターに変換できます。

- 派生クラスへのポインターから基底クラスへのポインターへの逆変換がアクセス可能である。

- 派生クラスが基底クラスからの仮想的な継承でない。

左のオペランドがメンバーへのポインターである場合、右のオペランドはメンバーへのポインター型であるか、0 に評価される定数式である必要があります。 この代入は、次の場合にのみ有効です。

- 右のオペランドが、左のオペランドと同じクラスのメンバーへのポインターである。

- 左のオペランドが、右のオペランドのクラスからパブリックかつ明確に派生したクラスのメンバーへのポインターである。

## <a name="integral-constant-conversions"></a>整数定数の変換

評価するとゼロになる整数定数式は、"null ポインター" というポインターに変換されます。 このポインターは、すべての有効なオブジェクトまたは関数へのポインターと等しくないと判定されることが保証されます (同じオフセットを持っていても別のオブジェクトを指すことができる、ベース付きのオブジェクトへのポインターを除く)。

次のコードは、クラス `i` のメンバー `A` へのポインターの定義を示しています。 ポインター `pai` が 0、つまり null ポインターに初期化されます。

```cpp
class A
{
public:
int i;
};

int A::*pai = 0;

int main()
{
}
```

## <a name="see-also"></a>関連項目

[C++ 言語リファレンス](../cpp/cpp-language-reference.md)