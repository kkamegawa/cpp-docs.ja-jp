---
title: C++ 型システム (Modern C++)
ms.date: 11/19/2018
ms.topic: conceptual
ms.assetid: 553c0ed6-77c4-43e9-87b1-c903eec53e80
ms.openlocfilehash: ea4d8da9af10df2fb930daaad8374d70b6704d28
ms.sourcegitcommit: a1fad0a266b20b313364a74b16c9ac45d089b1e9
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/11/2019
ms.locfileid: "54220674"
---
# <a name="c-type-system-modern-c"></a>C++ 型システム (Modern C++)

概念*型*C++ では非常に重要です。 変数、関数の引数、関数の戻り値をコンパイルするには、それぞれに型が必要です。 さらに、すべての式 (リテラル値を含む) には、評価前にコンパイラーにより暗黙的に型が指定されます。 型の例を示します**int**整数の値を格納する**二重**浮動小数点値を格納する (とも呼ばれます*スカラー*データ型)、または標準ライブラリ クラス[std::basic_string](../standard-library/basic-string-class.md)テキストを格納します。 定義することで、独自の型を作成することができます、**クラス**または**構造体**します。 型は、変数 (または式の結果) に割り当てられるメモリの量、その変数に格納される値の種類、それらの値の解釈方法 (ビット パターンとして)、その型で実行可能な操作を指定します。 ここでは、C++ の型システムの主な機能の概要を示します。

## <a name="terminology"></a>用語

**変数**:シンボリック リンクが定義されているコードのスコープ全体で参照するデータにアクセスする名前を使用できるように、データの量の名前。 C++ では、*変数*の他の型のインスタンスは通常と呼ばれますが、スカラー データ型のインスタンスを参照してくださいに通常使用*オブジェクト*します。

**オブジェクト**:シンプルさと一貫性では、この資料は、用語を使用して*オブジェクト*クラスまたは構造を使用して、一般的な意味で使用されている任意のインスタンスには参照するには、すべての型が含まれていますスカラー変数を含めています。

**POD 型**(プレーンな古いデータ)。C++ でのデータ型のこの非公式のカテゴリはスカラー型 (基本型」を参照してください)、または*POD クラス*します。 POD クラスには、POD でもない静的データ メンバーはなく、ユーザー定義のコンストラクター、ユーザー定義のデストラクター、ユーザー定義の代入演算子もありません。 また、POD クラスに仮想関数、基底クラス、プライベートまたは保護された非静的データ メンバーもありません。 POD 型は、外部データ交換によく使用されます。たとえば、C 言語で記述されたモジュール (POD 型しかありません) との交換などです。

## <a name="specifying-variable-and-function-types"></a>変数と関数の型の指定

C++ は、*厳密に型指定*言語でありも*静的に型指定された*; すべてのオブジェクトの型、型は決してできません (静的なデータ オブジェクトと混同) に変更します。
**変数を宣言するときに**コードで、その型を明示的に指定するかを使用して、**自動**キーワードを初期化子から型を推測するようコンパイラに指示します。
**関数を宣言するときに**、コード内の各引数と戻り値、型を指定する必要がありますまたは**void**関数によって値が返されない場合。 例外は、任意の型の引数を使用できる関数テンプレートを使用する場合です。

最初に変数を宣言すると、後で型を変更することはできません。 ただし、変数の値または関数の戻り値を異なる型の別の変数にコピーすることはできます。 このような操作が呼び出されて*変換の入力*をする必要がありますが、潜在的なソースのデータの損失や不正確ではまた、します。

POD 型の変数を宣言するときは、初期化する (つまり、初期値を指定する) ことを強くお勧めします。 変数を初期化しないと、以前そのメモリ位置にたまたま存在していたビットで構成される "不要な" 値が含まれたままになります。 これは、特に自動的に初期化が行われる別の言語を使用していた場合は、覚えておくべき C++ の重要な側面です。 非 POD クラス型の変数を宣言した場合、コンストラクターにより初期化が実行されます。

次の例は、それぞれ記述を含む、いくつかの簡単な変数宣言を示しています。 この例は、コンパイラが型情報を使用して、特定の後続の処理を許可または拒否する方法も示しています。

```cpp
int result = 0;              // Declare and initialize an integer.
double coefficient = 10.8;   // Declare and initialize a floating
                             // point value.
auto name = "Lady G.";       // Declare a variable and let compiler
                             // deduce the type.
auto address;                // error. Compiler cannot deduce a type
                             // without an intializing value.
age = 12;                    // error. Variable declaration must
                             // specify a type or use auto!
result = "Kenny G.";         // error. Can’t assign text to an int.
string result = "zero";      // error. Can’t redefine a variable with
                             // new type.
int maxValue;                // Not recommended! maxValue contains
                             // garbage bits until it is initialized.
```

## <a name="fundamental-built-in-types"></a>基本 (組み込み) 型

一部の言語とは異なり、C++ には他のすべての型の派生元となる汎用基本型はありません。 各種言語の Visual C 実装*基本的な型*とも呼ばれます*組み込み型*します。 などの数値型が含まれます**int**、**二重**、**長い**、 **bool**、だけでなく、 **char**と**wchar_t**それぞれ ASCII および UNICODE の文字の型します。 ほとんどの基本型 (を除く**bool**、**二重**、 **wchar_t**と関連する型) のすべてが符号なしのバージョンでは、変数に格納できる値の範囲を変更します。 たとえば、 **int**、32 ビット符号付き整数に格納される値を表すこと-2,147, 483,648 から 2,147, 483,647 です。 **符号なし int**、32 ビットとしても格納される 4,294,967,295 ~ 0 の値を格納できます。 各ケースで格納できる値の合計数は同じです。範囲のみ異なります。

基本型は、実行可能な操作や他の基本型に変換する方法を制御する組み込みの規則を持つコンパイラにより認識されます。 組み込み型およびサイズと数値の制限の完全な一覧を参照してください。[基本的な型](../cpp/fundamental-types-cpp.md)します。

次の図は、組み込み型の相対サイズを示しています。

![サイズ (バイト) のビルド&#45;の種類で](../cpp/media/built-intypesizes.png "のバイト サイズが構築された&#45;型")

次の表は、最もよく使用される基本型の一覧です。

|型|サイズ|コメント|
|----------|----------|-------------|
|int|4 バイト|整数値の既定のオプション。|
|double|8 バイト|浮動小数点値の既定のオプション。|
|bool|1 バイト|true または false になる値を表します。|
|char|1 バイト|以前の C スタイル文字列内の ASCII 文字や、UNICODE に変換する必要がない std::string オブジェクトの ASCII 文字に使用します。|
|wchar_t|2 バイト|UNICODE 形式でエンコードできるワイド文字を表します (Windows では UTF-16。他のオペレーティング システムでは異なる場合があります)。 これは、型 `std::wstring` の文字列で使用される文字型です。|
|符号なし&nbsp;char|1 バイト|C++ には、組み込みの `byte` 型はありません。  バイト値を表すには unsigned char を使用します。|
|unsigned int|4 バイト|ビット フラグの既定のオプション。|
|long long|8 バイト|非常に大きな整数値を表します。|

## <a name="the-void-type"></a>void 型

**Void**型は、特殊な型; 型の変数を宣言することはできません**void**、型の変数を宣言することができますが、 __void \*__  (へのポインター**void**)、生 (型指定されていない) メモリを割り当てるときに必要な場合があります。 ただしへのポインター **void**はタイプ セーフではないと、一般にその使用は、最新の C++ で使用しないでください。 関数の宣言で、 **void**の一般的で適切な使用をこれは戻り値は、関数が値を返さないことを意味**void**します。 0 個のパラメーターを宣言する C 言語のために必要な関数の中に**void**パラメーター リストで`fou(void)`、この実習は最新の C++ で非推奨と宣言されなければなりません`fou()`します。 詳細については、次を参照してください。[型変換とタイプ セーフ](../cpp/type-conversions-and-type-safety-modern-cpp.md)します。

## <a name="const-type-qualifier"></a>const 型修飾子

組み込み型またはユーザー定義型は、const キーワードで修飾することができます。 また、メンバー関数があります**const**-修飾とも**const**のオーバー ロードします。 値を**const**初期化された後、型を変更ことはできません。

```cpp

const double PI = 3.1415;
PI = .75 //Error. Cannot modify const variable.
```

**Const**修飾子は関数と変数の宣言で広く使用されて、「const の正確性」は、C++ の重要な概念と使用する場合は、基本的に; **const**を確実に、コンパイル時に、ある値が誤って変更されません。 詳細については、次を参照してください。 [const](../cpp/const-cpp.md)します。

A **const**型は、非定数のバージョンの異なるなど**const int**から別個の型は、 **int**します。C++ を使用する**const_cast**演算子を削除する必要がありますと特殊な状況に*const 性*変数から。 詳細については、次を参照してください。[型変換とタイプ セーフ](../cpp/type-conversions-and-type-safety-modern-cpp.md)します。

## <a name="string-types"></a>文字列型

厳密に言えば、C++ 言語には組み込みの文字列型がありません。**char**と**wchar_t** 1 つの文字を格納 - 終端の null 値を追加する、文字列を概算するこれらの型の配列を宣言する必要があります (たとえば、ASCII `'\0'`)、配列要素を 1 つに最後の有効な文字 (とも呼ばれる、 *C スタイル文字列*)。 C スタイル文字列では、かなり多くのコードを記述するか、外部文字列ユーティリティ ライブラリ関数を使用する必要がありました。 最新の c++ 標準ライブラリの型があるが、 `std::string` (8 ビットの**char**-文字列を入力) または`std::wstring`(16 ビットの**wchar_t**-文字列を入力)。 準拠の C++ ビルド環境に含まれている標準ライブラリの一部であるために、これらの C++ 標準ライブラリ コンテナーのネイティブの文字列型として考えることができます。 `#include <string>` ディレクティブを使用するだけで、これらの型をプログラムで使用できるようになります  (MFC や ATL を使用している場合、CString クラスも使用できますが、C++ の標準の一部ではありません)。null で終わる文字配列 (前述の C スタイル文字列) は、最新の C++ では使用しないことを強くお勧めします。

## <a name="user-defined-types"></a>ユーザー定義型

定義するときに、**クラス**、**構造体**、**共用体**、または**enum**、基本型の場合と同様に、その構成要素が、コードの残りの部分で使用されます. メモリ内には既知のサイズがあり、コンパイル時のチェックを要求し、実行時にプログラムの有効期間を問い合わせるために使用する方法に関する一定の規則もあります。 基本の組み込み型とユーザー定義型の主な相違点は次のとおりです。

- コンパイラには、ユーザー定義型に関する組み込みの情報はありません。 コンパイル プロセス中に、定義を見つけたときに、型の学習します。

- クラス メンバーまたは非メンバー関数として適切な演算子を定義することで (オーバーロードを通じて)、型で実行可能な操作と他の方に変換する方法を指定します。 詳細については、次を参照してください。[関数のオーバー ロード](function-overloading.md)します。

- 静的に型指定する必要はありません (オブジェクトの型が変化することはないという規則)。 メカニズムを通じて*継承*と*ポリモーフィズム*クラス (クラスのオブジェクトのインスタンスと呼ばれます) のユーザー定義型として宣言された変数でよりも実行時に別の種類がありますコンパイル時にします。 詳細については、「[継承](../cpp/inheritance-cpp.md)」を参照してください。

## <a name="pointer-types"></a>ポインター型

C 言語の初期バージョンからそうであったように、C++ では特別な宣言子 `*` (アスタリスク) を使用して、ポインター型の変数を宣言できます。 ポインター型には、実際のデータ値が格納されているメモリ位置のアドレスが格納されます。 最新の c++ では、これらと呼びます*生のポインター*、特殊な演算子でのコードではアクセスと`*`(アスタリスク) または`->`(ダッシュと大きい-よりも)。 これは呼び出されます*逆参照*、使用する 1 つはスカラーへのポインターまたはオブジェクト内のメンバーへのポインターを逆参照されているかどうかに依存します。 ポインター型の使用は、長い間 C および C++ プログラム開発における最も困難で複雑な側面の 1 つでした。 このセクションでは、いくつかの事実とする場合は、これが不要になったために必要な (またはお勧めします) の最新の C++ で生のポインターの使用に役立つ方法について説明しますの進化したため、すべてのオブジェクトの所有権に生のポインターを使用する、[スマート ポインター](../cpp/smart-pointers-modern-cpp.md) (。詳しく説明このセクションの最後に) します。 現在でも、オブジェクトの観察には生のポインターが役立ち、使用してもかまいませんが、オブジェクトの所有権に使用する必要がある場合は慎重に使用し、生のポインターが所有するオブジェクトを作成および破棄する方法について十分に考慮してください。

まず知る必要がある点は、生のポインター変数を宣言すると、ポインターが逆参照されるときに参照するメモリ位置のアドレスを格納するのに必要なメモリだけが割り当てられるという点です。 データ値自体のメモリの割り当て (とも呼ばれる*バッキング ストア*) がまだ割り当てられていません。 言い換えると、生のポインター変数を宣言することで、実際のデータの変数ではなくメモリ アドレスの変数を作成することになります。 バッキング ストアへの有効なアドレスが含まれることを確認する前にポインター変数を逆参照すると、プログラムで定義されていない動作 (通常は重大なエラー) が発生します。 この種のエラーの例を次に示します。

```cpp
int* pNumber;       // Declare a pointer-to-int variable.
*pNumber = 10;      // error. Although this may compile, it is
                    // a serious error. We are dereferencing an
                    // uninitialized pointer variable with no
                    // allocated memory to point to.
```

この例では、実際の整数データまたはそこに割り当てられた有効なメモリ アドレスを格納するメモリを割り当てずに、ポインター型を逆参照しています。 このエラーを修正するコード例を次に示します。

```cpp
    int number = 10;          // Declare and initialize a local integer
                              // variable for data backing store.
    int* pNumber = &number;   // Declare and initialize a local integer
                              // pointer variable to a valid memory
                              // address to that backing store.
...
    *pNumber = 41;            // Dereference and store a new value in
                              // the memory pointed to by
                              // pNumber, the integer variable called
                              // "number". Note "number" was changed, not
                              // "pNumber".
```

修正後のコード例では、ローカル スタック メモリを使用して、`pNumber` がポイントするバッキング ストアを作成します。 ここでは、説明を簡単にするために基本型を使用しています。 実際には、ポインターのバッキング ストアが動的に割り当てられたと呼ばれるメモリ領域にはほとんどの多くの場合、ユーザー定義型、*ヒープ*(または*フリー ストア*) を使用して、**新しい**キーワード式 (C スタイルのプログラミングでは、古い`malloc()`C ランタイム ライブラリ関数が使用されました)。 割り当てられると、これらの変数は、通常はオブジェクトと呼ば、特にクラス定義に基づいている場合。 使用が割り当てられたメモリ**新しい**、対応する削除する必要があります**削除**ステートメント (または、使用する場合、`malloc()`関数が、C ランタイム関数を割り当てる`free()`)。

ただし、削除を動的に割り当てられたオブジェクトの複雑なコードと呼ばれるリソース バグの原因で特にし忘れることは、*メモリ リーク*します。 したがって、最新の C++ では生のポインターを使用しないことを強くお勧めします。 生のポインターをラップする方が適切ではほぼ常に、[スマート ポインター](../cpp/smart-pointers-modern-cpp.md)が自動的にメモリを解放します (この場合、コードがスマート ポインターのスコープ外になる)、デストラクターが呼び出される; スマート ポインターを使用してする事実上C++ プログラムでバグのクラス全体を削除します。 次の例では、`MyClass` がパブリック メソッド `DoSomeWork();` を持つユーザー定義型であることを前提としています。

```cpp
void someFunction() {
    unique_ptr<MyClass> pMc(new MyClass);
    pMc->DoSomeWork();
}
  // No memory leak. Out-of-scope automatically calls the destructor
  // for the unique_ptr, freeing the resource.
```

スマート ポインターの詳細については、次を参照してください。[スマート ポインター](../cpp/smart-pointers-modern-cpp.md)します。

ポインター変換の詳細については、次を参照してください。[型変換とタイプ セーフ](../cpp/type-conversions-and-type-safety-modern-cpp.md)します。

ポインターの詳細については一般に、表示[ポインター](../cpp/pointers-cpp.md)します。

## <a name="windows-data-types"></a>Windows のデータ型

C および C++ 向けの従来の Win32 プログラミングでは、ほとんどの関数は Windows 固有の typedef マクロと #define マクロ (`windef.h` で定義) を使用して、パラメーターと戻り値の型を指定します。 これらの Windows データ型は、C と C++ の組み込み型に付けられた特殊な名前 (エイリアス) ではほとんどの場合です。 これらの typedef とプリプロセッサ定義の一覧は、次を参照してください。[データ型の Windows](/windows/desktop/WinProg/windows-data-types)します。 HRESULT や LCID など、typedef には便利で内容がわかりやすいものがあります。 INT など、他の typedef には特別な意味がなく、C++ の基本型のエイリアスにすぎません。 他の Windows のデータ型には、C プログラミングおよび 16 ビット プロセッサの時代から残っている名前がありますが、最新のハードウェアやオペレーティング システムでは目的も意味もありません。 またとして一覧表示、Windows ランタイム ライブラリに関連付けられている特殊なデータ型がある[Windows ランタイムの基本データ型](/windows/desktop/WinRT/base-data-types)します。 最新の C++ では、値の解釈方法について Windows の型が追加の意味を伝えるのでない限り、一般的なガイドラインとして C++ の基本型が推奨されます。

## <a name="more-information"></a>説明

C++ の型システムの詳細については、次のトピックを参照してください。

|||
|-|-|
|[値型](../cpp/value-types-modern-cpp.md)|説明*値の型*と使用に関連する問題です。|
|[型変換とタイプ セーフ](../cpp/type-conversions-and-type-safety-modern-cpp.md)|よくある型変換の問題について説明し、その回避方法を示します。|

## <a name="see-also"></a>関連項目

[C++ へようこそ (Modern C++)](../cpp/welcome-back-to-cpp-modern-cpp.md)<br/>
[C++ 言語リファレンス](../cpp/cpp-language-reference.md)<br/>
[.NET 標準ライブラリ](../standard-library/cpp-standard-library-reference.md)
