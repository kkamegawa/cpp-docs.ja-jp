---
title: ソース コードの編成 (C++ テンプレート)
ms.date: 04/22/2019
ms.assetid: 50569c5d-0219-4966-9bcf-a8689074ad1d
ms.openlocfilehash: 1933758e47f2fcc0b63f0d16809591b932501854
ms.sourcegitcommit: 934cb53fa4cb59fea611bfeb9db110d8d6f7d165
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/14/2019
ms.locfileid: "65611395"
---
# <a name="source-code-organization-c-templates"></a>ソース コードの編成 (C++ テンプレート)

クラス テンプレートを定義する場合、メンバーの定義がコンパイラから必要に応じて見えるようにソース コードを編成する必要があります。   使用できる選択肢には、"*包含モデル*" と "*明示的なインスタンス化*" モデルがあります。 包含モデルでは、テンプレートを使うすべてのファイルにメンバーの定義を含めます。 この方法は最もシンプルで、テンプレートで使える具象型について最大の柔軟性が得られます。 これの欠点は、コンパイル時間が増加する可能性があることです。 プロジェクトや含めたファイル自体が大きい場合、大きな影響を及ぼすことがあります。 明示的なインスタンス化の方法では、テンプレート自体によって具象クラスまたは特定の型のクラス メンバーがインスタンス化されます。  この方法によりコンパイル時間を短縮できますが、テンプレートの実装者が前もって有効にしていたクラスしか使えなくなります。 一般的に、コンパイル時間が問題にならない限りは、包含モデルを使うことをお勧めします。

## <a name="background"></a>背景

コンパイラによりテンプレートまたはそのメンバーのオブジェクト コードが生成されないという点で、テンプレートは通常のクラスと異なっています。 テンプレートが具象型でインスタンス化されるまで、生成されるものは何もありません。 コンパイラによりテンプレートのインスタンス化 (`MyClass<int> mc;` など) が見つかり、そのシグネチャを持つクラスがまだ存在していない場合は、新しいクラスが生成されます。 また、使用されるメンバー関数のコードの生成も試行されます。 それらの定義が、コンパイルしている .cpp ファイルに直接または間接的に #include されていないファイルに含まれていた場合、コンパイラではそれらを見つけられません。  コンパイラの観点から見ると、これは必ずしもエラーではありません。関数は別の翻訳単位で定義されているかもしれず、その場合はリンカーによってそれらが検索されるためです。  リンカーでそのコードが見つけられなかった場合、**未解決の外部**エラーが発生します。

## <a name="the-inclusion-model"></a>包含モデル

翻訳単位全体からテンプレートの定義を見つけられるようにするための最も簡単で最も一般的な方法は、ヘッダー ファイル自体に定義を置くことです。  テンプレートを使うすべての .cpp ファイルでは、ヘッダーを #include すればいいだけです。 これは、標準ライブラリで使われている方法です。

```cpp
#ifndef MYARRAY
#define MYARRAY
#include <iostream>

template<typename T, size_t N>
class MyArray
{
    T arr[N];
public:
    // Full definitions:
    MyArray(){}
    void Print()
    {
        for (const auto v : arr)
        {
            std::cout << v << " , ";
        }
    }

    T& operator[](int i)
   {
       return arr[i];
   }
};
#endif
```

この方法を使うと、コンパイラから完全なテンプレートの定義にアクセスでき、必要に応じて任意の型のテンプレートをインスタンス化できます。 これはシンプルで、管理が比較的簡単です。 ただし、包含モデルではコンパイル時間に関するコストがかかります。   大規模なプログラム、特にテンプレート ヘッダー自体で他のヘッダーが #include されている場合は、このコストが深刻になる場合があります。 ヘッダーを #include しているすべての .cpp ファイルでは、関数テンプレートとすべての定義のコピーが独自に取得されます。 最終的に 1 つの関数に対して定義が複数にならないよう、通常はリンカーで整理できるようになりますが、この作業には時間がかかります。 小規模のプログラムでは、その余分なコンパイル時間はおそらく重要にはなりません。

## <a name="the-explicit-instantiation-model"></a>明示的なインスタンス化モデル

自分のプロジェクトに包含モデルを採用できず、またテンプレートをインスタンス化するために使う型のセットが明確にわかっている場合は、テンプレート コードを .h および .cpp ファイルに分離して、.cpp ファイル内で明示的にテンプレートをインスタンス化することができます。 これによりオブジェクト コードが生成されます。これはコンパイラによって、ユーザーのインスタンス化を見つけたときに参照されます。

明示的なインスタンス化を作成するには、キーワードのテンプレートの後にインスタンス化したいエンティティの署名を使います。 これには型またはメンバーを指定できます。 型を明示的にインスタンス化する場合は、すべてのメンバーがインスタンス化されます。

```cpp
template MyArray<double, 5>;
```

```cpp
//MyArray.h
#ifndef MYARRAY
#define MYARRAY

template<typename T, size_t N>
class MyArray
{
    T arr[N];
public:
    MyArray();
    void Print();
    T& operator[](int i);
};
#endif

//MyArray.cpp
#include <iostream>
#include "MyArray.h"

using namespace std;

template<typename T, size_t N>
MyArray<T,N>::MyArray(){}

template<typename T, size_t N>
void MyArray<T,N>::Print()
{
    for(const auto v : arr)
    {
        cout << v << "'";
    }
    cout << endl;
}

template MyArray<double, 5>;template MyArray<string, 5>;
```

前の例では、明示的なインスタンス化は .cpp ファイルの下部にあります。 `MyArray` は、**double** または `String` 型にのみ使用できます。

> [!NOTE]
> C++ 11 では、テンプレートの定義のコンテキストにおいて **export** キーワードが非推奨になりました。 実際には、これの影響はほとんどありません。ほとんどのコンパイラでサポートされていないためです。