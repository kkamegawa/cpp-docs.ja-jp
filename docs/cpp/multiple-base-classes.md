---
title: 複数の基本クラス
ms.date: 11/19/2018
helpviewer_keywords:
- base classes [C++], multiple
- derived classes [C++], multiple bases
- multiple inheritance, class declaration
- multiple base classes [C++]
ms.assetid: a30c69fe-401c-4a87-96a0-e0da70c7c740
ms.openlocfilehash: b58c238da37fbbaf7c2c2913b652c26d98fbd96e
ms.sourcegitcommit: c6f8e6c2daec40ff4effd8ca99a7014a3b41ef33
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/24/2019
ms.locfileid: "64345945"
---
# <a name="multiple-base-classes"></a>複数の基本クラス

クラスは、1 つ以上の基底クラスから派生できます。 (クラスが 1 つ以上の基底クラスから派生した、) 多重継承モデルを使用して基底クラスが指定されて、*基本リスト*文法要素。 たとえば、`CollectionOfBook` および `Collection` から派生する `Book` のクラス宣言は指定できます。

```cpp
// deriv_MultipleBaseClasses.cpp
// compile with: /LD
class Collection {
};
class Book {};
class CollectionOfBook : public Book, public Collection {
    // New members
};
```

基底クラスを指定する順序は、コンストラクターとデストラクターが呼び出されている特定の場合を除き、重要ではありません。 このような場合は、基底クラスを指定する順序は次に影響します。

- コンストラクターで初期化が行われる順序。 コードが、`Book` パーツの前で初期化されるために、`CollectionOfBook` の `Collection` 部分に依存している場合、指定の順序が重要になります。 初期化が、クラスがで指定された順序で行われ、*基本リスト*します。

- デストラクターがクリーンアップされるために呼び出される順序。 ここでも、他のパーツの破棄時にクラスの特定の「パーツ」が存在する必要がある場合、順序が重要になります。 デストラクターで指定されたクラスの逆の順序で呼び出されます、*基本リスト*します。

    > [!NOTE]
    >  基底クラスの指定の順序はクラスのメモリ レイアウトに影響を与える場合があります。 メモリの基本メンバーの順序に基づいて、プログラムの決定を行わないでください。

指定するときに、*基本リスト*、同じクラス名を複数回指定することはできません。 ただし、間接基底クラスは複数回派生クラスとなることができます。

## <a name="virtual-base-classes"></a>仮想基底クラス

クラスは派生クラスへの間接基底クラスであることが複数回可能であるため、C++ にはこのような基底クラスの動作を最適化する方法が用意されています。 仮想基底クラスは、領域を節約し、多重継承を使用するクラス階層でのあいまいさを避ける方法を提供します。

非仮想オブジェクトはそれぞれ、基底クラスで定義されたデータ メンバーのコピーを含んでいます。 この重複によって領域が浪費され、基底クラスのメンバーのコピーにアクセスするたびに、どちらのコピーかを指定しなければならなくなります。

仮想基底クラスとして指定された基底クラスは、データ メンバーを複製しなくても、間接基底クラスとして複数回使用できます。 データ メンバーの 1 つのコピーが、仮想基底クラスとして使用するすべての基底クラスで共有されます。

仮想基底クラスを宣言するときに、**virtual**キーワードは派生クラスの基底のリストに表示されます。

昼食の行列をシミュレートした、次の図のクラス階層構造を考えます。

![Lunch-line シミュレーション グラフ](../cpp/media/vc38xp1.gif "lunch-line シミュレーション グラフ") <br/>
Lunch-line シミュレーション グラフ

図で、`Queue` は、`CashierQueue` および `LunchQueue` の基底クラスです。 ただし、`LunchCashierQueue` を作成するために両方のクラスを組み合わせると、新しいクラスに、`Queue` 型のサブオブジェクトが 2 つ (1 つは `CashierQueue` のサブオブジェクト、もう 1 つは `LunchQueue` のサブオブジェクト) が含まれるという問題が生じます。 次の図は、概念的なメモリ レイアウトを示します (実際のメモリ レイアウトは最適化される場合があります)。

![昼食をシミュレートした&#45;行オブジェクト](../cpp/media/vc38xp2.gif "昼食をシミュレートした&#45;行オブジェクト") <br/>
Lunch-Line シミュレーション オブジェクト

`Queue` オブジェクトに 2 つの `LunchCashierQueue` サブオブジェクトがあることに注意してください。 次のコードは、`Queue` が仮想基底クラスであることを宣言します。

```cpp
// deriv_VirtualBaseClasses.cpp
// compile with: /LD
class Queue {};
class CashierQueue : virtual public Queue {};
class LunchQueue : virtual public Queue {};
class LunchCashierQueue : public LunchQueue, public CashierQueue {};
```

**virtual**キーワードにより、サブオブジェクトの 1 つだけコピー`Queue`が含まれています (次の図を参照してください)。

![昼食をシミュレートした&#45;行オブジェクト、仮想基底クラス](../cpp/media/vc38xp3.gif "昼食をシミュレートした&#45;行オブジェクト、仮想基底クラス") <br/>
仮想基底クラスを持つ、シミュレートされた lunch-line オブジェクト

クラスは、指定された型の仮想コンポーネントと非仮想コンポーネントの両方を持つことができます。 これは、次の図に示されている条件で発生します。

![仮想および非&#45;クラスの仮想コンポーネント](../cpp/media/vc38xp4.gif "仮想および非&#45;クラスの仮想コンポーネント") <br/>
同じクラスの仮想および非仮想コンポーネント

図では、`CashierQueue` と `LunchQueue` は仮想基底クラスとして `Queue` を使用します。 ただし、`TakeoutQueue` は、仮想基底クラスではなく、基底クラスとして `Queue` を指定します。 したがって、`LunchTakeoutCashierQueue` には型 `Queue` の 2 つのサブオブジェクトがあります。1 つは `LunchCashierQueue` を含む継承パスからのもので、もう 1 つは `TakeoutQueue` を含むパスからのものです。 これを次の図に示します。

![仮想および非&#45;オブジェクトのレイアウトで仮想継承](../cpp/media/vc38xp5.gif "仮想および非&#45;オブジェクトのレイアウトで仮想継承") <br/>
仮想および非仮想継承を持つオブジェクトのレイアウト

> [!NOTE]
>  仮想継承は、非仮想継承と比較してサイズに関して大きな利点があります。 ただし、余分な処理オーバーヘッドが生じる場合があります。

派生クラスが仮想基底クラスから継承する仮想関数をオーバーライドする場合、および派生基底クラスのコンストラクターまたはデストラクターが仮想基底クラスへのポインターを使用してその関数を呼び出す場合、コンパイラは仮想基底クラスを含むクラスに追加の vtordisp 隠しフィールドを導入する場合があります。 `/vd0`コンパイラ オプションは、隠し vtordisp コンストラクター/デストラクター ディスプレイスメント メンバーの追加を抑制します。 `/vd1`コンパイラ オプションで、既定では、依存関係が必要できます。 すべてのクラス コンストラクターとデストラクターが仮想的に仮想関数を呼び出すことが確実な場合にだけ、vtordisp をオフにしてください。

`/vd`コンパイラ オプションがコンパイル モジュール全体に影響します。 使用して、`vtordisp`を抑制し、再度有効にするプラグマ`vtordisp`クラスによってごとにフィールド。

```cpp
#pragma vtordisp( off )
class GetReal : virtual public { ... };
\#pragma vtordisp( on )
```

## <a name="name-ambiguities"></a>名前のあいまいさ

多重継承には、名前が、複数のパスに沿って継承される可能性があります。 これらのパスに沿ったクラス メンバーの名前は、必ずしも一意ではありません。 これらの名前の競合は "あいまいさ" と呼ばれます。

クラス メンバーを参照する式は、明確な参照を作成する必要があります。 次の例は、あいまいさがどのように増すかを示します。

```cpp
// deriv_NameAmbiguities.cpp
// compile with: /LD
// Declare two base classes, A and B.
class A {
public:
    unsigned a;
    unsigned b();
};

class B {
public:
    unsigned a();  // Note that class A also has a member "a"
    int b();       //  and a member "b".
    char c;
};

// Define class C as derived from A and B.
class C : public A, public B {};
```

前のクラス宣言では、`b` が `b` または `A` のどちらの `B` を参照しているか不明確であるため、次のようなコードはあいまいになります。

```cpp
C *pc = new C;

pc->b();
```

前の例を考えます。 名前 `a` は `A` クラスと `B` クラスの両方のメンバーであるため、コンパイラはどの `a` が呼び出される関数を指定するか識別できません。 メンバーへのアクセスは、複数の関数、オブジェクト、型、または列挙子を参照できる場合はあいまいになります。

コンパイラは、この順序でテストを実行することにより、あいまいさを検出します。

1. 名前へのアクセスが (単に記述されているとおりに) あいまいな場合、エラー メッセージが生成されます。

1. オーバーロードされた関数があいまいでなければ、その関数は解決されます

1. 名前へのアクセスがメンバーのアクセス許可に違反する場合、エラー メッセージが生成されます (詳細については、次を参照してください[メンバー アクセス コントロール](../cpp/member-access-control-cpp.md)。)。

式が継承によるあいまいさを生成するときは、クラス名で該当する名前を修飾することにより手動で解決できます。 前の例をあいまいさなしで正しくコンパイルするには、コードを次のように使用します。

```cpp
C *pc = new C;

pc->B::a();
```

> [!NOTE]
>  `C` を宣言すると、`B` が `C` のスコープ内で参照されるとエラーが発生することがあります。 ただし、`B` のスコープ内で `C` への不適切な参照が実際に行われるまで、エラーは発行されません。

### <a name="dominance"></a>優先度

継承グラフをたどったときに複数の名前 (関数、オブジェクト、または列挙子) に到達することがあります。 そのようなケースは、非仮想基底クラスではあいまいであると見なされます。 名前のいずれかの "優先度" が他よりも高くない限り、仮想基底クラスでもあいまいになります。

1 つのクラスから別のクラスが派生していて、その両方に同じ名前が定義されている場合、一方の名前の優先度がもう一方より高くなります。 優先度が高くなる名前は、派生クラスにある名前です。この名前は、これを使用しないとあいまいさが発生する可能性がある場合に使用されます。次の例を参照してください。

```cpp
// deriv_Dominance.cpp
// compile with: /LD
class A {
public:
    int a;
};

class B : public virtual A {
public:
    int a();
};

class C : public virtual A {};

class D : public B, public C {
public:
    D() { a(); } // Not ambiguous. B::a() dominates A::a.
};
```

### <a name="ambiguous-conversions"></a>あいまいな変換

クラス型へのポインターまたは参照からの明示的および暗黙的な変換によって、あいまいさが生じる可能性があります。 次の図、「基底クラスへのポインターのあいまいな変換」は、以下のことを示しています。

- `D` 型のオブジェクトの宣言。

- Address-of 演算子を適用する効果 ( **&** ) そのオブジェクトにします。 アドレス演算子は、常にオブジェクトのベース アドレスを指定することに注意してください。

- アドレス演算子を使用して取得したポインターを、基底クラス型 `A` に明示的に変換する効果。 オブジェクトのアドレスを `A*` 型に強制変換しても、2 つのサブオブジェクトが存在する場合、`A` 型のどのサブオブジェクトを選択するのかについて十分な情報が必ずコンパイラに提供されるわけではありません。

![基底クラスへのポインターのあいまいな変換](../cpp/media/vc38xt1.gif "基底クラスへのポインターのあいまいな変換") <br/>
基底クラスへのポインターのあいまいな変換

`A*` 型のサブオブジェクトのどれが正しいかを識別する方法はないため、`A` 型への変換 (`A` へのポインター) はあいまいです。 次のように、使用するサブオブジェクトを明示的に指定することにより、あいまいさを避けることができます。

```cpp
(A *)(B *)&d       // Use B subobject.
(A *)(C *)&d       // Use C subobject.
```

### <a name="ambiguities-and-virtual-base-classes"></a>あいまいさと仮想基底クラス

仮想基底クラスが使用されている場合、関数、オブジェクト、型、および列挙子には、多重継承のパスを通じて到達できます。 基底クラスのインスタンスは 1 つだけあるため、これらの名前にアクセスする場合にあいまいさはありません。

次の図は、仮想継承と非仮想継承を使用してオブジェクトがどのように構成されているかを示しています。

![仮想派生および非&#45;仮想派生](../cpp/media/vc38xr1.gif "仮想派生および非&#45;仮想派生") <br/>
仮想および非仮想派生

この図では、非仮想基底クラスを通じてクラス `A` のメンバーにアクセスすると、あいまいさが発生します。コンパイラは、`B` に関連付けられているサブオブジェクトと `C` に関連付けられているサブジェクトのどちらを使用するかを示す情報を持ちません。 しかし、`A` が仮想基底クラスとして指定されている場合、どのサブオブジェクトがアクセスされているかは問題になりません。

## <a name="see-also"></a>関連項目

[継承](../cpp/inheritance-cpp.md)