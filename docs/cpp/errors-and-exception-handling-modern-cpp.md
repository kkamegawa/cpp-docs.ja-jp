---
title: エラーと例外の処理 (Modern C++)
ms.date: 09/17/2018
ms.topic: conceptual
ms.assetid: a6c111d0-24f9-4bbb-997d-3db4569761b7
ms.openlocfilehash: c3def77d8b7a22be05259784e3b80562c8728c15
ms.sourcegitcommit: a1fad0a266b20b313364a74b16c9ac45d089b1e9
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/11/2019
ms.locfileid: "54220570"
---
# <a name="errors-and-exception-handling-modern-c"></a>エラーと例外の処理 (Modern C++)

最新の C++ のほとんどのシナリオでは、論理エラーとランタイム エラーの両方を報告および処理する方法として、例外を使用することが推奨されます。 これは特に、エラーを検出した関数からその処理方法を認識するためのコンテキストを持つ関数までの間に、複数の関数がスタックに含まれる可能性がある場合に当てはまります。 例外は、エラーを検出して情報を呼び出し履歴に渡すコードに関する、正しく定義された正式な方法を提供します。

プログラム エラーは通常 2 つのカテゴリに分類されます。1 つは、プログラミングの間違いにより生じる論理エラー ("範囲外のインデックス" エラーなど) で、もう 1 つはプログラマの種類に分ける通常は: 誤り、たとえば、「有効範囲外のインデックス」エラーのプログラムによる論理エラー、およびプログラマが制御できないランタイム エラー ("ネットワーク サービスが利用不可" エラーなど) です。 C スタイル プログラミングと COM では、特定の関数のエラー コードまたはステータス コードを表す値を返すか、エラーが報告されたかどうかを確認するすべての関数呼び出しの後に呼び出し元がオプションで取得する可能性があるグローバル変数を設定することで、エラー レポートが管理されます。 たとえば、COM プログラミングは HRESULT 戻り値を使用してエラーを呼び出し元に通知します。また、Win32 API には、呼び出し履歴により報告された最後のエラーを取得する GetLastError 関数があります。 どちらの場合も、呼び出し元がコードを認識し、適切に応答することにかかっています。 呼び出し元が明示的にエラー コードを処理しない場合、プログラムが警告なしにクラッシュしたり、不適切なデータで実行を続けて間違った結果が生成される可能性があります。

最新の C++ では、次の理由で例外が推奨されます。

- 例外は、エラー状態の認識と処理を呼び出し元コードに強制します。 ハンドルされない例外は、プログラムの実行を停止します。

- 例外は、エラーを処理できる呼び出し履歴内のポイントにジャンプします。 中間関数は、例外を伝達することができます。 他のレイヤーに合わせる必要はありません。

- 例外のスタック アンワインド機構は、例外のスロー後に明確に定義された規則に従ってスコープ内のすべてのオブジェクトを破棄します。

- 例外によって、エラーを検出したコードとエラーを処理するコードを明確な区別することができるようになります。

簡略化された次の例は、C++ で例外をスローしてキャッチするのに必要な構文を示しています。

```cpp

#include <stdexcept>
#include <limits>
#include <iostream>

using namespace std;

void MyFunc(int c)
{
    if (c > numeric_limits< char> ::max())
        throw invalid_argument("MyFunc argument too large.");
    //...
}

int main()
{
    try
    {
        MyFunc(256); //cause an exception to throw
    }

    catch (invalid_argument& e)
    {
        cerr << e.what() << endl;
        return -1;
    }
    //...
    return 0;
}
```

C++ の例外は、C# や Java などの言語と似ています。 **を再試行してください**ブロック、例外がある場合*スロー*なります*キャッチ*の最初の関連付けられている**キャッチ**のと同じ型のブロック、例外。 つまり、実行が移動することから、**スロー**ステートメントを**キャッチ**ステートメント。 使用可能な catch ブロックが見つからない場合、`std::terminate` が呼び出されてプログラムが終了します。 C++ では、どの種類もスローされる可能性があります。ただし、`std::exception` から直接または間接的に派生した型をスローすることをお勧めします。 前の例では、例外の種類で[invalid_argument](../standard-library/invalid-argument-class.md)、標準ライブラリで定義されて、 [ \<stdexcept >](../standard-library/stdexcept.md)ヘッダー ファイル。 C++ を指定しないは必要ありません、**最後に**ブロックに例外がスローされた場合に、すべてのリソースが解放されるかどうかを確認します。 スマート ポインターを使用する Resource Acquisition Is Initialization (RAII) の表現形式には、リソース クリーンアップのための必須機能が用意されています。 詳細については、「[方法 :例外安全性のための設計](../cpp/how-to-design-for-exception-safety.md)します。 C++ のスタック アンワインド機構については、次を参照してください。[例外とスタック アンワインド](../cpp/exceptions-and-stack-unwinding-in-cpp.md)します。

## <a name="basic-guidelines"></a>基本的なガイドライン

堅牢なエラー処理は、どのプログラミング言語でも簡単ではありません。 例外には、適切なエラー処理をサポートする機能がいくつか用意されていますが、すべての処理を自動的に行うことはできません。 例外機構の利点を理解するため、コードをデザインするときに例外を念頭に置いてください。

- 発生することのないエラーをチェックするには、アサートを使用します。 発生する可能性があるエラー (たとえば、パブリック関数のパラメーターにおける入力検証のエラーなど) をチェックするには、例外を使用します。 詳細については、「セクションを参照してください。**例外とします。アサーション**します。

- 例外は、エラーを処理するコードが、1 つ以上の介在する関数呼び出しによりエラーを検出したコードから切り離されている可能性がある場合に使用します。 エラーを処理するコードが、エラーを検出したコードに密に結合されている場合は、パフォーマンスが重要なループで代わりにエラー コードを使用するかどうかを検討します。

- 例外をスローまたは伝達する可能性のある関数ごとに、strong 保証、basic 保証、nothrow (noexcept) 保証の 3 つの例外保証のいずれかを指定します。 詳細については、「[方法 :例外安全性のための設計](../cpp/how-to-design-for-exception-safety.md)します。

- 値渡しで例外をスローし、参照渡しでそれらの例外をキャッチします。 処理できない例外をキャッチしないでください。

- C++11 で非推奨とされた例外指定を使用しないでください。 詳細については、「セクションを参照してください。**例外指定と noexcept**します。

- 標準ライブラリの例外の種類は、適用するときに使用します。 カスタム例外型から派生、 [exception クラス](../standard-library/exception-class.md)階層。

- 例外がデストラクターまたはメモリ解放関数からエスケープしないようにしてください。

## <a name="exceptions-and-performance"></a>例外とパフォーマンス

例外がスローされない場合、例外機構によるパフォーマンスの低下はごくわずかです。 例外がスローされた場合、スタックの走査およびアンワインドによるパフォーマンスの低下は、関数呼び出しとほぼ同程度です。 追加のデータ構造が後に呼び出し履歴を追跡するために必要な**お試しください**ブロックが入力され、例外がスローされた場合、スタックをアンワインドする追加手順が必要です。 ただし、ほとんどの場合、パフォーマンスの低下とメモリ使用量の増加はそれほど大きくありません。 パフォーマンスに対する例外の悪影響は、メモリ制約が非常に大きいシステムでのみ大きくなる可能性があります。エラーが定期的に発生する可能性が高く、エラーを処理するコードがエラーを報告したコードに密に結合されている、パフォーマンスが重要なループでも大きくなる可能性があります。 いずれの場合も、プロファイリングや測定を行わずに例外の実際の影響を把握することは不可能です。 影響が大きくなるまれな場合でも、優れたデザインの例外ポリシーにより実現する正確さの向上、管理の容易さ、他の利点と比較することができます。

## <a name="exceptions-vs-assertions"></a>例外とアサーション

例外とアサーションは、プログラムのランタイム エラーを検出する 2 つの別個の機構です。 開発時にアサートを使用して、すべてのコードが正しい場合は true になることがない条件をテストします。 エラーはコード内に修正が必要な箇所があることを示しており、プログラムが実行時から回復する必要がある条件を表しているわけではないため、例外を使用してそのようなエラーを処理するポイントはありません。 デバッガーでプログラムの状態を検査できるように、アサートはステートメントで実行を停止します。例外は、該当する最初のキャッチ ハンドラーから実行を続行します。 コードが正しい場合でも実行時に発生する可能性があるエラー条件 ("ファイルが見つかりません" や "メモリ不足" など) をチェックするには、例外を使用します。 回復によりログにメッセージが出力され、プログラムが終了するだけの場合でも、これらの条件から回復することができます。 必ず、例外を使用してパブリックの関数への引数をチェックしてください。 関数にエラーがない場合でも、ユーザーが渡す引数を完全に制御できないことがあります。

## <a name="c-exceptions-versus-windows-seh-exceptions"></a>C++ 例外と Windows SEH 例外

C プログラムと C++ プログラムのどちらでも、Windows オペレーティング システムの構造化例外処理 (SEH) 機構を使用できます。 SEH の概念のように、C++ 例外で SEH を使用する点を除いて、 **_ _try**、 **_ _except**、および **_ _finally**の代わりに構築**をお試しください**と**キャッチ**します。 Visual C++ では、C++ 例外が SEH 用に実装されています。 ただし、C++ コードを記述するときは、C++ 例外構文を使用してください。

SEH の詳細については、次を参照してください。[構造化例外処理 (c/c++)](../cpp/structured-exception-handling-c-cpp.md)します。

## <a name="exception-specifications-and-noexcept"></a>例外指定と noexcept

例外指定は、関数がスローする可能性がある例外を指定する方法として C++ に導入されました。 ただし、実際には例外指定に問題があることがわかったため、C++11 ドラフト標準では非推奨とされます。 以外の例外の仕様を使用しないことをお勧めします。 `throw()`、関数が例外のエスケープを許可されませんを示します。 型の例外の仕様を使用する必要がある場合`throw(`*型*`)`、Visual C が、特定の方法で、標準と異なることに注意してください。 詳細については、次を参照してください。[例外の仕様 (スロー)](../cpp/exception-specifications-throw-cpp.md)します。 `noexcept` 指定子は、`throw()` の推奨される代替手段として C++11 に導入されました。

## <a name="see-also"></a>関連項目

[方法: 例外と非例外的なコードの間のインターフェイスします。](../cpp/how-to-interface-between-exceptional-and-non-exceptional-code.md)<br/>
[C++ へようこそ (Modern C++)](../cpp/welcome-back-to-cpp-modern-cpp.md)<br/>
[C++ 言語リファレンス](../cpp/cpp-language-reference.md)<br/>
[.NET 標準ライブラリ](../standard-library/cpp-standard-library-reference.md)
