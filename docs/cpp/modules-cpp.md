---
title: C++ のモジュールの概要
ms.date: 12/13/2019
helpviewer_keywords:
- modules [C++]
- modules [C++], overview
description: C++ 20 のモジュールは、ヘッダーファイルに代わる新しい機能を提供します。
ms.openlocfilehash: 28e1824250ad4fb404c528aa9511745abb001f31
ms.sourcegitcommit: a5fa9c6f4f0c239ac23be7de116066a978511de7
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/20/2019
ms.locfileid: "75301380"
---
# <a name="overview-of-modules-in-c"></a>C++ のモジュールの概要

C++ 20 では、 C++ライブラリとプログラムをコンポーネント化するための最新のソリューションであるモジュールが導入されています。 モジュールは、インポート元の[翻訳単位](https://wikipedia.org/wiki/Translation_unit_(programming))とは別にコンパイルされるソースコードファイルのセットです。 モジュールによって、ヘッダーファイルの使用に関連する問題の多くが解消されるか、大幅に削減されます。また、コンパイル時間が短縮される可能性もあります。 モジュールで宣言されているマクロ、プリプロセッサディレクティブ、およびエクスポートされていない名前は表示されないため、モジュールをインポートする翻訳単位のコンパイルには影響しません。 マクロの再定義を気にせずに、任意の順序でモジュールをインポートできます。 インポートする翻訳単位の宣言は、インポートされたモジュールのオーバーロードの解決や名前の参照には関与しません。 モジュールが一度コンパイルされると、結果は、エクスポートされたすべての型、関数、およびテンプレートを記述するバイナリファイルに格納されます。 このファイルは、ヘッダーファイルよりもはるかに高速に処理できます。また、モジュールがプロジェクトにインポートされる場所ごとに、コンパイラによって再利用できます。

モジュールは、ヘッダーファイルとサイドバイサイドで使用できます。 ソースC++ファイルでは、モジュールをインポートしたり、ヘッダーファイルを #include することもできます。 場合によっては、プリプロセッサによって #included ではなく、モジュールとしてヘッダーファイルをインポートできます。 新しいプロジェクトでは、可能な限りヘッダーファイルではなくモジュールを使用することをお勧めします。 アクティブな開発中の大規模な既存プロジェクトの場合は、従来のヘッダーをモジュールに変換してみることをお勧めします。これにより、コンパイル時間が大幅に短縮されているかどうかがわかります。

## <a name="enable-modules-in-the-microsoft-c-compiler"></a>Microsoft C++コンパイラでモジュールを有効にする

Visual Studio 2019 バージョン16.2 では、モジュールは Microsoft C++コンパイラで完全には実装されていません。 モジュール機能を使用して、単一パーティションのモジュールを作成し、Microsoft が提供する標準ライブラリモジュールをインポートすることができます。 モジュールのサポートを有効にするには、 [/実験的: module](../build/reference/experimental-module.md)および[/std:c++latest](../build/reference/std-specify-language-standard-version.md)を使用してコンパイルします。 Visual Studio プロジェクトで、**ソリューションエクスプローラー**のプロジェクトノードを右クリックし、 **[プロパティ]** を選択します。 **[構成]** ドロップダウンを **[すべての構成]** に設定し、 **[構成プロパティ]**  > [ **C++ C/**  > **言語**] >  **[モジュールを有効にするC++ (試験段階)]** の順に選択します。

モジュールとそれを使用するコードは、同じコンパイラオプションを使用してコンパイルする必要があります。

## <a name="consume-the-c-standard-library-as-modules"></a>標準ライブラリC++をモジュールとして使用する

C++ 20 標準では指定されていませんが、Microsoft C++では標準ライブラリの実装をモジュールとしてインポートできます。 C++標準ライブラリをモジュールとしてインポートすることで、ヘッダーファイルを使用して #including するのではなく、プロジェクトのサイズによってはコンパイル時間を短縮できる可能性があります。 ライブラリは、次のモジュールに分類されています。

- std. regex は、ヘッダー \<regex の内容を提供し >
- std. ファイルシステムは、ヘッダー \<ファイルシステムの内容を提供 >
- std. memory は、ヘッダー \<メモリの内容を提供 >
- std. スレッドは、atomic > \<のヘッダーの内容、\<condition_variable >、\<将来の >、\<mutex >、\<shared_mutex >、および \<スレッドを提供 >
- std は、 C++標準ライブラリ内の他のすべての機能を提供します。

これらのモジュールを使用するには、インポート宣言をソースコードファイルの先頭に追加するだけです。 例:

```cpp
import std.core;
import std.regex;
```

Microsoft 標準ライブラリモジュールを使用するには、 [/ehsc](../build/reference/eh-exception-handling-model.md)オプションと[/md](../build/reference/md-mt-ld-use-run-time-library.md)オプションを使用してプログラムをコンパイルします。

## <a name="basic-example"></a>基本的な例

次の例では、 **Foo. ixx**という名前のソースファイル内の単純なモジュール定義を示します。 Visual Studio のモジュールインターフェイスファイルには、 **. ixx**拡張子が必要です。 この例では、インターフェイスファイルに関数定義と宣言が含まれています。 ただし、定義は1つ以上の個別のファイルに配置することもできます (後の例を参照)。 **Export Module Foo**ステートメントは、このファイルが `Foo`というモジュールの主要なインターフェイスであることを示しています。 `f()` の**export**修飾子は、`Foo` が別のプログラムまたはモジュールによってインポートされたときに、この関数が表示されることを示します。 モジュールは `Bar`名前空間を参照することに注意してください。

```cpp
export module Foo;

#define ANSWER 42

namespace Bar 
{
   int f_internal() {
        return ANSWER;
      }

   export int f() {
      return f_internal();
   }
}
```

ファイル**Myprogram**は、**インポート**宣言を使用して、`Foo`によってエクスポートされた名前にアクセスします。 `Bar` 名前はここに表示されますが、すべてのメンバーではないことに注意してください。 また、マクロ `ANSWER` が表示されないことにも注意してください。

```cpp

import Foo;
import std.core;

using namespace std;

int main()
{
   cout << "The result of f() is " << Bar::f() << endl; // 42
   // int i = Bar::f_internal(); // C2039
   // int j = ANSWER; //C2065
}

```

インポート宣言は、グローバルスコープでのみ表示できます。

## <a name="implementing-modules"></a>モジュールの実装

名前をエクスポートし、すべての関数と型の実装を含む単一のインターフェイスファイル (ixx) を持つモジュールを作成できます。 また、1つまたは複数の個別の実装ファイルに実装を配置することもできます。これは、.h ファイルと .cpp ファイルの使用方法と似ています。 **Export**キーワードは、インターフェイスファイルでのみ使用されます。 実装ファイルは別のモジュールを**インポート**できますが、名前を**エクスポート**することはできません。 実装ファイルの名前には、任意の拡張子を付けることができます。 インターフェイスファイルと、それを返す一連の実装ファイルは、*モジュール単位*と呼ばれる特別な種類の翻訳単位として扱われます。 任意の実装ファイルで宣言された名前は、同じモジュール単位内の他のすべてのファイルで自動的に表示されます。

大きなモジュールの場合は、*パーティション*と呼ばれる複数のモジュール単位にモジュールを分割できます。 各パーティションは、1つまたは複数の実装ファイルによってサポートされるインターフェイスファイルで構成されます。 (Visual Studio 2019 バージョン16.2 以降では、パーティションはまだ完全には実装されていません)。

## <a name="modules-namespaces-and-argument-dependent-lookup"></a>モジュール、名前空間、および引数依存の参照

モジュール内の名前空間の規則は、他のコードと同じです。 名前空間内の宣言をエクスポートする場合、外側の名前空間 (エクスポートされていないメンバーを除く) も暗黙的にエクスポートされます。 名前空間が明示的にエクスポートされた場合、その名前空間定義内のすべての宣言がエクスポートされます。

インポート翻訳単位のオーバーロードの解決に対して引数依存の参照を実行すると、コンパイラは、関数の引数の型と同じ翻訳単位 (モジュールインターフェイスを含む) で宣言されている関数を検討します。が定義されています。

### <a name="module-partitions"></a>モジュールパーティション

> [!NOTE]
> このセクションは、完全を期すために用意されています。 パーティションは、Microsoft C++コンパイラではまだ実装されていません。

モジュールは、1つのインターフェイスファイルと0個以上の実装ファイルで構成される*パーティション*にコンポーネント化できます。 モジュールパーティションはモジュールに似ていますが、モジュール全体のすべての宣言の所有権を共有する点が異なります。 パーティションインターフェイスファイルによってエクスポートされたすべての名前は、プライマリインターフェイスファイルによってインポートおよび再エクスポートされます。 パーティションの名前は、モジュール名の後にコロンを付ける必要があります。 パーティション内の宣言は、モジュール全体で参照できます。 1つの定義規則 (ODR) エラーを回避するために特別な予防措置は必要ありません。 1つのパーティションで名前 (関数、クラスなど) を宣言し、別のパーティションで定義することができます。 パーティションの実装ファイルは次のように始まります。

```cpp
module Foo:part1
```

パーティションインターフェイスファイルは次のように始まります。

```cpp
export module Foo:part1
```

別のパーティションの宣言にアクセスするには、パーティションでインポートする必要がありますが、パーティション名は使用できますが、モジュール名は使用できません。

```cpp
module Foo:part2;
import :part1;
```

プライマリインターフェイスユニットは、次のように、モジュールのすべてのインターフェイスパーティションファイルをインポートして、再エクスポートする必要があります。

```cpp
export import :part1
export import :part2
...
```

プライマリインターフェイスユニットは、パーティションの実装ファイルをインポートできますが、これらのファイルは名前のエクスポートが許可されていないため、エクスポートできません。 これにより、モジュールはモジュールの内部で実装の詳細を保持できます。

## <a name="modules-and-header-files"></a>モジュールとヘッダーファイル

モジュールの宣言の前に `#include` ディレクティブを配置することで、モジュールのソースファイルにヘッダーファイルを含めることができます。 これらのファイルは、*グローバルモジュールフラグメント*に含まれると見なされます。 モジュールは、明示的にインクルードされているヘッダー内にある*グローバルモジュールフラグメント*内の名前のみを参照できます。 グローバルモジュールフラグメントには、実際に使用されるシンボルだけが含まれます。

```cpp
// MyModuleA.cpp

#include "customlib.h"
#include "anotherlib.h"

import std.core;
import MyModuleB;

//... rest of file
```

従来のヘッダーファイルを使用して、どのモジュールをインポートするかを制御できます。

```cpp
// MyProgram.h
import std.core;
#ifdef DEBUG_LOGGING
import std.filesystem;
#endif
```

### <a name="imported-header-files"></a>インポートされたヘッダーファイル

> [!NOTE]
> このセクションは情報提供のみを目的としています。 レガシインポートは、Microsoft C++コンパイラではまだ実装されていません。

一部のヘッダーは、import キーワードを使用して**取り込む**ことができる十分な自己完結しています。 インポートされたヘッダーとインポートされたモジュールの主な違いは、ヘッダー内のプリプロセッサ定義は、import ステートメントの直後にインポートプログラムに表示されるという点です。 (そのヘッダーに含まれるすべてのファイルのプリプロセッサ定義は表示され*ません*)。

```cpp
import <vector>
import "myheader.h"
```

## <a name="see-also"></a>関連項目

[モジュール、インポート、エクスポート](import-export-module.md)
