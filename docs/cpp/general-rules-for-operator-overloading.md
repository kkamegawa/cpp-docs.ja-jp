---
title: 演算子のオーバーロードに関する一般的な規則
ms.date: 11/04/2016
helpviewer_keywords:
- operator overloading [C++], rules
ms.assetid: eb2b3754-35f7-4832-b1da-c502893dc0c7
ms.openlocfilehash: 1eceb26a244bc6dd2d5243e54f5e3b8391d88ed1
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2019
ms.locfileid: "62153763"
---
# <a name="general-rules-for-operator-overloading"></a>演算子のオーバーロードに関する一般的な規則

次の規則は、オーバーロードした演算子の実装のされ方を抑制します。 ただし、これらには適用されません、[new](../cpp/new-operator-cpp.md)と[delete](../cpp/delete-operator-cpp.md)演算子は個別に説明します。

- の新しい演算子を定義することはできません **.** します。

- 組み込みのデータ型に適用された場合、演算子の意味は再定義できません。

- オーバーロードされた演算子は、非静的クラス メンバー関数またはグローバル関数である必要があります。 プライベートまたはプロテクト クラス メンバーへのアクセスを必要とするグローバル関数は、クラスのフレンドとして宣言する必要があります。 グローバル関数は、クラスまたは列挙型の引数、またはクラスまたは列挙型への参照である引数を 1 個以上受け取る必要があります。 例えば:

    ```cpp
    // rules_for_operator_overloading.cpp
    class Point
    {
    public:
        Point operator<( Point & );  // Declare a member operator
                                     //  overload.
        // Declare addition operators.
        friend Point operator+( Point&, int );
        friend Point operator+( int, Point& );
    };

    int main()
    {
    }
    ```

   前のコード サンプルは、メンバー関数として小なり演算子を宣言します。ただし、加算演算子はフレンド アクセスを持つグローバル関数として宣言されます。 複数の実装を特定の演算子に対して提供できることに注意してください。 前の加算演算子の場合は、可換を容易にするため、2 種類の実装が用意されています。 追加する演算子と、`Point`を`Point`、 **int**を`Point`で実装される場合があります。

- 演算子は、組み込み型との一般的な使用方法によって指定されるオペランドの優先順位、グループ、および数に従います。 そのため、という概念を表現する方法はありません"2 および 3 を型のオブジェクトに追加`Point`、"に追加する 2 を指定してください、 *x*に追加するには、座標、3、 *y*を調整します。

- メンバー関数として宣言された単項演算子は引数を受け取りません。グローバル関数として宣言された場合は、引数を 1 つ受け取ります。

- メンバー関数として宣言された二項演算子は引数を 1 つ受け取ります。グローバル関数として宣言された場合は、引数を 2 つ受け取ります。

- 演算子を単項演算子または二項演算子のいずれかとして使用できるかどうか ( __&__ 、 __*__ 、 __+__ 、および __-__ )、それぞれの使用を個別にオーバー ロードできます。

- オーバーロードされた演算子は、既定の引数を持つことができません。

- オーバー ロードされたすべての割り当てを除く演算子 (**演算子 =** ) 派生クラスによって継承されます。

- メンバー関数のオーバーロードされた演算子の最初の引数は、常に演算子が呼び出されたオブジェクトのクラス型です (演算子が宣言されたクラス、またはそのクラスから派生したクラス)。 最初の引数に対して変換の指定はありません。

どの演算子も意味を完全に変更できることに注意してください。 アドレスの意味を含みます ( **&** )、割り当て ( **=** )、および関数呼び出し演算子。 また、組み込みの型に依存できる ID は、演算子のオーバーロードを使用して変更できます。 たとえば、次の 4 つのステートメントは、通常、完全に評価される場合は等価です。

```cpp
var = var + 1;
var += 1;
var++;
++var;
```

演算子をオーバーロードするクラス型では、この ID に依存できません。 また、基本型に対してこれらの演算子の使用が暗黙に必要とされていた条件は一部オーバーロードされる演算子に対して緩和されています。 たとえば、加算/代入演算子、  **+=** 左辺値基本型に適用されるときに左側のオペランドが必要です、演算子がオーバー ロードされたときに、このような要件はありません。

> [!NOTE]
> 一貫性のために、オーバーロードされた演算子を定義する場合、組み込み型のモデルに従うことをお勧めします。 オーバーロードされた演算子のセマンティクスが他のコンテキストではその意味とは大きく異なる場合、便利というよりも混乱を招く可能性があります。

## <a name="see-also"></a>関連項目

[演算子のオーバーロード](../cpp/operator-overloading.md)
