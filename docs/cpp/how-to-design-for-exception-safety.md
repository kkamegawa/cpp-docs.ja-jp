---
title: '方法: 例外安全性のための設計'
ms.custom: how-to
ms.date: 11/04/2016
ms.topic: conceptual
ms.assetid: 19ecc5d4-297d-4c4e-b4f3-4fccab890b3d
ms.openlocfilehash: 2dada25ea712b7bb6d48d80525c824a0457b18cf
ms.sourcegitcommit: a1fad0a266b20b313364a74b16c9ac45d089b1e9
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/11/2019
ms.locfileid: "54220553"
---
# <a name="how-to-design-for-exception-safety"></a>方法: 例外安全性のための設計

例外機構の利点の 1 つは、例外をスローするステートメントから例外を処理する最初の catch ステートメントに、例外に関するデータと共に実行が直接ジャンプすることです。 ハンドラーは呼び出し履歴の何レベル上であってもかまいません。 try ステートメントと throw ステートメントの間で呼び出された関数は、スローされる例外に関して何も知る必要がありません。  ただし、例外が下から上に通知される可能性があるどの時点でも、予期せずにスコープから外れることができるように関数が設計されている必要があり、部分的に作成されたオブジェクト、リークしたメモリ、使用不能な状態のデータ構造体などが部分的に残らないようになっている必要があります。

## <a name="basic-techniques"></a>基本技術

堅牢な例外処理ポリシーには、熟考が必要であり、デザイン プロセスの一部になっている必要があります。 一般に、ほとんどの例外は、ソフトウェア モジュールの下位層で検出されてスローされますが、一般にこれらの層には、エラーを処理したり、エンド ユーザーにメッセージを通知するための十分なコンテキストがありません。 中間層の関数は、例外オブジェクトを検査する必要があったり、最終的に例外をキャッチする上位層のための有用な追加情報がある場合に、例外をキャッチして再スローできます。 関数が例外をキャッチしてそれを "飲み込む" ことができるのは、例外から完全に回復できる場合のみです。 多くの場合、中間層の正しい動作は、呼び出し履歴の上方向へ例外を伝達することです。 最上位層でも、例外によってプログラムがその正しさを保証できない状態になる場合は、例外を処理せずにプログラムを終了するのが適切な場合があります。

関数が例外を処理する方法にかかわらず、"例外セーフ" であることを保証するには、次の基本的なルールに従って関数が設計されている必要があります。

### <a name="keep-resource-classes-simple"></a>リソース クラスを単純にする

クラスに手動のリソース管理をカプセル化するときは、各リソースの管理以外何も行わないクラスを使用します。そうしないと、リークが発生する可能性があります。 使用[スマート ポインター](../cpp/smart-pointers-modern-cpp.md)可能な場合、次の例に示すようにします。 この例は、`shared_ptr` を使用した場合の相違点を強調するため、意図的に作成し簡略化されています。

```cpp
// old-style new/delete version
class NDResourceClass {
private:
    int*   m_p;
    float* m_q;
public:
    NDResourceClass() : m_p(0), m_q(0) {
        m_p = new int;
        m_q = new float;
    }

    ~NDResourceClass() {
        delete m_p;
        delete m_q;
    }
    // Potential leak! When a constructor emits an exception,
    // the destructor will not be invoked.
};

// shared_ptr version
#include <memory>

using namespace std;

class SPResourceClass {
private:
    shared_ptr<int> m_p;
    shared_ptr<float> m_q;
public:
    SPResourceClass() : m_p(new int), m_q(new float) { }
    // Implicitly defined dtor is OK for these members,
    // shared_ptr will clean up and avoid leaks regardless.
};

// A more powerful case for shared_ptr

class Shape {
    // ...
};

class Circle : public Shape {
    // ...
};

class Triangle : public Shape {
    // ...
};

class SPShapeResourceClass {
private:
    shared_ptr<Shape> m_p;
    shared_ptr<Shape> m_q;
public:
    SPShapeResourceClass() : m_p(new Circle), m_q(new Triangle) { }
};
```

### <a name="use-the-raii-idiom-to-manage-resources"></a>RAII の表現形式を使用してリソースを管理する

使用して、割り当てられているオブジェクトを例外セーフにするには、関数を確認する必要があります`malloc`または**新しい**が破棄され、ファイル ハンドルなどのすべてのリソースが閉じられるか、例外がスローされた場合でもリリースされたとします。 *Resource Acquisition Is Initialization* (RAII) の表現形式の自動変数の有効期間には、このようなリソースの管理に結び付いています。 正常に返るか例外により関数がスコープから外れた場合、すべての完全構築された自動変数のデストラクターが呼び出されます。 スマート ポインターなどの RAII ラッパー オブジェクトは、デストラクターの中で適切な delete または close 関数を呼び出します。 例外セーフなコードでは、なんらかの種類の RAII オブジェクトに各リソースの所有権をすぐに渡すことが非常に重要です。 なお、 `vector`、 `string`、 `make_shared`、 `fstream`、および同様のクラス処理するためのリソースを取得します。  ただし、`unique_ptr`と従来`shared_ptr`構造は、リソースの取得がオブジェクトではなく、ユーザーが実行されるため、特別な; としてカウントするため、*リソース リリースが破棄*されますが、問題のある RAII として。

## <a name="the-three-exception-guarantees"></a>3 種類の例外保証

例外安全性が関数を提供する 3 つの例外保証に関して議論は通常、: *no-fail 保証*、 *strong 保証*、および*basic 保証*.

### <a name="no-fail-guarantee"></a>no-fail 保証

no-fail (または no-throw) 保証は、関数が提供できる最も強力な保証です。 それは、関数が例外をスローしないか、例外の伝達を許可することを示します。 ただし、(a) この関数が呼び出すすべての関数が no-fail であることがわかっているか、(b) スローされるすべての例外がこの関数に達する前にキャッチされることがわかっているか、(c) この関数に達する可能性があるすべての例外をキャッチし正しく処理する方法がわかっている場合を除いて、確実にこのようなことを保証できません。

strong 保証と basic 保証のどちらも、デストラクターが no-fail であることを前提としています。 標準ライブラリのすべてのコンテナーと型は、デストラクターが例外をスローしないことを保証します。 逆の要件です。標準ライブラリは、ユーザー定義型が必要ですに指定されます: たとえば、テンプレート引数として — デストラクターをスローしない必要があります。

### <a name="strong-guarantee"></a>strong 保証

strong 保証は、関数が例外によりスコープから外れる場合、メモリをリークせず、プログラムの状態が変化しないことを示します。 strong 保証を提供する関数は、基本的にコミットまたはロールバック セマンティクスを持つトランザクションです。つまり、完全に成功するか無効かのどちらかになります。

### <a name="basic-guarantee"></a>basic 保証

basic 保証は、3 つのうちで最も弱い保証です。 ただし、strong 保証がメモリ消費またはパフォーマンスの点で高価すぎる場合に最善の選択肢となる場合があります。 basic 保証は、例外が発生した場合は、データが変更された可能性があるとしても、メモリがリークせず、オブジェクトが引き続き使用可能な状態にあることを示します。

## <a name="exception-safe-classes"></a>例外セーフなクラス

クラスは、安全でない関数で使用される場合であっても、自身が部分的に構築されたり部分的に破棄されるのを防ぐことにより、自身の例外セーフ性を保証するのに役立つことがあります。 クラス コンストラクターが完了前に終了した場合、オブジェクトは作成されず、そのデストラクターは決して呼び出されません。 例外の前に初期化された自動変数のデストラクターは呼び出されますが、動的に割り当てられたメモリや、スマート ポインターなどの自動変数によって管理されていないリソースはリークすることになります。

組み込みの型はすべて no-fail であり、標準ライブラリの型は少なくとも basic 保証をサポートしています。 例外セーフである必要があるすべてのユーザー定義型について、次のガイドラインに従ってください。

- スマート ポインターまたは他の RAII 型ラッパーを使用してすべてのリソースを管理します。 コンストラクターが例外をスローするとデストラクターが起動されないので、クラスのデストラクターにリソース管理機能を持たせないようにします。 ただし、クラスが 1 種類のリソースのみを制御する専用のリソース マネージャーである場合は、デストラクターを使用してリソースを管理してもかまいません。

- 基底クラスのコンストラクターでスローされる例外は、派生クラスのコンストラクターで飲み込むことができない点に注意します。 基底クラスの例外を派生クラスのコンストラクターで変換して再スローする場合は、関数の try ブロックを使用します。

- 特に、クラスに "失敗することが可能な初期化" の概念がある場合は、すべてのクラス状態を、スマート ポインターでラップされたデータ メンバーに保存するかどうかを検討します。 C++ では初期化されていないデータ メンバーが許可されていますが、初期化されていないか部分的に初期化されたクラス インスタンスはサポートされていません。 コンストラクターは成功または失敗のいずれかであることが必要です。コンストラクターが最後まで実行されない場合、オブジェクトは作成されません。

- デストラクターから例外が漏れないようにします。 C++ の基本的な原則は、デストラクターで例外が呼び出し履歴の上方向へ伝達されないようにすることです。 デストラクターで例外をスローする可能性がある操作を実行する必要がある場合は、try catch ブロックで実行し、例外を飲み込む必要があります。 標準ライブラリでは、定義されているすべてのデストラクターでこのことが保証されます。

## <a name="see-also"></a>関連項目

[エラーと例外の処理 (Modern C++)](../cpp/errors-and-exception-handling-modern-cpp.md)<br/>
[方法: 例外と非例外的なコードの間のインターフェイスします。](../cpp/how-to-interface-between-exceptional-and-non-exceptional-code.md)
