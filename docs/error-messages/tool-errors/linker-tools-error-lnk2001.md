---
title: リンカー ツール エラー LNK2001
ms.date: 12/19/2019
f1_keywords:
- LNK2001
helpviewer_keywords:
- LNK2001
ms.assetid: dc1cf267-c984-486c-abd2-fd07c799f7ef
ms.openlocfilehash: b6d1e53d8f057ddc93e2dfde65cb951d247dfcc0
ms.sourcegitcommit: a5fa9c6f4f0c239ac23be7de116066a978511de7
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/20/2019
ms.locfileid: "75302134"
---
# <a name="linker-tools-error-lnk2001"></a>リンカー ツール エラー LNK2001

> 未解決の外部シンボル "*symbol*"

コンパイルされたコードは、*シンボル*への参照または呼び出しを行います。 シンボルは、リンカーによって検索されるライブラリまたはオブジェクトファイルで定義されていません。

このエラーメッセージの後には、致命的なエラー [LNK1120](../../error-messages/tool-errors/linker-tools-error-lnk1120.md)が続きます。 エラー LNK1120 を修正するには、まず LNK2001 エラーと LNK2019 エラーをすべて修正します。

LNK2001 エラーを取得するには、さまざまな方法があります。 これらのすべてには、リンカーが*解決*できない関数または変数への*参照*、またはの定義を見つけることが含まれます。 コンパイラは、コードがシンボルを*宣言*していないときは特定できますが、*定義*されていない場合は識別できません。 これは、定義が別のソースファイルまたはライブラリに存在する可能性があるためです。 コードがシンボルを参照していても定義されていない場合、リンカーはエラーを生成します。

## <a name="what-is-an-unresolved-external-symbol"></a>未解決の外部シンボルとは何ですか。

*シンボル*は、関数またはグローバル変数の内部名です。 これは、コンパイルされたオブジェクトファイルまたはライブラリで使用または定義されている名前の形式です。 グローバル変数は、ストレージが割り当てられるオブジェクトファイルで定義されます。 関数は、関数本体のコンパイル済みコードが配置されるオブジェクトファイル内で定義されます。 *外部シンボル*は1つのオブジェクトファイルで参照されていますが、別のライブラリまたはオブジェクトファイルで定義されています。 エクスポートされたシンボルとは、オブジェクトファイルまたはライブラリを定義するライブラリによって公開される*シンボル*です。

アプリケーションまたは DLL を作成するには、すべてのシンボルが定義されている必要があります。 リンカーは、各オブジェクトファイルによって参照されるすべての外部シンボルを*解決*するか、一致する定義を検索する必要があります。 外部シンボルを解決できない場合、リンカーはエラーを生成します。 リンカーが、リンクされたファイルのいずれかで、一致するエクスポートされたシンボル定義を見つけられなかったことを意味します。

## <a name="compilation-and-link-issues"></a>コンパイルとリンクの問題

このエラーは次の場合に発生する可能性があります。

- プロジェクトにライブラリへの参照 () がない場合。LIB) またはオブジェクト (.OBJ) ファイル。 この問題を解決するには、必要なライブラリまたはオブジェクトファイルへの参照をプロジェクトに追加します。 詳細については、「[リンカー入力としての Lib ファイル](../../build/reference/dot-lib-files-as-linker-input.md)」を参照してください。

- プロジェクトにライブラリへの参照がある場合 (.LIB) またはオブジェクト (.OBJ) ファイルに別のライブラリのシンボルが必要です。 依存関係を引き起こす関数を呼び出さない場合でも発生する可能性があります。 この問題を解決するには、他のライブラリへの参照をプロジェクトに追加します。 詳細については、「[リンクの古典モデルと](https://devblogs.microsoft.com/oldnewthing/20130108-00/?p=5623)は」を参照してください。

- [/NODEFAULTLIB](../../build/reference/nodefaultlib-ignore-libraries.md)オプションまたは[/zl](../../build/reference/zl-omit-default-library-name.md)オプションを使用する場合。 これらのオプションを指定すると、明示的にインクルードしない限り、必須コードを含むライブラリはプロジェクトにリンクされません。 この問題を解決するには、リンクコマンドラインで使用するすべてのライブラリを明示的に含めます。 これらのオプションを使用するときに、不足している CRT や標準ライブラリの関数名が多数表示される場合は、CRT および標準ライブラリ Dll またはライブラリファイルをリンクに明示的に含めます。

- **/Clr**オプションを使用してコンパイルする場合。 `.cctor`への参照が不足している可能性があります。 この問題を解決する方法の詳細については、「[混在アセンブリの初期化](../../dotnet/initialization-of-mixed-assemblies.md)」を参照してください。

- アプリケーションのデバッグバージョンをビルドするときにリリースモードライブラリにリンクする場合。 同様に、 **/MTd**または **/mdd**オプションを使用して `_DEBUG` を定義してからリリースライブラリにリンクする場合は、他の問題の中で未解決の可能性がある多くの外部関係を想定する必要があります。 デバッグライブラリを使用してリリースモードビルドをリンクすると、同様の問題が発生します。 この問題を解決するには、デバッグビルドでデバッグライブラリを使用し、リテールビルドでリテールライブラリを使用していることを確認します。

- コードが1つのライブラリバージョンのシンボルを参照している場合に、別のバージョンのライブラリをリンクします。 一般に、異なるバージョンのコンパイラ用に構築されたオブジェクトファイルやライブラリを混在させることはできません。 1つのバージョンで出荷されるライブラリには、他のバージョンに含まれているライブラリには見つからないシンボルが含まれている場合があります。 この問題を解決するには、同じバージョンのコンパイラを使用してすべてのオブジェクトファイルとライブラリをビルドしてから、それらをリンクします。 詳細については、「 [ C++バイナリ互換性 2015-2019](../../porting/binary-compat-2015-2017.md)」を参照してください。

- ライブラリパスが古くなっている場合。 **[ライブラリファイル]** の選択 の下にある **[VC + + ディレクトリに > プロジェクト > ツール > オプション]** を選択すると、ライブラリの検索順序を変更できます。 プロジェクトの [プロパティページ] ダイアログボックスの [リンカー] フォルダーには、古いパスが含まれている場合もあります。

- 新しい Windows SDK が (場合によっては別の場所に) インストールされたとき。 ライブラリの検索順序は、新しい場所を指すように更新する必要があります。 通常は、新しい SDK include ディレクトリと lib ディレクトリへのパスを既定の視覚的C++な場所の前に配置する必要があります。 また、埋め込みパスを含むプロジェクトは、有効な古いパスを指している可能性がありますが、最新ではありません。 別の場所にインストールされている新しいバージョンによって追加された新しい機能のパスを更新します。

- をコマンドラインでビルドし、独自の環境変数を作成した場合。 ツール、ライブラリ、およびヘッダーファイルへのパスが、一貫性のあるバージョンに移行していることを確認します。 詳細については、「[コマンドラインビルドのパスと環境変数の設定](../../build/setting-the-path-and-environment-variables-for-command-line-builds.md)」を参照してください。

## <a name="coding-issues"></a>コーディングに関する問題

このエラーは、次のことが原因で発生する場合があります。

- ソースコードまたはモジュール定義 (.def) ファイルで大文字と小文字が一致しません。 たとえば、あるC++ソースファイルで `var1` 変数に名前を付け、別のソースファイルで `VAR1` としてアクセスしようとすると、このエラーが生成されます。 この問題を解決するには、一貫した綴りの付いた名前を使用します。

- [関数のインライン展開](../../error-messages/tool-errors/function-inlining-problems.md)を使用するプロジェクト。 これは、ヘッダーファイルではなく、ソースファイル内の `inline` として関数を定義した場合に発生する可能性があります。 インライン関数は、それを定義するソースファイルの外部では表示できません。 この問題を解決するには、宣言されているヘッダー内のインライン関数を定義します。

- C 関数の `extern "C"` 宣言をC++使用せずに、プログラムから c 関数を呼び出します。 コンパイラは、C とC++コードに異なる内部シンボルの名前付け規則を使用します。 内部シンボル名は、シンボルを解決するときにリンカーが検索するものです。 この問題を解決するには、コード内で使用されてC++いる c 関数のすべての宣言に対して `extern "C"` ラッパーを使用します。これにより、コンパイラは、これらのシンボルに対して c 内部の名前付け規則を使用します。 コンパイラオプション[/tp](../../build/reference/tc-tp-tc-tp-specify-source-file-type.md)および[/tc](../../build/reference/tc-tp-tc-tp-specify-source-file-type.md)では、ファイル名の拡張子C++に関係なく、コンパイラがファイルをまたは C としてコンパイルします。 これらのオプションを使用すると、内部関数名が予期したものと異なる場合があります。

- 外部リンケージを持たない関数またはデータを参照しようとしました。 でC++は、インライン関数と `const` データは、`extern`として明示的に指定されていない限り、内部リンケージを持ちます。 この問題を解決するには、定義元のソースファイルの外部で参照されるシンボルに対して明示的な `extern` 宣言を使用します。

- [関数本体または変数](../../error-messages/tool-errors/missing-function-body-or-variable.md)定義が不足しています。 このエラーは、コード内で変数、関数、またはクラスを宣言して定義しない場合によく発生します。 コンパイラは、関数プロトタイプまたは `extern` 変数宣言だけを使用して、エラーを発生させずにオブジェクトファイルを生成する必要がありますが、関数の呼び出しや変数への参照をリンカーで解決することはできません。関数コードまたは変数空間が予約されていないためです。 この問題を解決するには、リンクするソースファイルまたはライブラリ内のすべての参照関数と変数を定義してください。

- 戻り値の型、パラメーターの型、または関数の定義と一致しない呼び出し規約を使用する関数呼び出し。 オブジェクトC++ファイルでは、[名前の装飾](../../error-messages/tool-errors/name-decoration.md)によって、呼び出し規則、クラスまたは名前空間スコープ、および関数の戻り値とパラメーターの型がエンコードされます。 エンコードされた文字列は、最後の修飾された関数名の一部になります。 この名前は、他のオブジェクトファイルから関数の呼び出しを解決または照合するためにリンカーによって使用されます。 この問題を解決するには、関数の宣言、定義、および呼び出しがすべて同じスコープ、型、および呼び出し規約を使用していることを確認してください。

- C++関数プロトタイプをクラス定義に含めたが、関数の[実装が含まれて](../../error-messages/tool-errors/missing-function-body-or-variable.md)いない場合は、呼び出すコード。 この問題を解決するには、呼び出すすべてのクラスメンバーの定義を指定してください。

- 抽象基本クラスから純粋仮想関数を呼び出そうとしました。 純粋仮想関数には基底クラスの実装がありません。 この問題を解決するには、呼び出されたすべての仮想関数が実装されていることを確認します。

- 関数内で宣言された変数 ([ローカル変数](../../error-messages/tool-errors/automatic-function-scope-variables.md)) をその関数のスコープ外で使用しようとしています。 この問題を解決するには、スコープ内にない変数への参照を削除するか、変数を上位のスコープに移動します。

- ATL プロジェクトのリリースバージョンをビルドすると、CRT スタートアップコードが必要であることを示すメッセージが生成されます。 この問題を解決するには、次のいずれかの操作を行います。

  - プリプロセッサ定義の一覧から `_ATL_MIN_CRT` を削除して、CRT スタートアップコードを含めることができるようにします。 詳細については、「 [[全般] プロパティページ (プロジェクト)](../../build/reference/general-property-page-project.md)」を参照してください。

  - 可能であれば、CRT スタートアップコードを必要とする CRT 関数の呼び出しを削除します。 代わりに、Win32 に相当するものを使用してください。 たとえば、`strcmp` の代わりに `lstrcmp` を使用します。 CRT スタートアップコードを必要とする既知の関数は、一部の文字列関数と浮動小数点関数です。

## <a name="consistency-issues"></a>一貫性の問題

現在、コンパイラベンダー間での名前の装飾や、同じコンパイラの異なるバージョン間での[ C++名前の装飾](../../error-messages/tool-errors/name-decoration.md)の標準はありません。 異なるコンパイラでコンパイルされたオブジェクトファイルは、同じ名前付けスキームを使用できません。 リンクすると、エラー LNK2001 が発生する可能性があります。

[インラインコンパイルオプションと非インラインコンパイルオプション](../../error-messages/tool-errors/function-inlining-problems.md)を異なるモジュールに混在させると、LNK2001 が発生する可能性があります。 関数のC++インライン展開が有効になっているライブラリが作成された場合 ( **/ob1**または **/ob2**)、関数を説明する対応するヘッダーファイルでインライン化が無効になっている (`inline` キーワードがない) 場合は、このエラーが発生します。 この問題を解決するには、他のソースファイルに含めるヘッダーファイルに `inline` 関数を定義します。

`#pragma inline_depth` コンパイラディレクティブを使用する場合は、[値が2以上](../../error-messages/tool-errors/function-inlining-problems.md)に設定されていることを確認し、/ [ob1](../../build/reference/ob-inline-function-expansion.md)または[/ob2](../../build/reference/ob-inline-function-expansion.md)コンパイラオプションも使用していることを確認してください。

このエラーは、リソースのみの DLL を作成するときにリンクオプション/NOENTRY を省略した場合に発生する可能性があります。 この問題を解決するには、/NOENTRY オプションを link コマンドに追加します。

このエラーは、プロジェクトで間違った/SUBSYSTEM または/ENTRY 設定を使用した場合に発生する可能性があります。 たとえば、コンソールアプリケーションを作成し、/SUBSYSTEM: WINDOWS を指定した場合、`WinMain`に対して未解決の外部エラーが生成されます。 この問題を解決するには、オプションがプロジェクトの種類と一致していることを確認してください。 これらのオプションとエントリポイントの詳細については、「 [/SUBSYSTEM](../../build/reference/subsystem-specify-subsystem.md)および[/entry](../../build/reference/entry-entry-point-symbol.md)リンカーオプション」を参照してください。

## <a name="exported-def-file-symbol-issues"></a>エクスポートされた .def ファイルシンボルの問題

このエラーは、.def ファイルに一覧表示されているエクスポートが見つからない場合に発生します。 エクスポートが存在しないか、スペルが間違っているか、またC++は装飾名を使用している可能性があります。 .Def ファイルは装飾名を受け取りません。 この問題を解決するには、不要なエクスポートを削除し、エクスポートされたシンボルに対して `extern "C"` 宣言を使用します。

## <a name="use-the-decorated-name-to-find-the-error"></a>装飾名を使用してエラーを見つける

コンパイラC++とリンカーは、名前の装飾を使用します。これは、*名前の*[装飾](../../error-messages/tool-errors/name-decoration.md)とも呼ばれます。 名前の装飾は、シンボル名に含まれる変数の型に関する追加情報をエンコードします。 関数のシンボル名は、戻り値の型、パラメーターの型、スコープ、および呼び出し規約をエンコードします。 この装飾名は、リンカーが外部シンボルを解決するために検索するシンボル名です。

関数または変数の宣言が関数または変数の定義と*完全*に一致しない場合、リンクエラーが発生する可能性があります。 これは、一致させるシンボル名の一部に違いがあるためです。 このエラーは、呼び出し元のコードと定義するコードの両方で同じヘッダーファイルが使用されている場合でも発生する可能性があります。 異なるコンパイラフラグを使用してソースファイルをコンパイルすると、1つの方法が考えられます。 たとえば、コードが `__vectorcall` 呼び出し規約を使用するようにコンパイルされているものの、既定の `__cdecl` または `__fastcall` の呼び出し規約を使用してクライアントが呼び出すライブラリにリンクする場合などです。 この場合、呼び出し規約が異なるため、シンボルが一致しません。

原因を見つけるために、エラーメッセージには名前の2つのバージョンが表示されます。 "表示名"、"ソースコードで使用される名前"、および "装飾名" (かっこ内) の両方が表示されます。 装飾名を解釈する方法を知る必要はありません。 それでも、他の装飾名を検索して比較することができます。 コマンドラインツールを使用すると、期待されるシンボル名と実際のシンボル名を見つけて比較することができます。

- DUMPBIN コマンドラインツールの [ [/エクスポート](../../build/reference/dash-exports.md)] オプションと [ [/記号](../../build/reference/symbols.md)] オプションは、ここでは便利です。 これらは、.dll ファイルとオブジェクトファイルまたはライブラリファイルで定義されているシンボルを検出するのに役立ちます。 シンボルの一覧を使用して、エクスポートされた装飾名が、リンカーが検索する装飾名と一致することを確認できます。

- 場合によっては、リンカーはシンボルの装飾名のみを報告できます。 UNDNAME コマンドラインツールを使用すると、装飾名の装飾されていない形式を取得できます。

## <a name="additional-resources"></a>その他の技術情報

詳細については、「[未定義の参照/未解決の外部シンボルエラーとその解決方法」](https://stackoverflow.com/q/12573816/2002113)を参照してください Stack Overflow。
