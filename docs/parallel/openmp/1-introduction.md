---
title: 1. はじめに
ms.date: 01/16/2019
ms.assetid: c42e72bc-0e31-4b1c-b670-cd82673c0c5a
ms.openlocfilehash: 8c735408bdf9f9a13693bd0ad25df185bb1db42a
ms.sourcegitcommit: 382e247c0f1b4cb7c2dab837b8b6fdff24bff47a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/28/2019
ms.locfileid: "55087276"
---
# <a name="1-introduction"></a>1.はじめに

このドキュメントでは、コンパイラ ディレクティブ、ライブラリ関数、および C および C++ プログラムでの共有メモリの並列処理の指定に使用できる環境変数のコレクションを指定します。 このドキュメントで説明されている機能と総称、 *OpenMP C と C++ アプリケーション プログラム インターフェイス (API)* します。 この仕様の目的では、並列プログラミング モデルを提供するにより、さまざまなベンダーからの共有メモリ アーキテクチャ間で移植できるプログラムです。 多くのベンダーからのコンパイラでは、OpenMP C と C++ の API をサポートします。 OpenMP の詳細についてを含む、 *OpenMP Fortran アプリケーション プログラミング インターフェイス*、次の web サイトにあります。

[https://www.openmp.org](https://www.openmp.org)

ディレクティブ、ライブラリ関数、およびこのドキュメントで定義されている環境変数を作成して移植しながら並列プログラムを管理できます。 ディレクティブは、モデルを拡張、C および C++ シーケンシャル プログラミング (SPMD) 複数のデータ構造の 1 つのプログラム、work-sharing コンス トラクター、および同期の構成要素を使用します。 共有とのデータをプライベート化もサポートしています。 OpenMP C および C++ API をサポートするコンパイラにはをアクティブ化し、すべての OpenMP コンパイラ ディレクティブの解釈は、コンパイラのコマンド ライン オプションが含まれます。

## <a name="11-scope"></a>1.1 スコープ

この仕様は、のみユーザー指向の並列処理、どのようなアクションを明示的に定義する場合、コンパイラとランタイム システムは、並列プログラムの実行を実行します。 OpenMP C および C++ の実装では、依存関係、競合、デッドロック、競合状態、または正しくないプログラムの実行と、その他の問題を確認する必要ありません。 OpenMP C および C++ API の構造を使用して、アプリケーションが正しく実行されることを保証します。 このドキュメントでは、コンパイラによって生成された自動並列化し、このような並列処理を支援するために、コンパイラ ディレクティブについて説明します。

## <a name="12-definition-of-terms"></a>1.2 用語の定義

次の用語は、このドキュメントで使用されます。

- barrier

  同期ポイント チームのすべてのスレッドに到達する必要があります。  各スレッドは、この時点で、チームのすべてのスレッドが到着するまで待機します。 ディレクティブは、実装によって作成された暗黙のバリアで識別される明示的な障壁があります。

- construct

  ステートメントにコンス トラクターを示します。 ディレクティブ、含まれています、構造化ブロックします。 一部のディレクティブでは、構造の一部はありません。 (を参照してください*openmp ディレクティブ*で[付録 C](c-openmp-c-and-cpp-grammar.md))。

- ディレクティブ

  C または C++`#pragma`続けて、`omp`識別子、その他のテキスト、および改行します。 ディレクティブには、プログラムの動作を指定します。

- 動的範囲

  すべてのステートメント、*構文範囲*、構文の範囲内のステートメントの実行の結果として実行される関数内のすべてのステートメントとします。 動的範囲と呼ばれることも、*リージョン*します。

- 構文範囲

  ステートメントが構文的に保持されている、*構造化ブロック*します。

- マスタ スレッド

  チームを作成したスレッドと、*並列領域*を入力します。

- 並列領域

  OpenMP の parallel コンストラクトにバインドし、多数のスレッドによって実行される可能性があるステートメント。

- private

  プライベート変数の参照を行っているスレッドに一意の記憶域のブロックを名前します。 プライベート変数を指定するためのいくつかの方法があります: 並行領域内の定義を`threadprivate`ディレクティブ、 `private`、 `firstprivate`、 `lastprivate`、または`reduction`句、または変数としての使用、`for`ループ内のコントロール変数を`for`直後に、次のループを`for`または`parallel for`ディレクティブ。

- region

  動的範囲。

- serial リージョン

  ステートメントによってのみ実行される、*マスター スレッド*動的範囲のいずれかの外部で*並列領域*します。

- シリアル化します。

  Parallel コンストラクトで実行します。

  - スレッドのみを単一のスレッド (つまり、parallel コンストラクトのマスター スレッド) から成るチーム

  - シリアル (ブロック、parallel コンストラクトの一部でなかった場合と同じ順序に付け)、構造化ブロック内のステートメントの実行順序と

  - によって返される値に影響しない`omp_in_parallel()`(いずれかの効果とは別には、並列構造を入れ子になった)。

- shared

  共有変数は、1 つのブロック記憶域の名前します。 この変数にアクセスする、チーム内のすべてのスレッドには、この 1 つのブロック記憶域のアクセスもできます。

- 構造化ブロック

  構造化ブロックは、1 つのエントリと 1 つの終了を持つステートメント (単一または複合) です。 ステートメントの内外にジャンプする場合は、そのステートメントは、構造化ブロックです。 (このルールには呼び出しが含まれています`longjmp`(3 C) の使用または`throw`への呼び出しが、`exit`は許可されて)。開くときに常にその実行が開始された場合`{`終了で終わる`}`、複合ステートメントは、構造化ブロックします。 式ステートメントは、選択ステートメント、反復ステートメント、または`try`ブロックは、構造化ブロックで囲まれた対応する複合ステートメントが取得される場合`{`と`}`構造化ブロックになります。 ジャンプ ステートメント、ラベル付きステートメント、または宣言ステートメントは、構造化ブロックにはありません。

- チーム

  1 つ以上のスレッドが、コンス トラクターの実行に協力します。

- スレッド

  シリアル、制御フロー、一連の秘密の変数、および共有変数へのアクセスを持つ実行エンティティ。

- 変数

  オブジェクトの名前を示す識別子、名前空間の名前で修飾できます。

## <a name="13-execution-model"></a>1.3 実行モデル

OpenMP では、並列実行の fork と join のモデルを使用します。 この fork-join モデルは、さまざまな問題を解決するのに役立ちますが、大規模な配列ベースのアプリケーション用に調整されています。 OpenMP は正しく両方 (多くのスレッドの実行と完全な OpenMP のサポート ライブラリを)、並列プログラムとして実行するプログラムをサポートするためのものです。 正しく順次プログラム (ディレクティブは無視し、簡単な OpenMP スタブ ライブラリ) を実行するプログラムです。 ただし、可能性があり、順番に実行されたときに正しく動作しないプログラムを開発します。 さらに、並列処理の程度が異なる可能性があります数値結果をさまざまな数値演算の関連付けの変更のため。 たとえば、シリアル加算削減には、並列リダクションと加算の関連付けのさまざまなパターンがあります。 これらの異なる関連付けでは、浮動小数点加算の結果を変更できます。

OpenMP C と C++ API で記述されたプログラムと呼ばれる実行の 1 つのスレッドとして実行を開始する、*マスター スレッド*します。 マスタ スレッドは、最初の parallel コンストラクトが出現するまでシリアル領域で実行します。 OpenMP C と C++ API で、`parallel`ディレクティブは、parallel コンストラクトを構成します。 Parallel コンストラクトが発生した場合に、マスター スレッドは、スレッドのチームを作成し、チームのマスターになります。 チーム内の各スレッドは、動的 work-sharing コンス トラクターを除く、並行領域の範囲でステートメントを実行します。 チームのすべてのスレッドが同じ順序での work-sharing コンス トラクターが発生する必要があり、1 つまたは複数のスレッドが、関連付けられている構造化ブロック内のステートメントを実行します。 せず work-sharing コンス トラクターの末尾に暗黙的に指定するバリア、`nowait`句は、チームのすべてのスレッドによって実行されます。

スレッドが共有されたオブジェクトを変更した場合、独自の実行環境だけでなく、プログラム内の他のスレッドのものに影響します。 変更が完了する、次のシーケンス ポイントで、別のスレッドの観点から (ベースの言語で定義) された揮発性のあるオブジェクトが宣言されている場合にのみ保証されます。 それ以外の場合、変更は、変更したスレッドの後に、完了する保証されます。 他のスレッドし (または同時に) を参照してください、 `flush` (暗黙的または明示的に) オブジェクトを指定するディレクティブ。 ときに、`flush`他 OpenMP ディレクティブによって暗黙的に指定されたディレクティブは副作用の正確な順序を保証しません、追加、明示的に指定するはプログラマの役目は`flush`ディレクティブ。

Parallel コンストラクトの完了したらで暗黙的なバリアでは、チーム内のスレッドを同期し、マスター スレッドのみが実行を継続します。 1 つのプログラムでは、parallel コンストラクトの任意の数を指定できます。 その結果、プログラムはフォークし、結合の実行中に何度も可能性があります。

OpenMP C と C++ API では、parallel コンストラクト内から呼び出された関数でディレクティブを使用するプログラマができるようにします。 ディレクティブを parallel コンストラクトの構文範囲内に表示されませんが、動的範囲内にある場合がありますが呼び出される*孤立した*ディレクティブ。 孤立したディレクティブは、プログラマは逐次プログラムに最小限の変更のみを並列で、プログラムの主要な部分を実行できます。 この機能により、プログラムのコール ツリーの最上位レベルにある parallel コンストラクトを作成し、ディレクティブを使用して、呼び出された関数のいずれかで実行を制御できます。

C および C++ に同期されていない呼び出しでは、出力を別のスレッドで書き込まれたデータが順不同で表示される可能性があります、同じファイルに書き込む関数を出力します。 同様に、同じファイルから読み取られた関数の入力に同期されていない呼び出しでは、非決定的な順序でデータを読み取ることができます。 各スレッドが別のファイルにアクセスするよう、I/O の非同期の使用 I/O 関数の逐次実行と同じ結果を生成します。

## <a name="14-compliance"></a>1.4 準拠

OpenMP C と C++ の API の実装は*OpenMP 準拠*は、付録 C A、B、D、E、および F とかどうかを認識し、章 1、2、3、4、レイアウトとは、この仕様は、のすべての要素のセマンティクスを保持情報は、のみを目的し、仕様の一部ではありません。 API のサブセットのみを含む実装は、OpenMP 準拠です。

OpenMP C および C++ API は、実装でサポートされているベース言語の拡張機能です。 ベースの言語をサポートしていない言語コンストラクトまたは表示される拡張機能をこのドキュメントの場合は、OpenMP の実装がサポートするように必要はありません。

すべての C および C++ の標準ライブラリ関数と組み込み関数 (つまり、コンパイラが特定のナレッジには、関数) スレッド セーフである必要があります。 同期されていない使用の並列領域内の別のスレッドでスレッド セーフな関数の未定義の動作は生成されません。 ただし、動作できない serial リージョンと同じです。 (ランダムな番号の生成関数は、例を示します)。

OpenMP C と C++ API では、特定の動作は、ことを指定します*実装で定義されます。* OpenMP に準拠した実装は、定義し、このような場合は、その動作を文書化する必要があります。 動作の実装定義の一覧は、次を参照してください。[付録 E](e-implementation-defined-behaviors-in-openmp-c-cpp.md)します。

## <a name="15-normative-references"></a>1.5 標準リファレンス

- ISO/IEC 9899:1999、*情報テクノロジのプログラミング言語の C*します。OpenMP API 仕様では、ISO/IEC 9899:1999 を C99 と呼びます。

- ISO/IEC 9899:1990、*情報テクノロジのプログラミング言語の C*します。OpenMP API 仕様では、ISO/IEC 9899:1990 を C90 と呼びます。

- ISO/IEC 14882:1998、*情報テクノロジのプログラミング言語の C++* します。 ISO/IEC 14882:1998 は、この OpenMP API 仕様では C++ と呼びます。

OpenMP API 仕様は、C を参照している場合は、基本実装でサポートされている言語に参照が行われます。

## <a name="16-organization"></a>1.6 階層

- [ランタイム ライブラリ関数](3-run-time-library-functions.md)
- [環境変数](4-environment-variables.md)
- [OpenMP C/C の実装で定義された動作](e-implementation-defined-behaviors-in-openmp-c-cpp.md)
- [OpenMP C と C++ のバージョン 2.0 の新機能](f-new-features-and-clarifications-in-version-2-0.md)
