---
title: アップグレード時の潜在的な問題の概要 (Visual C++)
ms.date: 05/03/2019
ms.assetid: 2c99a8cb-098f-4a9d-bf2c-b80fd06ace43
ms.openlocfilehash: 2b310760b1a6623a18a00e36e3bd5378d2ebb76e
ms.sourcegitcommit: 0cfc43f90a6cc8b97b24c42efcf5fb9c18762a42
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/05/2019
ms.locfileid: "73627240"
---
# <a name="overview-of-potential-upgrade-issues-visual-c"></a>アップグレード時の潜在的な問題の概要 (Visual C++)

長年にわたり、Microsoft C++ コンパイラでは、C++ 言語自体、C++ 標準ライブラリ、C ランタイム (CRT)、その他のライブラリ (MFC や ATL など) における変更と併せて、多くの変更が行われてきました。 その結果、Visual Studio の以前のバージョンからアプリケーションをアップグレードした場合、以前は正常にコンパイルされていたコードにおいてコンパイラおよびリンカーに関するエラーや警告が発生する場合があります。 元のコード ベースが古いほど、このようなエラーが発生する可能性は高くなります。 この記事では、発生する可能性が高い問題を最も一般的な方法で分類して概説するとともに、詳細情報へのリンクも示します。

> [!NOTE]
> 以前は、アップグレードが Visual Studio の複数のバージョンにまたがる場合には、一度に 1 つずつ段階的にバージョンをアップグレードすることをお勧めしていました。 しかし、現在、この方法はお勧めしていません。 コード ベースを使用している期間に関係なく、ほとんどの場合は Visual Studio の最新バージョンへアップグレードする方がより簡単であることがわかっています。

アップグレード プロセスに関する質問またはコメントについては、vcupgrade@microsoft.com にお送りください。

## <a name="library-and-toolset-dependencies"></a>ライブラリとツールセットの依存関係

> [!NOTE]
> このセクションは、Visual Studio 2013 以前を使ってビルドされたアプリケーションとライブラリに適用されます。 Visual Studio 2015、Visual Studio 2017、Visual Studio 2019 で使用されるツールセットには、バイナリ互換性があります。 詳細については、「[Visual Studio 2015 と Visual Studio 2019 の間の C++ バイナリ互換性](binary-compat-2015-2017.md)」を参照してください。

アプリケーションを Visual Studio コンパイラの新しいバージョンにアップグレードする場合は、アプリケーションがリンクしているすべてのライブラリおよび DLL もアップグレードすることをお勧めします。多くの場合は、この作業が必要となります。 そのためには、ソース コードへのアクセス権を持っているか、あるいは、ライブラリ ベンダーから、同じメジャー バージョンのコンパイラでコンパイルされた新しいバイナリ ファイルが提供されている必要があります。 この条件のいずれかを満たしている場合、バイナリの互換性について説明するこのセクションをスキップすることができます。 どちらにも当てはまらない場合は、アップグレードされたアプリケーションでライブラリを使用できない可能性があります。 このセクションの情報を参照することで、アップグレードを続行することができるかどうかを判断することができます。

### <a name="toolset"></a>ツールセット

.obj および .lib ファイル形式は、適切に定義されており、変わることはほとんどありません。 時々これらのファイル形式には追加が行われる場合がありますが、この追加は一般には、より新しいツールセットが以前のツールセットによって生成されたオブジェクト ファイルやライブラリを利用する機能に影響はありません。 ここでの重要な例外として、[/GL (プログラム全体の最適化)](../build/reference/gl-whole-program-optimization.md) を使用してコンパイルする場合が挙げられます。 `/GL` を使用してコンパイルした場合、その結果として生成されたオブジェクト ファイルをリンクするには、そのファイルの生成に使用したツールセットと同じものしか使用できません。 よって、`/GL` および Visual Studio 2017 (v141) コンパイラを使用してオブジェクト ファイルを生成する場合、生成されたファイルは Visual Studio 2017 (v141) リンカーを使用してリンクする必要があります。 このことは、オブジェクト ファイルの内部データ構造がツールセットのメジャー バージョン全般に安定性がなく、より新しいツールセットが以前のデータ形式を認識できないことに原因があります。

C++ のアプリケーション バイナリ インターフェイス (ABI) は安定性がありません。 しかし、Visual Studio では、リリースのすべてのマイナー バージョンについては安定した C++ ABI を維持しています。 Visual Studio 2015 (v140)、Visual Studio 2017 (v141)、Visual Studio 2019 (v142) は、マイナー バージョンでのみ異なります。 これらはすべて、同じメジャー バージョン 14 です。 詳細については、「[Visual Studio 2015 と Visual Studio 2019 の間の C++ バイナリ互換性](binary-compat-2015-2017.md)」を参照してください。

C++ リンケージを使用した外部シンボルがオブジェクト ファイルに含まれている場合、そのオブジェクト ファイルは、ツールセットの異なるメジャー バージョンで生成されたオブジェクト ファイルと正しくリンクできないことがあります。 さまざまな結果が考えられ、リンクが完全に失敗する可能性があります (たとえば、名前の装飾が変更された場合)。 リンクが成功し、実行時に動作がうまくいかない可能性があります (たとえば、型のレイアウトが変更された場合)。 または、多くの場合、偶然うまく動作して、問題なく処理される可能性があります。 また、C++ ABI は安定していなくても、C ABI および COM に必須の C++ ABI のサブセットは安定していることに注意してください。

インポート ライブラリにリンクすると、ABI との互換性を保持する、Visual Studio の再頒布可能ライブラリの新しいバージョンを実行時に使用することができます。 たとえば、ご利用のアプリが Visual Studio 2015 Update 3 ツールセットを使用してコンパイルされ、リンクされている場合、すべての Visual Studio 2017 または Visual Studio 2019 再頒布可能パッケージを使用することができます。これは、2015、2017、2019 のライブラリでバイナリの下位互換性が保持されているためです。 逆は当てはまりません。互換性のある ABI がある場合でも、コードのビルドに使用したものとは異なり、以前のバージョンのツールセットの再頒布可能パッケージを使用することはできません。

### <a name="libraries"></a>ライブラリ

特定のバージョンの Visual Studio C++ ライブラリ ヘッダー ファイルを使用してソース ファイルをコンパイルする場合 (ヘッダーを #including して)、結果として生成されるオブジェクト ファイルは、同じバージョンのライブラリとリンクする必要があります。 たとえば、Visual Studio 2017 2015 Update 3 \<immintrin.h> を使用してソース ファイルをコンパイルした場合は、Visual Studio 2015 Update 3 vcruntime ライブラリとリンクする必要があります。 同様に、Visual Studio 2017 バージョン 15.5 \<iostream> を使用してソース ファイルをコンパイルした場合は、Visual Studio 2017 バージョン 15.5 標準 C++ ライブラリである msvcprt とリンクする必要があります。 mixing-and-matching は、サポートされていません。

C++ 標準ライブラリについては、Visual Studio 2010 以降、標準ヘッダーに `#pragma detect_mismatch` を使用したことにより、mixing-and-matching は明示的に禁止されています。 互換性のないオブジェクト ファイルとのリンクを試みた場合、または誤った標準ライブラリとのリンクを試みた場合、リンクは失敗します。

CRT については、mixing-and-matching はサポートされていませんでしたが、少なくとも Visual Studio 2015 および Universal CRT までは、多くの場合、問題なく動作していました。これは、長い期間、API サーフェイスにあまり変更がなかったことによります。 Universal CRT では下位互換性の問題が解決され、将来的に下位互換性を維持できるようになりました。 すなわち、今後、バージョン管理の対象となる Universal CRT バイナリを新たに導入する計画はありません。 その代わり、既存の Universal CRT を適切に更新できるようになりました。

以前のバージョンの Microsoft C ランタイム ヘッダーでコンパイルされたオブジェクト ファイル (およびライブラリ) との部分的なリンク互換性を提供するために、弊社では Visual Studio 2015 以降のバージョンにライブラリ legacy_stdio_definitions.lib を提供しています。 このライブラリは、Universal CRT から削除された関数とデータ エクスポートの大部分に対して互換性シンボルを提供します。 legacy_stdio_definitions.lib によって提供される一連の互換性シンボルは、Windows SDK に含まれるライブラリ内のすべての依存関係を含む、ほとんどの依存関係を十分に満たしています。 ただし、Universal CRT から一部のシンボルは削除されています。それらについては、互換性シンボルを提供することはできません。 これらのシンボルには、いくつかの関数 (例: \_\_iob\_func) とデータ エクスポート (例: \_\_imp\_\_\_iob、\_\_imp\_\_\_pctype、\_\_imp\_\_\_mb\_cur\_max) が含まれています。

以前のバージョンの C ランタイム ヘッダーでビルドされたスタティック ライブラリがある場合は、以下の順番で次の処理をお勧めします。

1. 新しいバージョンの Visual Studio および Universal CRT のヘッダーを使用してスタティック ライブラリをリビルドして、Universal CRT とのリンクをサポートします。 この手法は、完全にサポートされた (最適な) オプションです。

1. スタティック ライブラリをリビルドできない場合 (またはリビルドしたくない場合)、legacy\_stdio\_definitions.lib とのリンクを試みることができます。 それがスタティック ライブラリのリンク時の依存関係を満たしている場合は、スタティック ライブラリをバイナリ内で使用しながら十分にテストすることにより、スタティック ライブラリが [Universal CRT に加えられた動作関係の変更](visual-cpp-change-history-2003-2015.md#BK_CRT)のいずれからも悪影響を受けていないことを確認します。

1. legacy\_stdio\_definitions.lib がスタティック ライブラリの依存関係を満たしていない場合、または前述した動作関係の変更によりライブラリが Universal CRT で動作しない場合は、Microsoft C ランタイムの正しいバージョンとリンクする DLL にスタティック ライブラリをカプセル化することをお勧めします。 たとえば、Visual Studio 2013 を使用してスタティック ライブラリがビルドされているならば、Visual Studio 2013 および Visual Studio 2013 C++ ライブラリを使用してこの DLL もビルドします。 DLL を生成してライブラリに取り込むことにより、特定のバージョンの Microsoft C ランタイムに対する依存関係を示す実装の詳細をカプセル化します DLL インターフェイスで、それがどの C ランタイムを使用しているかという詳細が漏れないように注意する必要があります。たとえば、DLL 境界を超えて FILE* を返したり、malloc で割り当てられたポインターを返して呼び出し元にそれを解放するよう求めたりすることにより、発生します。

単一のプロセスで複数の CRT を使用することは、それ自体問題ではありません (実際に、ほとんどのプロセスでは最終的に複数の CRT DLL を読み込みます。たとえば、Windows オペレーティング システムのコンポーネントは msvcrt.dll に依存し、CLR は独自のプライベート CRT に依存します)。 さまざまな CRT からの状態を混ぜると、問題が発生します。 たとえば、msvcr110.dll!malloc でメモリを割り当ててから、msvcr120.dll!free でそのメモリの割り当て解除を試みたり、msvcr110!fopen で FILE を開いてから、msvcr120!fread でその FILE からの読み取りを試みたりしないでください。 さまざまな CRT からの状態を混ぜ合わせない限り、1 つのプロセスで複数の CRT を安全に読み込むことができます。

詳細については、「[Upgrade your code to the Universal CRT](upgrade-your-code-to-the-universal-crt.md)」 (コードを Universal CRT にアップグレードする) を参照してください。

## <a name="errors-due-to-project-settings"></a>プロジェクトの設定に起因するエラー

アップグレード プロセスを開始するには、Visual Studio の最新バージョンで以前のプロジェクト/ソリューション/ワークスペースを開きます。 Visual Studio は、以前のプロジェクトの設定に基づいて新しいプロジェクトを作成します。 以前のプロジェクトに、ライブラリが存在するか、または非標準的な場所にハードコーディングされたパスが含まれる場合、それらのパス内のファイルは、プロジェクトで既定の設定が使用されていると、コンパイラに表示されない可能性があります。 詳細については、「[Linker OutputFile setting](porting-guide-spy-increment.md#linker_output_settings)」 (リンカーの OutputFile の設定) を参照してください。

全般的に見て、プロジェクト コードを適切に整理することにより、プロジェクトの保守を容易にすると共にアップグレードされたコードを可能な限りすばやくコンパイルできるようにするには今が絶好の機会です。 ソース コードがすでに適切に整理されていて、以前のプロジェクトが Visual Studio 2010 以降でコンパイルされている場合は、新旧両方のコンパイラでのコンパイルをサポートするように新しいプロジェクト ファイルを手動で編集することができます。 次の例では、Visual Studio 2015 および Visual Studio 2017 の場合のコンパイル方法を示します。

```xml
<PlatformToolset Condition="'$(VisualStudioVersion)'=='14.0'">v140</PlatformToolset>
<PlatformToolset Condition="'$(VisualStudioVersion)'=='15.0'">v141</PlatformToolset>
```

### <a name="lnk2019-unresolved-external"></a>LNK2019: 未解決の外部シンボル

未解決のシンボルの場合、プロジェクト設定の修正が必要なことがあります。

- ソース ファイルが既定以外の場所にある場合に、プロジェクトの include ディレクトリへのパスを追加しましたか?

- .lib ファイル内に外部が定義されている場合、プロジェクト プロパティ内に lib パスを指定していますか? また、そこには .lib ファイルの正しいバージョンが置かれていますか?

- 異なるバージョンの Visual Studio でコンパイルされた .lib ファイルへのリンクを試みていますか? 試みている場合は、ライブラリとツールセットの依存関係に関する前のセクションを参照してください。

- 呼び出しサイトにおける引数の型は、関数の既存のオーバー ロードと実際に一致していますか? 関数のシグネチャ内で、および関数を呼び出すコード内で typedef の基になる型が、予期していたものと一致しているかどうかを確認します。

未解決シンボル エラーのトラブルシューティングを実行するには、dumpbin.exe を使用して、バイナリで定義されているシンボルを調べることができます。 次のコマンド ラインを試行して、ライブラリで定義されているシンボルを表示してください。

```cmd
dumpbin.exe /LINKERMEMBER somelibrary.lib
```

### <a name="zcwchar_t-wchar_t-is-native-type"></a>/Zc:wchar_t (wchar_t をネイティブ型として認識)

(Microsoft Visual C++ 6.0 以前では、 **wchar_t**は組み込み型として実装されていませんが、unsigned short の typedef として wchar で宣言されていました)。標準C++では、 **wchar_t**が組み込み型である必要があります。 typedef バージョンを使用すると、移植性の問題が発生することがあります。 以前のバージョンの Visual Studio からアップグレードしているとき、コードが **wchar_t** を符号なし **short** に暗黙的に変換しようとしたために C2664 コンパイル エラーが発生した場合は、`/Zc:wchar_t-` を設定するのではなく、コードを変更してエラーを修正することをお勧めします。 「[/Zc:wchar_t (wchar_t をネイティブ型として認識)](../build/reference/zc-wchar-t-wchar-t-is-native-type.md)」を参照してください。

### <a name="upgrading-with-the-linker-options-nodefaultlib-entry-and-noentry"></a>リンカー オプション /NODEFAULTLIB、/ENTRY、および /NOENTRY を使用したアップグレード

`/NODEFAULTLIB` リンカー オプション (または [すべての既定のライブラリの無視] リンカー プロパティ) は、CRT などの既定のライブラリ内で自動的にリンクしないようにリンカーに指示します。 これは、各ライブラリが、入力として個別にリストされる必要があることを意味します。 このライブラリ リストは、 **[プロジェクトのプロパティ]** ダイアログの **[リンカー]** セクションにある **[追加の依存関係]** プロパティに指定されます。

このオプションを使用しているプロジェクトでは、アップグレード時に問題が発生します。これは、既定のいくつかのライブラリでコンテンツのリファクタリングが行われていることが原因です。 各ライブラリは **[追加の依存関係]** プロパティ内またはリンカーのコマンドラインに一覧表示される必要があるため、すべての現在の名前が使用されるようにライブラリのリストを更新する必要があります。

次の表に、Visual Studio 2015 以降、コンテンツが変更されたライブラリを示します。 アップグレードするには、2 番目の列内の新しいライブラリの名前を、1 番目の列内のライブライに追加する必要があります。 これらのライブラリの一部はインポート ライブラリですが、そのことは重要ではありません。

|||
|-|-|
|次を使用していた場合|次のライブラリを使用する必要があります|
|LIBCMT.lib|libcmt.lib、libucrt.lib、libvcruntime.lib|
|libcmtd.lib|libcmtd.lib、libucrtd.lib、libvcruntimed.lib|
|msvcrt.lib|msvcrt.lib、ucrt.lib、vcruntime.lib|
|msvcrtd.lib|msvcrtd.lib、ucrtd.lib、vcruntimed.lib|

また、`/ENTRY` オプションあるいは `/NOENTRY` オプションを使用する場合 (これらには既定のライブラリをバイパスする効果もある)、同じ問題が発生します。

## <a name="errors-due-to-improved-language-conformance"></a>言語の適合性強化に起因するエラー

Microsoft C++ コンパイラは、長年にわたり、C++ 標準への適合性を強化し続けててきました。 以前のバージョンでコンパイルされたコードは、新しいバージョンの Visual Studio でコンパイルできない場合があります。これは、以前は無視または明示的に許容されていたエラーに適切にフラグが付けられるようになったことによります。

たとえば、`/Zc:forScope` スイッチは、MSVC の歴史の早い段階で導入されました。 このスイッチでは、ループ変数に対する非準拠の動作が許可されます。 このスイッチは非推奨となりました。将来のバージョンでは削除される可能性があります。 コードをアップグレードする際は、このスイッチを使用しないことを強く推奨します。 詳細については、「[/Zc:forScope- is deprecated](porting-guide-spy-increment.md#deprecated_forscope)」 (/Zc:forScope- は使用しないでください) を参照してください。

アップグレード時によく発生するコンパイラ エラーの例として、非 const 引数が const パラメーターに渡された場合に発生するエラーが挙げられます。 コンパイラの以前のバージョンでは、これに対して常にエラーのフラグが付けられるわけではありませんでした。 詳細については、「[コンパイラのより厳密な変換](porting-guide-spy-increment.md#stricter_conversions)」を参照してください。

特定の適合性強化の詳細については、[Visual C++ change history 2003 - 2015](visual-cpp-change-history-2003-2015.md) (Visual C++ 2003 から 2015 での互換性に影響する変更点) および「[C++ conformance improvements in Visual Studio](../overview/cpp-conformance-improvements.md)」 (Visual Studio での C++ 適合性強化) を参照してください。

## <a name="errors-involving-stdinth-integral-types"></a>\<stdint.h> 整数型に関連するエラー

\<stdint.h> ヘッダーでは、組み込みの整数型とは異なり、すべてのプラットフォームで指定の長さを保持することが保証される typedef および macro を定義します。 `uint32_t` と `int64_t` は、その例です。 \<stdint.h > ヘッダーは、Visual Studio 2010 で追加されました。 2010 より前に記述されたコードは、型に関するプライベート定義を備えている場合がありますが、それらの定義は \<stdint.h> 定義と常に整合するとは限りません。

エラー C2371 が発生し、`stdint` 型が関係している場合、その多くは、コード内またはサードパーティ製の lib ファイル内のヘッダー内でその型が定義されていることを意味します。 アップグレード時には、\<stdint.h> のカスタム定義を削除する必要がありますが、最初に、カスタム定義を現在の標準的な定義と比較して、新たな問題を招かないことを確認してください。

**F12** キー (**定義へ移動**) を押すと、問題の型が定義されている場所を確認できます。

ここでは、[/showIncludes](../build/reference/showincludes-list-include-files.md) コンパイラ オプションが役に立ちます。 プロジェクトの **[プロパティ ページ]** ダイアログ ボックスで、 **[C/C++]**  >  **[詳細設定]** ページの順に開き、 **[インクルード ファイルの表示]** を **[はい]** に設定します。 次にプロジェクトをリビルドし、出力ウィンドウで `#include` の一覧を確認します。 各ヘッダーは、それぞれが含まれているヘッダーの下にインデントされます。

## <a name="errors-involving-crt-functions"></a>CRT の関数に関係するエラー

C ランタイムには、長年にわたり、多くの変更が加えられてきました。 セキュリティで保護された関数のバージョンが多数追加された一方で、削除された関数もありました。 また、この記事で前述したように、Microsoft のRT 実装は、Visual Studio 2015 で新しいバイナリと関連する .lib ファイルにリファクタリングされました。

エラーが CRT 関数に関係している場合は、記事に追加情報が含まれるかどうか、「[Visual C++ 2003 から 2015 の変更履歴](visual-cpp-change-history-2003-2015.md)」または [Visual Studio での C++ 準拠の改善](../overview/cpp-conformance-improvements.md)に関するページを検索してください。 エラーが LNK2019 (未解決の外部シンボル) である場合は、関数が削除されていないことを確認してください。 関数がまだ存在し、呼び出し元のコードも正しい場合は、プロジェクトで `/NODEFAULTLIB` が使用されているかどうかを確認します。 その場合は、プロジェクトで新しいユニバーサル (UCRT) ライブラリを使用するように、ライブラリのリストを更新する必要があります。 詳細については、ライブラリと依存関係に関する上記セクションを参照してください。

エラーが `printf` または `scanf` 関数に関係している場合は、いずれの関数も stdio.h なしで非公開に定義されているのではないか確認してください。 そのように定義されている場合は、プライベート定義を削除するか、または legacy\_stdio\_definitions.lib へのリンクを削除します。 **[プロパティ ページ]** ダイアログの **[追加の依存関係]** プロパティで **[構成プロパティ]**  >  **[リンカー]**  >  **[入力]** の順に選択して、このライブラリを設定することができます。 Windows SDK 8.1 以前のバージョンとリンクする場合は、legacy\_stdio\_definitions.lib を追加します。

エラーが書式文字列の引数に関係している場合は、おそらく、コンパイラが標準の適用により厳格であることが原因です。 詳細については、変更履歴を参照してください。 ここでのエラーは、セキュリティ上のリスクを招く可能性があるので、十分に注意してください。

## <a name="errors-due-to-changes-in-the-c-standard"></a>C++ 標準での変更によるエラー

C++ 標準自体、進化の過程で常に下位互換性が保たれていたわけではありませんでした。 C++11 での移動セマンティクス、新しいキーワード、および言語および標準ライブラリに関するその他の機能の導入は、コンパイラのエラーや異なるランタイム動作を引き起こす可能性があります。

たとえば、以前の C++ プログラムには、iostream.h ヘッダーが含まれている場合があります。 このヘッダーは、C++ の歴史の早い段階で非推奨となり、最終的には Visual Studio から完全に削除されました。 前述の状況に該当する場合は、\<iostream> を使用してコードを書き直す必要があります。 詳細については、「[古い iostreams コードを更新する](porting-guide-spy-increment.md#updating_iostreams_code)」を参照してください。

### <a name="c4838-narrowing-conversion-warning"></a>C4838: 縮小変換に関する警告

C++ 標準では、符号なし整数値から符号付き整数値への変換を縮小変換と見なすように指定することになりました。 Visual Studio 2015 より前のコンパイラでは、この警告が通知されませんでした。 発生した内容をそれぞれ調べて、コードの正確性に影響がないことを確認します。

## <a name="warnings-to-use-secure-crt-functions"></a>セキュリティで保護された CRT 関数を使用するように助言する警告

時間をかけて、C ランタイム関数のセキュリティで保護されたバージョンが導入されてきました。 セキュリティ保護されていない古いバージョンは引き続き使用できますが、セキュリティで保護されたバージョンを使用するようにコードを変更することをお勧めします。 セキュリティで保護されていないバージョンが使用されている場合は、コンパイラが警告を発行するようになります。 これらの警告は、無効にすることも無視することもできます。 ソリューション内のすべてのプロジェクトに対して警告を無効にするには、 **[表示]**  >  **[プロパティ マネージャー]** の順に開き、警告を無効にするすべてのプロジェクトを選択し、選択した項目を右クリックして、 **[プロパティ]** を選択します。 **[プロパティ ページ]** ダイアログで **[構成プロパティ]**  >  **[C/C++]**  >  **[詳細]** の順に選択し、 **[指定の警告を無効にする]** を選択します。 ドロップダウン矢印をクリックし、 **[編集]** をクリックします。 テキスト ボックスに「4996」と入力します (' C ' プレフィックスは含めないでください)。詳細については、「[セキュリティで保護された CRT を使用するための移植](porting-guide-spy-increment.md#porting_to_secure_crt)」を参照してください。

## <a name="errors-due-to-changes-in-windows-apis-or-obsolete-sdks"></a>Windows API または古い SDK での変更に起因するエラー

長年にわたり、Windows API とデータ型が追加されてきました。これらは変更されたり削除されたりすることもありました。 また、他にも、コア オペレーティング システムに付属していない SDK の中には登場しては消えていったものがあります。 そのため、古いプログラムには、もはや存在しない API の呼び出しが含まれている場合があります。 また、サポート対象外となった他の Microsoft SDK の API への呼び出しが含まれていることもあります。 Windows API または以前の Microsoft SDK の API に関連するエラーが表示される場合、API が削除されているか、より新しくセキュリティが強化された関数に置き換えられている可能性があります。

現行の API セットについて、および特定の Windows API で最低限サポートされるオペレーティング システムについては、「[Microsoft API とリファレンスのカタログ](https://msdn.microsoft.com/library)」を参照し、該当する API に移動してください。

### <a name="windows-version"></a>Windows のバージョン

Windows API を直接または間接的に使用するプログラムをアップグレードする場合は、サポートする最低限の Windows バージョンを判断する必要があります。 ほとんどの場合は、Windows 7 が適切な選択となります。 詳細については、[ヘッダー ファイルの問題](porting-guide-spy-increment.md#header_file_problems)に関するページを参照してください。 `WINVER` マクロでは、プログラムを実行できる最も古い Windows バージョンが定義されます。 MFC プログラムで WINVER が 0x0501 (Windows XP) に設定されている場合、警告が表示されます。これは、コンパイラ自体は XP モードを備えているにもかかわらず、MFC で XP がサポートされなくなったことに原因があります。

詳細については、「[ターゲットの Windows バージョンを更新する](porting-guide-spy-increment.md#updating_winver)」および「[その他の期限切れのヘッダー ファイル](porting-guide-spy-increment.md#outdated_header_files)」を参照してください。

## <a name="atl--mfc"></a>ATL/MFC

ATL および MFC は比較的安定した API ですが、変更が行われる場合があります。 詳細については、「[Visual C++ 2003 から 2015 の変更履歴](visual-cpp-change-history-2003-2015.md)」、[Visual Studio での Visual C++ の新機能](../overview/what-s-new-for-visual-cpp-in-visual-studio.md)に関するページ、[Visual Studio の C++ 準拠の強化](../overview/cpp-conformance-improvements.md)に関するページを参照してください。

### <a name="lnk-2005-_dllmain12-already-defined-in-msvcrtdlib"></a>MSVCRTD.lib で定義済みの LNK 2005 _DllMain@12

このエラーは MFC アプリケーションで発生することがあります。 CRT ライブラリと MFC ライブラリの間での順序付けの問題を示します。 最初に MFC をリンクして、new および delete 演算子が提供されるようにする必要があります。 エラーを修復するには、`/NODEFAULTLIB` スイッチを使用して、既定のライブラリ MSVCRTD.lib と mfcs140d.lib を無視します。 次に、これらの lib を追加の依存関係として追加します。

## <a name="32-vs-64-bit"></a>32 ビットと 64 ビット

元のコードを 32 ビット システム用にコンパイルする場合は、新しい 32 ビット アプリの代わりに、または新しい 32 ビット アプリに加えて、64 ビット バージョンを作成することができます。 一般には、まずプログラムを 32 ビット モードでコンパイルしてから、64 ビット モードでのコンパイルを試みてください。 64 ビットのコンパイルは単純ですが、場合によって、32 ビットのビルドで隠れていたバグが明らかになることがあります。

また、ポインターのサイズ、時間、およびサイズ値、さらに printf 関数と scanf 関数での書式指定子に関連して発生する可能性のあるコンパイル時およびランタイムの問題にも注意する必要があります。 詳細については、「[64 ビット、x64 ターゲット用の Visual C++ の構成](../build/configuring-programs-for-64-bit-visual-cpp.md)」と「[Visual C++ の 64 ビットへの移行に関する一般的な問題](../build/common-visual-cpp-64-bit-migration-issues.md)」を参照してください。 移行に関する追加のヒントは、「[64 ビット Windows プログラミング ガイド](/windows/win32/WinProg64/programming-guide-for-64-bit-windows)」を参照してください。

## <a name="unicode-vs-mbcsascii"></a>Unicode と MBCS/ASCII

Unicode が標準化される前、多くのプログラムでは、ASCII 文字セットに含まれていない文字を表現するためにマルチバイト文字セット (MBCS) が使用されていました。 古い MFC プロジェクトでは MBCS が既定の設定となっていました。しかし、そのようなプログラムをアップグレードすると、MBCS ではなく Unicode を使用するように助言する警告が表示されます。 Unicode への変換には開発コストをかけるだけの価値がないと判断した場合、警告は無効または無視してもかまいません。 ソリューション内のすべてのプロジェクトに対して警告を無効にするには、 **[表示]**  >  **[プロパティ マネージャー]** の順に開き、警告を無効にするすべてのプロジェクトを選択し、選択した項目を右クリックして、 **[プロパティ]** を選択します。 **[プロパティ ページ]** ダイアログ ボックスで、 **[構成プロパティ]**  >  **[C/C++]**  >  **[詳細]** の順に選択します。 **[指定の警告を無効にする]** プロパティで、ドロップダウン矢印を開き、 **[編集]** を選択します。 テキスト ボックスに「4996」と入力します (' C ' プレフィックスは含めないでください)。[ **Ok]** を選択してプロパティを保存し、 **[ok]** を選択して変更を保存します。

詳細については、「[Porting from MBCS to Unicode](porting-guide-spy-increment.md#porting_to_unicode)」 (MBCS から Unicode に移植する) を参照してください。 MBCS と Unicode に関する一般的な情報については、「[ビジュアルC++でのテキストと文字列](../text/text-and-strings-in-visual-cpp.md)」および「[国際化](../c-runtime-library/internationalization.md)」を参照してください。

## <a name="see-also"></a>関連項目

[以前のバージョンのビジュアルからのプロジェクトのアップグレードC++](upgrading-projects-from-earlier-versions-of-visual-cpp.md)<br/>
[Visual Studio の C++ 準拠の強化](../overview/cpp-conformance-improvements.md)