---
title: CRT ライブラリの機能
ms.date: 08/20/2018
f1_keywords:
- c.runtime
helpviewer_keywords:
- MSVCR71.dll
- libraries [C++], multithreaded
- library files, run-time
- LIBCMT.lib
- LIBCP.lib
- LIBCPMT.lib
- run-time libraries, C
- CRT, release versions
- MSVCP71.dll
- LIBC.lib
- libraries [C++]
- libraries [C++], run-time
- linking [C++], libraries
ms.assetid: a889fd39-807d-48f2-807f-81492612463f
ms.openlocfilehash: b9a2691d492a277ffe0018b6e86b00cd245840ed
ms.sourcegitcommit: 72583d30170d6ef29ea5c6848dc00169f2c909aa
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/18/2019
ms.locfileid: "58767692"
---
# <a name="crt-library-features"></a>CRT ライブラリの機能

ここでは、C ランタイム ライブラリを構成するさまざまな .lib ファイル、および関連するコンパイラ オプションとプリプロセッサ ディレクティブについて説明します。

## <a name="c-run-time-libraries-crt"></a>C ランタイム ライブラリ (CRT)

C ランタイム ライブラリ (CRT) は、ISO C99 標準ライブラリが組み込まれている C++ 標準ライブラリの一部です。 この CRT を実装する Visual C++ ライブラリは、ネイティブ コードの開発と、ネイティブとマネージドの混在コードの開発をサポートします。 CRT のすべてのバージョンがマルチスレッド開発をサポートします。 ほとんどのライブラリが、ライブラリを直接コードにリンクする静的リンクと、コードで共通 DLL ファイルを使用できるようにする動的リンクの両方をサポートします。

Visual Studio 2015 より、CRT が新しいバイナリにリファクタリングされました。 ユニバーサル CRT (UCRT) には、標準の C99 CRT ライブラリからエクスポートされた関数とグローバルが含まれています。 UCRT は Windows コンポーネントであり、Windows 10 の一部として出荷されます。 UCRT 用のスタティック ライブラリ、DLL インポート ライブラリ、およびヘッダー ファイルが Windows 10 SDK に含まれています。 Visual C++ をインストールすると、Visual Studio セットアップによって、UCRT を使用するために必要な Windows 10 SDK のサブセットがインストールされます。 UCRT は、Visual Studio 2015 以降のバージョンでサポートされている Windows の任意のバージョンで使用できます。 Windows 10 以外のサポートされているバージョンの Windows では、vcredist を使用して再配布することができます。 詳細については、「 [Redistributing Visual C++ Files](../windows/redistributing-visual-cpp-files.md)」を参照してください。

次の表に、UCRT を実装するライブラリの一覧を示します。

|ライブラリ|関連付けられている DLL|特性|オプション|プリプロセッサ ディレクティブ|
|-------------|--------------------|---------------------|------------|-----------------------------|
|libucrt.lib|なし|UCRT をコードに静的にリンクします。|**/MT**|_MT|
|libucrtd.lib|なし|静的リンク用の UCRT のデバッグ バージョン。 再頒布可能パッケージではありません。|**/MTd**|_DEBUG、_MT|
|ucrt.lib|ucrtbase.dll|UCRT 用の DLL インポート ライブラリ。|**/MD**|_MT、_DLL|
|ucrtd.lib|ucrtbased.dll|UCRT のデバッグ バージョン用の DLL インポート ライブラリ。 再頒布可能パッケージではありません。|**/MDd**|_DEBUG、_MT、_DLL|

vcruntime ライブラリには、例外処理やデバッグ サポートなどの Visual C++ CRT 実装固有のコード、ランタイム チェックと型情報、実装の詳細、および特定の拡張ライブラリ関数が含まれています。 このライブラリは、使用されているコンパイラのバージョンによって異なります。

次の表に、vcruntime ライブラリを実装するライブラリの一覧を示します。

|ライブラリ|関連付けられている DLL|特性|オプション|プリプロセッサ ディレクティブ|
|-------------|--------------------|---------------------|------------|-----------------------------|
|libvcruntime.lib|なし|コードに静的にリンクされています。|**/MT**|_MT|
|libvcruntimed.lib|なし|静的リンク用のデバッグ バージョン。 再頒布可能パッケージではありません。|**/MTd**|_MT、_DEBUG|
|vcruntime.lib|vcruntime\<version>.dll|vcruntime 用の DLL インポート ライブラリ。|**/MD**|_MT、_DLL|
|vcruntimed.lib|vcruntime\<version>d.dll|デバッグ vcruntime 用の DLL インポート ライブラリ。 再頒布可能パッケージではありません。|**/MDd**|_DEBUG、_MT、_DLL|

> [!NOTE]
> UCRT リファクタリングが行われたとき、同時実行ランタイムは concrt140.dll に移動されました。これは C++ 再頒布可能パッケージに含まれています。 この DLL は、C++ の並列コンテナーおよびアルゴリズム (`concurrency::parallel_for` など) に必要となります。 さらに、C++ 標準ライブラリでは、同期プリミティブを支援するために、Windows XP でこの DLL を必要とします。Windows XP には条件変数がないためです。

CRT を初期化するコードは、CRT ライブラリが静的にリンクされているのか、動的にリンクされているのか、ネイティブ コードなのか、マネージド コードなのか、混合コードなのかによって、複数あるライブラリのいずれかに含まれています。 このコードは、CRT のスタートアップ、内部スレッド単位データ初期化、および強制終了を処理します。 使用されているコンパイラのバージョンによって異なります。 このライブラリは、動的にリンクされた UCRT が使用されている場合でも、常に静的にリンクされます。

次の表に、CRT の初期化と強制終了を実装するライブラリの一覧を示します。

|ライブラリ|特性|オプション|プリプロセッサ ディレクティブ|
|-------------|---------------------|------------|-----------------------------|
|LIBCMT.lib|ネイティブ CRT スタートアップをコードに静的にリンクします。|**/MT**|_MT|
|libcmtd.lib|ネイティブ CRT スタートアップのデバッグ バージョンを静的にリンクします。 再頒布可能パッケージではありません。|**/MTd**|_DEBUG、_MT|
|msvcrt.lib|DLL UCRT および vcruntime で使用するためのネイティブ CRT スタートアップ用のスタティック ライブラリ。|**/MD**|_MT、_DLL|
|msvcrtd.lib|DLL UCRT および vcruntime で使用するためのネイティブ CRT スタートアップのデバッグ バージョン用のスタティック ライブラリ。 再頒布可能パッケージではありません。|**/MDd**|_DEBUG、_MT、_DLL|
|msvcmrt.lib|DLL UCRT および vcruntime で使用するためのネイティブとマネージドの混合 CRT スタートアップ用のスタティック ライブラリ。|**/clr**||
|msvcmrtd.lib|DLL UCRT および vcruntime で使用するためのネイティブとマネージドの混合 CRT スタートアップのデバッグ バージョン用のスタティック ライブラリ。 再頒布可能パッケージではありません。|**/clr**||
|msvcurt.lib|**非推奨** 純粋マネージド CRT 用のスタティック ライブラリ。|**/clr:pure**||
|msvcurtd.lib|**非推奨** 純粋マネージド CRT のデバッグ バージョン用のスタティック ライブラリ。 再頒布可能パッケージではありません。|**/clr:pure**||

C ランタイム ライブラリを指定するコンパイラ オプションを使用せずにコマンド ラインからプログラムをリンクした場合、リンカーは静的にリンクされた CRT ライブラリ (libcmt.lib、libvcruntime.lib、libucrt.lib) を使用します。

静的にリンクされた CRT を使用すると、暗黙的に、C ランタイム ライブラリによって保存されるステータス情報は CRT のそのインスタンスに対してローカルなものになります。 たとえば、静的にリンクされた CRT を使用している状態で [strtok、_strtok_l、wcstok、_wcstok_l、_mbstok、_mbstok_l](../c-runtime-library/reference/strtok-strtok-l-wcstok-wcstok-l-mbstok-mbstok-l.md) を使用した場合、`strtok` パーサーの位置は、静的な CRT の別のインスタンスにリンクされた同じプロセス内 (ただし DLL または EXE は別) のコードで使用される `strtok` の状態とは無関係になります。 反対に、動的にリンクされた CRT では、CRT に動的にリンクされるプロセス内のすべてのコードに対して状態が共有されます。 この問題は、セキュリティが強化された新しいバージョンの関数では発生しません。たとえば、 `strtok_s` にはこの問題はありません。

静的な CRT とのリンクによってビルドされた DLL は独自の CRT 状態を持つので、この結果を明確に理解し、期待する場合を除き、DLL 内で CRT に静的にリンクすることは推奨されません。 たとえば、独自の静的な CRT にリンクする DLL を読み込む実行可能ファイルで [_set_se_translator](../c-runtime-library/reference/set-se-translator.md) を呼び出すと、このトランスレータは DLL 内のコードで生成されたハードウェア例外をキャッチしませんが、メインの実行可能ファイル内のコードによって生成されたハードウェア例外をキャッチします。

**/clr** コンパイラ スイッチを使用すると、コードはスタティック ライブラリ msvcmrt.lib とリンクされます。 このスタティック ライブラリは、マネージド コードとネイティブ CRT 間のプロキシを提供します。 **/MT** は、静的にリンクされる CRT ( **/MTd** オプションまたは **/clr**オプション) と一緒には使用できません。 代わりに、動的にリンクされるライブラリ (**/MD** または **/MDd**) を使用してください。 純粋マネージ CRT のライブラリは、Visual Studio 2015 で非推奨となり、Visual Studio 2017 ではサポートされていません。

**/clr** と共に CRT を使用する方法の詳細については、「[混在 (ネイティブおよびマネージド) アセンブリ](../dotnet/mixed-native-and-managed-assemblies.md)」を参照してください。

アプリケーションのデバッグ バージョンをビルドするには、[_DEBUG](../c-runtime-library/debug.md) フラグが定義され、アプリケーションが上の表のいずれかのライブラリのデバッグ バージョンとリンクされている必要があります。 ライブラリ ファイルのデバッグ バージョンの使い方の詳細については、「 [CRT のデバッグ技術](/visualstudio/debugger/crt-debugging-techniques)」を参照してください。

この CRT のバージョンは、C99 標準に完全には準拠していません。 具体的には、\<tgmath.h> ヘッダーと CX_LIMITED_RANGE/FP_CONTRACT プラグマ マクロがサポートされていません。 標準 IO 関数内のパラメーター指定子の意味などの特定の要素で、既定で、従来の解釈が使用されます。 /Zc コンパイラ準拠オプションを使用して、リンカー オプションを指定し、ライブラリ準拠の一部の側面を制御することができます。

## <a name="c-standard-library"></a>C++ 標準ライブラリ

|C++ 標準ライブラリ|特性|オプション|プリプロセッサ ディレクティブ|
|----------------------------|---------------------|------------|-----------------------------|
|libcpmt.lib|マルチスレッド、静的リンク|**/MT**|_MT|
|msvcprt.lib|マルチスレッド、動的リンク (MSVCP*version*.dll 用のインポート ライブラリ)|**/MD**|_MT、_DLL|
|libcpmtd.lib|マルチスレッド、静的リンク|**/MTd**|_DEBUG、_MT|
|msvcprtd.lib|マルチスレッド、動的リンク (MSVCP*version*D.DLL 用のインポート ライブラリ)|**/MDd**|_DEBUG、_MT、_DLL|

プロジェクトのリリース バージョンをビルドすると、既定では、選択したコンパイラ オプション (マルチスレッド、DLL、/clr) に応じて、基本 C ランタイム ライブラリ (libcmt.lib, msvcmrt.lib, msvcrt.lib) の 1 つがリンクされます。 コードに [C++ 標準ライブラリのヘッダー ファイル](../standard-library/cpp-standard-library-header-files.md)の 1 つがインクルードされている場合は、コンパイル時に Visual C++ によって自動的に C++ 標準ライブラリがリンクされます。 次に例を示します。

```cpp
#include <ios>
```

バイナリの互換性のため、複数の DLL ファイルが 1 つのインポート ライブラリによって指定される場合があります。 バージョンの更新によって、*ドット ライブラリ*が導入される場合があります。これは、新しいライブラリ機能が導入される別の DLL です。 たとえば、Visual Studio 2017 バージョン 15.6 では、msvcp140.dll でサポートされる ABI を分断することなく追加の標準ライブラリ機能をサポートする msvcp140_1.dll が導入されました。 Visual Studio 2017 バージョン 15.6 のツールセットに含まれる msvcprt.lib インポート ライブラリは両方の DLL をサポートし、このバージョンの vcredist は両方の DLL をインストールします。 出荷後は、ドット ライブラリに修正された ABI が含まれ、以後のドット ライブラリに対する依存関係はなくなります。

## <a name="what-problems-exist-if-an-application-uses-more-than-one-crt-version"></a>アプリケーションで複数の CRT バージョンを使用した場合に発生する問題

すべての実行可能イメージ (EXE または DLL) は、静的にリンクされた独自の CRT を持たせるか、動的に CRT にリンクさせることができます。 特定のイメージによって静的に含まれる、または動的に読み込まれる CRT のバージョンは、ビルド時に使用されたツールとライブラリのバージョンによって異なります。 1 つのプロセスが複数の EXE や DLL イメージを読み込み、そのそれぞれが独自の CRT を持っている場合があります。 これらの各 CRT は、異なる allocator を使用し、異なる内部構造体のレイアウトを備え、異なるストレージ配置を使用する可能性があります。 つまり、メモリの割り当て、CRT リソース、DLL の境界を越えて渡されるクラスによって、メモリ管理、内部の static の使用、レイアウトの解釈に問題が発生する場合があります。 たとえば、1 つの DLL に割り当てられているクラスが別の DLL に渡されて削除された場合、使用されるのはどの CRT の deallocator でしょうか。 発生するエラーは微妙なものから即座に致命的となるものまでさまざまです。そのため、そのようなリソースを直接転送することは、回避することを強くお勧めします。

代わりに、アプリケーション バイナリ インターフェイス (ABI) テクノロジを使用することで、この問題の多くを回避できます。安定しバージョン管理が可能であるように設計されるためです。 値によって情報を渡すか、ローカルで割り当てたメモリを呼び出し元に返すのではなく呼び出し元によって渡されたメモリを使用するように、DLL のエクスポート インターフェイスを設計します。 マーシャリングの手法を使用して、実行可能イメージ間で構造化されたデータをコピーします。 リソースをローカルでカプセル化し、クライアントに公開したハンドルまたは関数を通してのみこれを操作できるようにします。

また、プロセス内のすべてのイメージで同じバージョンの CRT が動的に読み込まれる場合は、これらの問題を一部回避することもできます。 すべてのコンポーネントで CRT の同じ DLL バージョンを使用するには、**/MD** オプションを指定してビルドし、同じコンパイラ ツールセットとプロパティ設定を使用します。

プログラムで DLL の境界を超えて特定の CRT リソース (ファイル ハンドル、ロケール、環境変数など) を渡す場合には、同じバージョンの CRT を使用する場合であっても、注意する必要があります。 発生する可能性のある問題とその対処法の詳細については、「[DLL の境界を越えて CRT オブジェクトを渡す場合に発生する可能性のあるエラー](../c-runtime-library/potential-errors-passing-crt-objects-across-dll-boundaries.md)」を参照してください。

## <a name="see-also"></a>関連項目

- [C ランタイム ライブラリ リファレンス](../c-runtime-library/c-run-time-library-reference.md)
