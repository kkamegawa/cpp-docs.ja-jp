---
title: 混在アセンブリの初期化
ms.date: 03/09/2018
helpviewer_keywords:
- mixed assemblies [C++], loader lock
- loader lock [C++]
- initializing mixed assemblies
- deadlocks [C++]
- .cctor [C++]
- custom locales [C++]
- mixed assemblies [C++], initilizing
ms.assetid: bfab7d9e-f323-4404-bcb8-712b15f831eb
ms.openlocfilehash: 1f4ea7f5cfc6e99390c93ba9c2beadc46fce8584
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2019
ms.locfileid: "62339040"
---
# <a name="initialization-of-mixed-assemblies"></a>混在アセンブリの初期化

中にコードを実行するときに、Windows 開発者のローダー ロックの必ず`DllMain`します。 ただし、C + を扱うときに影響するいくつか追加の考慮事項がある/cli clr 混合モードのアセンブリ。

[DllMain](/windows/desktop/Dlls/dllmain) 内のコードは、CLR にはアクセスできません。 つまり、 `DllMain` は、直接的にも間接的にもマネージ関数を呼び出すことができません。 `DllMain`ではマネージド コードを宣言または実装しないでください。また、 `DllMain`内では、ガベージ コレクションや自動ライブラリ読み込みは行われません。

## <a name="causes-of-loader-lock"></a>ローダー ロックの原因

.NET プラットフォームの導入に伴い、実行モジュール (EXE または DLL) を読み込むためのメカニズムが 2 つになりました。1 つは、Windows 向けで、アンマネージ モジュールに使用されます。もう 1 つは、.NET 共通言語ランタイム (CLR: Common Language Runtime) 向けで、.NET アセンブリを読み込みます。 混在モード DLL 読み込み時の問題は、Microsoft Windows OS ローダーを中心に発生します。

.NET のコンストラクトだけを含むアセンブリをプロセスに読み込んだ場合、CLR ローダーは、必要なすべての読み込みタスクおよび初期化タスクを自分で実行できます。 しかし、混在アセンブリの場合は、ネイティブ コードやデータが含まれている可能性があるため、Windows ローダーも使用する必要があります。

Windows ローダーは、DLL が初期化されるまで、その DLL 内のコードやデータにコードがアクセスできないようにします。また、DLL が一部しか初期化されていない間は、コードが DLL を重複して読み込むことができないようにします。 そのため、Windows ローダーでは、モジュールの初期化中に安全ではないアクセスを防止する、プロセス グローバルのクリティカル セクション (多くの場合 "ローダー ロック" と呼ばれています) が使用されます。 結果として、読み込みプロセスでは、典型的な多くのデッドロックのシナリオが発生しやすくなります。 混在アセンブリの場合、次の 2 つのシナリオで、デッドロックの危険性が高くなります。

- 最初のシナリオでは、 `DllMain` または静的初期化子などでローダー ロックが保持されている場合に、Microsoft Intermediate Language (MSIL) にコンパイルされた関数を実行しようとすると、デッドロックが発生します。 ここで、MSIL 関数が、読み込まれていないアセンブリ内の型を参照する場合を考えてみてください。 CLR は、そのアセンブリを自動的に読み込もうとします。これにより、Windows ローダーはローダー ロックをブロックすることが必要になる場合があります。 呼び出しシーケンスのより早い時点でコードが既にローダー ロックを保持しているため、デッドロックが発生します。 ただし、ローダー ロック中に MSIL を実行しても、必ずデッドロックが発生するわけではありません。そのために、このシナリオを診断して修復することが困難になります。 参照されている型の DLL にネイティブ コンストラクトが含まれておらず、そのすべての依存関係にネイティブ コンストラクトが含まれていない場合など、状況によっては、Windows ローダーは参照されている型の .NET アセンブリを読み込む必要がありません。 さらに、必要なアセンブリやその混在するネイティブまたは .NET の依存関係は、既に他のコードによって読み込まれている可能性があります。 その結果、デッドロックの発生を予測することが難しくなります。また、デッドロック状態が、対象となるコンピューターの構成によって異なる場合もあります。

- 2 番目のシナリオでは、.NET Framework Version 1.0 および 1.1 の DLL を読み込むときに、CLR はローダー ロックが保持されていないと想定し、ローダー ロックの状況下では無効な処理をいくつか実行しました。 ローダー ロックが保持されていないという想定は、純粋な .NET DLL に対しては妥当な想定ですが、混在モード DLL はネイティブな初期化ルーチンを実行するため、ネイティブな Windows ローダーが必要となり、その結果、ローダー ロックが発生します。 したがって、開発者が DLL の初期化中に MSIL 関数を実行しない場合でも、.NET Framework Version 1.0 および 1.1 では、デッドロックが確定的でない場合にデッドロックが発生する可能性がわずかに残っていました。

混在モード DLL の読み込みプロセスで、このような確定的でない場合の問題はなくなりました。 これは、以下の変更によって実現されました。

- CLR が、混在モード DLL の読み込み時に誤った想定を行わなくなりました。

- アンマネージド初期化とマネージド初期化が、2 つの独立した段階で実行されます。 最初にアンマネージド初期化が DllMain によって実行され、その後、.NET でサポートされている *.cctor*というコンストラクトによってマネージド初期化が実行されます。 後者は、 **/Zl** または **/NODEFAULTLIB** を使用している場合を除いて、ユーザーが意識する必要はありません。 詳細については、「[/NODEFAULTLIB (Ignore Libraries)](../build/reference/nodefaultlib-ignore-libraries.md) 」と「 [/Zl (Omit Default Library Name)](../build/reference/zl-omit-default-library-name.md) 」を参照してください。

ローダー ロックは依然として発生することがありますが、再現性があり、検出されるようになりました。 場合`DllMain`の MSIL 命令が含まれています。 コンパイラは警告を生成[コンパイラの警告 (レベル 1) C4747](../error-messages/compiler-warnings/compiler-warning-level-1-c4747.md)。 さらに、ローダー ロックの状況下で MSIL が実行されようとしている場合、CRT または CLR は検出とレポートを試みます。 CRT による検出の結果、実行時の診断として C ランタイム エラー R6033 が発生します。

このドキュメントの残りの部分では、MSIL がローダー ロックの状況で実行できる他のシナリオ、各シナリオでの問題に対する解決策、デバッグ技術について説明します。

## <a name="scenarios-and-workarounds"></a>シナリオと回避策

ローダー ロックが発生している場合でも、ユーザー コードが MSIL を実行できる状況がいくつかあります。 開発者は、そのような状況のそれぞれについて、ユーザー コードの実装が MSIL 命令を実行しないようにする必要があります。 以下では、最も一般的な事例で問題を解決する方法を考えつつ、すべての可能性について説明します。

### <a name="dllmain"></a>DllMain

`DllMain` 関数は、DLL 用のユーザー定義のエントリ ポイントです。 ユーザーがそれ以外の関数を指定しない限り、プロセスやスレッドを DLL にアタッチするか、プロセスやスレッドを DLL からデタッチするたびに、 `DllMain` が呼び出されます。 この呼び出しは、ローダー ロックが保持されているときに行われる可能性もあるため、ユーザー指定の `DllMain` 関数は MSIL にコンパイルしないでください。 さらに、コール ツリー内で `DllMain` をルートにしている関数も、MSIL にコンパイルできません。 この問題を解決するには、 `DllMain` が定義されているコード ブロックを、#pragma `unmanaged`で修飾する必要があります。 `DllMain` によって呼び出されるすべての関数にも、同じ処理を行う必要があります。

このような関数で、他の呼び出しコンテキスト用に MSIL 実装を必要とする関数を呼び出す必要がある場合には、同じ関数の .NET バージョンとネイティブ バージョンを重複して作成する方法を使用できます。

また、 `DllMain` が不要な場合またはローダー ロックの状況でこれを実行する必要がない場合は、ユーザー指定の `DllMain` の実装を削除できます。そうすることで、問題が発生しなくなります。

DllMain で直接 MSIL を実行しようとすると、 [Compiler Warning (level 1) C4747](../error-messages/compiler-warnings/compiler-warning-level-1-c4747.md) が発生します。 ただし、コンパイラは、DllMain が別のモジュール内の関数を呼び出し、その関数が MSIL を実行するような事例は検出できません。

このシナリオの詳細については、「診断に対する障害」を参照してください。

### <a name="initializing-static-objects"></a>静的オブジェクトの初期化

静的オブジェクトを初期化すると、動的初期化子が必要な場合にデッドロックが発生することがあります。 コンパイル時に認識される値に静的変数が割り当てられる場合など、単純な事例では動的な初期化が不要なため、デッドロックの危険性はありません。 ただし、関数呼び出し、コンストラクター呼び出し、またはコンパイル時に評価できない式によって初期化される静的変数は、モジュールの初期化中にコードを実行する必要があります。

動的な初期化を必要とする静的初期化子の例 (関数呼び出し、オブジェクト構築、およびポインター初期化) を次のコードに示します。 これらの例は静的ではありませんが、グローバル スコープで定義されることが想定されるため、同じ結果になります。

```cpp
// dynamic initializer function generated
int a = init();
CObject o(arg1, arg2);
CObject* op = new CObject(arg1, arg2);
```

このデッドロックの危険性は、該当モジュールが **/clr** を指定してコンパイルされているかどうかと MSIL が実行されるかどうかによって決まります。 具体的には、静的変数を **/clr** を指定せずにコンパイルする場合 (または静的変数が #pragma `unmanaged` ブロックに存在する場合) に、その変数の初期化に必要な動的初期化子によって MSIL 命令が実行されると、デッドロックが発生することがあります。 この原因は、 **/clr**を指定せずにコンパイルされたモジュールでは、DllMain によって静的変数の初期化が実行されることにあります。 これに対して、 **/clr** を指定してコンパイルされた静的変数は、アンマネージ初期化段階が完了してローダー ロックが解除された後に、.cctor によって初期化されます。

静的変数の動的な初期化が原因で発生するデッドロックに対する解決策は多数あります (問題解決にかかる時間が短い順に記載しています)。

- 静的変数を含むソース ファイルは、 **/clr**を指定してコンパイルします。

- 静的変数によって呼び出されるすべての関数は、#pragma `unmanaged` ディレクティブを使用してネイティブ コードにコンパイルします。

- 静的変数が依存するコードを手動で複製して、.NET バージョンとネイティブ バージョンを作成し、それぞれに異なる名前を指定します。 その後、開発者は、ネイティブな静的初期化子からネイティブ バージョンを呼び出し、それ以外の場所から .NET バージョンを呼び出します。

### <a name="user-supplied-functions-affecting-startup"></a>起動に影響を与える、ユーザーが指定した関数

起動時の初期化でライブラリが依存する、ユーザー指定の関数がいくつかあります。 たとえば、グローバルになど、C++ の演算子をオーバー ロードするとき、`new`と`delete`演算子、ユーザー指定のバージョンは C++ 標準ライブラリの初期化や破棄など、どこでも使用されます。 その結果、C++ 標準ライブラリとユーザー指定の静的初期化子はこれらの演算子の任意のユーザーが指定したバージョンを呼び出します。

ユーザー指定バージョンが MSIL にコンパイルされると、これらの初期化子は、ローダー ロックが保持されているときに MSIL 命令を実行しようとします。 ユーザーが指定した`malloc`同じ影響します。 この問題を解決するには、これらのオーバーロードまたはユーザー指定定義を、#pragma `unmanaged` ディレクティブを使用してネイティブ コードとして実装する必要があります。

このシナリオの詳細については、「診断に対する障害」を参照してください。

### <a name="custom-locales"></a>カスタム ロケール

ユーザーがグローバルなカスタム ロケールを指定すると、このロケールは、今後、すべての入出力ストリームの初期化に使用されます。静的に初期化されるストリームも対象になります。 このグローバルなロケール オブジェクトを MSIL にコンパイルすると、MSIL にコンパイルされたロケール オブジェクト メンバー関数が、ローダー ロックが保持されているときに呼び出されることがあります。

この問題を解決するためのオプションが 3 つあります。

グローバル入出力ストリームの定義をすべて含むソース ファイルを、 **/clr** オプションを使用してコンパイルします。 これにより、ローダー ロックの状態では静的初期化子が実行されなくなります。

カスタム ロケールの関数定義は、#pragma `unmanaged` ディレクティブを使用することによって、ネイティブ コードにコンパイルできます。

ローダー ロックが解除されるまで、カスタム ロケールをグローバル ロケールとして設定しないようにします。 その後、初期化中に作成された入出力ストリームをカスタム ロケールで明示的に構成します。

## <a name="impediments-to-diagnosis"></a>診断に対する障害

場合によっては、デッドロックの原因を検出することが困難になります。 以下では、そのようなシナリオとそれらの問題の解決策について説明します。

### <a name="implementation-in-headers"></a>ヘッダーでの実装

特殊なケースで、ヘッダー ファイル内に関数を実装すると、診断が困難になる場合があります。 インライン関数とテンプレート コードの両方で、その関数をヘッダー ファイルに指定する必要があります。  C++ 言語では、単一定義規則を指定します。単一定義規則を指定すると、同じ名前で実装されているすべての関数が、強制的に同じ意味にされます。 その結果、C++ リンカーでは、特定の関数を重複して実装しているオブジェクト ファイルをマージする際に特別に注意する必要がなくなります。

Visual Studio 2005 では、前に、リンカーは単に最大規模のさまざまなソース ファイルを異なる最適化オプションを使用する場合は、事前宣言およびシナリオを対応するためにこれらと同じ意味の定義は選択します。 これにより、ネイティブ DLL と .NET DLL が混在する問題が発生します。

同じヘッダーがあるのででの C++ ファイルの両方に **/clr**有効/無効、または #include #pragma 内にラップできます`unmanaged`ブロックすると、MSIL とネイティブ バージョンの提供する関数の両方があることができますヘッダーで実装します。 MSIL の実装とネイティブの実装は、ローダー ロックの状態での初期化については異なる意味を持ちます。これは、事実上、単一定義規則に違反しています。 その結果、リンカーが最大の実装を選択すると、他の場所で #pragma unmanaged ディレクティブを使用して明示的にネイティブ コードにコンパイルした場合でも、関数の MSIL バージョンが選択されます。 MSIL バージョンのテンプレートまたはインライン関数がローダー ロック中に呼び出されないようにするには、ローダー ロック中に呼び出されるこのような各関数のすべての定義を、#pragma `unmanaged` ディレクティブで修飾する必要があります。 サード パーティのヘッダー ファイルの場合、これを実現するための最も簡単な方法は、問題のヘッダー ファイルの #include ディレクティブの周囲で #pragma unmanaged ディレクティブをプッシュしてポップすることです。 (を参照してください[マネージ、アンマネージ](../preprocessor/managed-unmanaged.md)例についてはします)。ただし、この方法は、直接 .NET API を呼び出す必要のある他のコードを含むヘッダーには有効ではありません。

ローダー ロックを扱うユーザーの負担を減らすため、マネージドとネイティブの両方の実装が存在する場合、リンカーはネイティブの実装を選択するようになっています。 これにより、上記の問題は回避されます。 ただし、このリリースではコンパイラに未解決の問題が 2 つ残っているため、この規則には、次の 2 つの例外があります。

- グローバル静的関数ポインターを介したインライン関数呼び出しである場合。 仮想関数はグローバル関数ポインターを介して呼び出されるため、このシナリオには特に注意する必要があります。 例えば以下のようにします。

```cpp
#include "definesmyObject.h"
#include "definesclassC.h"

typedef void (*function_pointer_t)();

function_pointer_t myObject_p = &myObject;

#pragma unmanaged
void DuringLoaderlock(C & c)
{
    // Either of these calls could resolve to a managed implementation,
    // at link-time, even if a native implementation also exists.
    c.VirtualMember();
    myObject_p();
}
```

### <a name="diagnosing-in-debug-mode"></a>デバッグ モードでの診断

ローダー ロックに関する問題の診断はすべて、デバッグ ビルドで行う必要があります。 リリース ビルドは診断を生成しない場合があります。また、リリース モードで実行される最適化によって、ローダー ロックのシナリオで MSIL の一部が隠されることがあります。

## <a name="how-to-debug-loader-lock-issues"></a>ローダー ロックに関する問題をデバッグする方法

MSIL 関数が呼び出されたときに、CLR が生成する診断は、CLR の実行を中断します。 さらに、このことが原因で、デバッグ対象をインプロセスで実行している場合は Visual C++ の混合モード デバッガーも中断されます。 ただし、プロセスにアタッチした場合、混合デバッガーを使用してデバッグ対象のマネージド コールスタックを取得することはできません。

ローダー ロック中に呼び出された特定の MSIL 関数を識別するには、開発者が次の手順を実行する必要があります。

1. mscoree.dll と mscorwks.dll のシンボルを使用できるようにします。

   これは、次の 2 つの方法で行うことができます。 1 つ目の方法として、mscoree.dll と mscorwks.dll の PDB をシンボル検索パスに追加します。 そのためには、シンボル検索パスのオプションのダイアログ ボックスを開きます。 (から、**ツール**] メニューの [選択**オプション**します。 左側のウィンドウで、**オプション**ダイアログ ボックスで、**デバッグ**ノード選択**シンボル**)。mscoree.dll PDB ファイルと mscorwks.dll PDB ファイルのパスを検索一覧に追加します。 これらの PDB は、%VSINSTALLDIR%\SDK\v2.0\symbols にインストールされます。 **[OK]** をクリックします。

   2 つ目の方法として、mscoree.dll と mscorwks.dll の PDB を Microsoft Symbol Server からダウンロードします。 Symbol Server を構成するには、シンボル検索パスのオプションのダイアログ ボックスを開きます。 (から、**ツール**] メニューの [選択**オプション**します。 左側のウィンドウで、**オプション**ダイアログ ボックスで、**デバッグ**ノード選択**シンボル**)。次の検索パスを検索リストに追加: [http://msdl.microsoft.com/download/symbols](http://msdl.microsoft.com/download/symbols) します。 シンボルのキャッシュ ディレクトリをシンボル サーバーのキャッシュのテキスト ボックスに追加します。 **[OK]** をクリックします。

1. デバッガーのモードをネイティブのみに設定します。

   これを行うには、開く、**プロパティ**ソリューションのスタートアップ プロジェクトのグリッド。 選択**構成プロパティ** > **デバッグ**します。 設定、**デバッガーの種類**に**ネイティブのみ**します。

1. (F5 キーを押して) デバッガーを起動します。

1. ときに、 **/clr**診断が生成されたら、選択**再試行**選び、**中断**します。

1. [呼び出し履歴] ウィンドウを開きます。 (メニュー バーで、**デバッグ** > **Windows** > **呼び出し履歴**)。問題のある`DllMain`または静的初期化子は緑色の矢印で識別されます。 問題のある関数が示されない場合は、以下の手順を実行して検索する必要があります。

1. 開く、**イミディ エイト**ウィンドウ (メニュー バーで、**デバッグ** > **Windows** > **イミディ エイト**)。

1. 入力に .load sos.dll、**イミディ エイト**ウィンドウ、SOS デバッグ サービスを読み込めません。

1. 型! dumpstack に、**イミディ エイト**、内部の完全な一覧を取得するにはウィンドウ **/clr**スタック。

1. _CorDllMain の (スタックの一番下に最も近い) 最初のインスタンスを探します (場合`DllMain`問題の原因) もの、または GetTargetForVTableEntry (静的初期化子、問題の原因) 場合。 この呼び出しのすぐ下にあるスタック エントリが、ローダー ロック中に実行しようとした、MSIL 実装の関数の呼び出しです。

1. ソース ファイルに移動し、前の手順で特定し適切な数のシナリオとソリューションのシナリオ」セクションで説明されているを使用して、問題の行。

## <a name="example"></a>例

### <a name="description"></a>説明

次の例からのコードを移動することによってローダー ロックを回避する方法を示しています。`DllMain`グローバル オブジェクトのコンス トラクターにします。

このサンプルでは、コンス トラクターには、元のマネージ オブジェクトが含まれています。 グローバル マネージ オブジェクトは`DllMain`します。 このサンプルの 2 番目の部分は、マネージド オブジェクトのインスタンスを作成して、初期化を実行するモジュール コンストラクターを呼び出し、アセンブリを参照します。

### <a name="code"></a>コード

```cpp
// initializing_mixed_assemblies.cpp
// compile with: /clr /LD
#pragma once
#include <stdio.h>
#include <windows.h>
struct __declspec(dllexport) A {
   A() {
      System::Console::WriteLine("Module ctor initializing based on global instance of class.\n");
   }

   void Test() {
      printf_s("Test called so linker does not throw away unused object.\n");
   }
};

#pragma unmanaged
// Global instance of object
A obj;

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) {
   // Remove all managed code from here and put it in constructor of A.
   return true;
}
```

この例では、混在アセンブリの初期化の問題を示しています。

```cpp
// initializing_mixed_assemblies_2.cpp
// compile with: /clr initializing_mixed_assemblies.lib
#include <windows.h>
using namespace System;
#include <stdio.h>
#using "initializing_mixed_assemblies.dll"
struct __declspec(dllimport) A {
   void Test();
};

int main() {
   A obj;
   obj.Test();
}
```

このコードを実行すると、次の出力が生成されます。

```Output
Module ctor initializing based on global instance of class.

Test called so linker does not throw away unused object.
```

## <a name="see-also"></a>関連項目

[混在 (ネイティブおよびマネージド) アセンブリ](../dotnet/mixed-native-and-managed-assemblies.md)
