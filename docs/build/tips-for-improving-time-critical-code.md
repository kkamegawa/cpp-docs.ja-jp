---
title: タイム クリティカルなコードを高速化するためのヒント
ms.date: 11/04/2016
helpviewer_keywords:
- _lsearch function
- qsort function
- background tasks
- standard sort routines
- clock cycle losses
- code, time-critical
- memory [C++], monitoring usage
- execution, speed improvements
- local heap performance
- optimization [C++], time-critical code
- performance [C++], time-critical code
- threading [C++], performance
- cache [C++], hits and misses
- linear search performance
- page faults
- best practices, time-critical code
- searching [C++], improving performance
- sorting data, improving performance
- threading [C++], best practices
- threading [C++], background tasks
- lists, sorting
- bsearch function
- MFC [C++], performance
- sort routines
- programs [C++], performance
- _lfind function
- heap allocation, time-critical code performance
ms.assetid: 3e95a8cc-6239-48d1-9d6d-feb701eccb54
ms.openlocfilehash: 828a0c49440b4fd2e1f3ae10514ffb86b2315ebd
ms.sourcegitcommit: fcb48824f9ca24b1f8bd37d647a4d592de1cc925
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/15/2019
ms.locfileid: "69498111"
---
# <a name="tips-for-improving-time-critical-code"></a>タイム クリティカルなコードを高速化するためのヒント

実行が速いコードを書くには、アプリケーションのすべての側面およびシステムとのやり取りを理解する必要があります。 このトピックでは、コードのタイム クリティカルな部分が満足に機能するよう、よく知られたコーディング テクニックの代わりとなるものを提案します。

要約すると、タイム クリティカルなコードを改善するには、次を行う必要があります。

- プログラムのどの部分を高速にする必要があるかを知る。

- コードのサイズと速度を知る。

- 新しい機能のコストを知る。

- ジョブを完了するために必要な最小限の作業を知る。

コードのパフォーマンスに関する情報を収集するには、パフォーマンス モニター (perfmon.exe) を使うことができます。

## <a name="sections-in-this-article"></a>この記事のセクション

- [キャッシュミスとページフォールト](#_core_cache_hits_and_page_faults)

- [並べ替えと検索](#_core_sorting_and_searching)

- [MFC およびクラスライブラリ](#_core_mfc_and_class_libraries)

- [共有ライブラリ](#vcovrsharedlibraries)

- [頻繁](#_core_heaps)

- [スレッド](#_core_threads)

- [小さいワーキングセット](#_core_small_working_set)

##  <a name="_core_cache_hits_and_page_faults"></a>キャッシュミスとページフォールト

ミスしたキャッシュ ヒット (内部および外部キャッシュの両方) およびページ フォールト (プログラムの命令とデータのために 2 次的なストレージに行く) は、プログラムのパフォーマンスを遅らせます。

CPU キャッシュヒットは、プログラム10-20 のクロックサイクルにかかる可能性があります。 外部キャッシュヒットは、20-40 のクロックサイクルをコストにかけることができます。 ページ フォールトでは、100 万クロック サイクルが必要になります (プロセッサが毎秒 500 万回の命令を処理し、ページ フォールトで 2 ミリ秒を要したと仮定)。 そのため、キャッシュ ヒットのミスやページ フォールトの数を減らすコードを書くことが、プログラムの実行に大きく役立ちます。

プログラムが遅いことの一因に、必要以上にページ フォールトの回数やキャッシュ ミスの回数が多いことがあります。 これを避けるには、参照場所が整理されたデータ構造にする、つまり関連データを一緒にしておくことが重要です。 データ構造が優れているように見えても、参照場所が良くないため、実は劣った構造であったり、その逆もあります。 2 つの例を挙げます。

- 動的に割り当てられたリンク リストは、プログラムのパフォーマンスを低下させる可能性があります。項目を検索したり、リストの最後まで走査したりすると、スキップされた各リンクでキャッシュ ミスやページ フォールトが生じることがあるからです。 単純な配列に基づいたリストの導入のほうが大幅に速い場合があります。キャッシュが優れ、ページ フォールトが少ないからです。配列の拡張が難しい点を考慮に入れても、より速い可能性があります。

- 動的に割り当てられたリンク リストを使うハッシュ テーブルはパフォーマンスを低下させる可能性があります。 その延長で、動的に割り当てられたリンク リストを使ってコンテンツを保存するハッシュ テーブルは、パフォーマンスがさらに劣る可能性があります。 最終的には、配列を使った単純な一方向の検索のほうが実際には速い場合があります (状況に応じて)。 配列ベースのハッシュ テーブル (いわゆる「クローズド ハッシュ」) は、導入が見過ごされがちですが、多くの場合パフォーマンスが優れています。

##  <a name="_core_sorting_and_searching"></a>並べ替えと検索

並べ替えは、多くの一般的な操作と比べて本質的に時間がかかります。 不必要な遅延を避ける最善の方法は、重要な時間帯に並べ替えを避けることです。 次を行うことができます。

- パフォーマンスが重要ではない時間まで並べ替えを延期します。

- 以前のパフォーマンスに影響しない時間帯にデータを並べ替えます。

- 並べ替えが本当に必要な部分だけデータを並べ替える。

並べ替えられた順番でリストをビルドできる場合があります。 ただし、並べ替えられた順番でデータを挿入する必要がある場合、より複雑なデータ構造が必要となって参照場所の配置が悪くなる可能性があり、キャッシュ ミスやページ フォールトにつながるため注意する必要があります。 すべての場面で効果的な単一の方法はありません。 いくつかの方法を試してみて、違いを測定します。

並べ替えに関する一般的なヒントを次に示します。

- ストックの並べ替えを使ってバグを最小限にします。

- 並べ替えの複雑さを軽減するために事前に行える作業は、実行する価値があります。 データのワンタイム パスによって比較が単純化され、並べ替えが O(n log n) から O(n) に減る場合、ほとんどの場合に効率が上がります。

- 並べ替えアルゴリズムの参照場所と実行対象のデータについて考えます。

検索の場合、並べ替えと比べて代替方法が少なくなります。 検索がタイム クリティカルな場合、バイナリ検索またはハッシュ テーブル ルックアップがほとんどいつも最善の方法となりますが、並べ替えの場合と同じく、場所も考慮する必要があります。 多くのポインターがあってページ フォールトやキャッシュ ミスが生じるデータ構造でのバイナリ検索よりも、小さな配列の一方向の検索のほうが速くなる場合があります。

##  <a name="_core_mfc_and_class_libraries"></a>MFC およびクラスライブラリ

Microsoft Foundation Classes (MFC) は、コードの作成を大幅に簡略化します。 タイム クリティカルなコードを作成する場合、一部のクラスに特有のオーバーヘッドについて理解する必要があります。 タイム クリティカルなコードが使用する MFC コードがパフォーマンス要件を満たしているかどうか確認します。 次は、知っておく必要のある MFC クラスと関数の一覧です。

- `CString`MFC は C ランタイムライブラリを呼び出して、 [CString](../atl-mfc-shared/reference/cstringt-class.md)にメモリを動的に割り当てます。 一般に、`CString` の効率は、他の動的に割り当てられる文字列と同等です。 また他の動的に割り当てられた文字列と同様に、動的な割り当てとリリースのオーバーヘッドがあります。 多くの場合、スタックの単純な `char` 配列は同じ用途を速く行うことができます。 定数文字列を保存するのに `CString` は使用しません。 代わりに、`const char *` を使用してください。 `CString` オブジェクトで行う操作には何らかのオーバーヘッドがあります。 ランタイムライブラリ[文字列関数](../c-runtime-library/string-manipulation-crt.md)の使用が高速になる場合があります。

- `CArray`[CArray](../mfc/reference/carray-class.md)は、通常の配列では使用できない柔軟性を備えていますが、プログラムではこれを必要としない場合があります。 配列に特定の制限があることを知っている場合、代わりにグローバル固定配列を使用できます。 `CArray` を使用する場合、`CArray::SetSize` を使ってそのサイズを設定し、要素の数を指定します。再割り当てが必要なときにはこれを利用して拡張します。 それ以外の場合、要素を追加すると配列に対して頻繁に再割り当てとコピーが行われるため、非効率的となり、メモリが断片化されます。 また、配列に項目を挿入すると、`CArray` は続く項目をメモリに移動するため、配列を増やす必要が生じる場合があります。 これらの操作によって、キャッシュ ミスやページ フォールトが生じることがあります。 MFC が使用するコードを見直すと、自分のシナリオに応じてより具体的に記述することで、パフォーマンスを向上できる可能性があります。 `CArray` はテンプレートであるため、たとえば特定の型に応じて `CArray` 特殊化することもできます。

- `CList`[CList](../mfc/reference/clist-class.md)はダブルリンクリストであるため、要素の挿入は、リストの先頭、末尾、および既知の位置`POSITION`() に高速になります。 要素を値またはインデックスで検索する場合、順次検索が必要となり、リストが長い場合は遅くなります。 コードでダブルリンク リストが必要ないなら、`CList` の使用を再度検討できます。 シングルリンク リストは、すべての操作で追加のポインターを更新するためのオーバーヘッドおよびそのポインターのメモリのオーバーヘッドを減らすことができます。 追加のメモリは多くありませんが、キャッシュ ミスやページ フォールトが生じる余地を与えることになります。

- `IsKindOf`この関数は、さまざまなデータ領域で多数の呼び出しを生成し、大量のメモリにアクセスすることで、参照の局所性を低下させる可能性があります。 デバッグ ビルド (たとえば ASSERT 呼び出し) で有用ですが、リリース ビルドでは使用しないようにします。

- `PreTranslateMessage`Windows `PreTranslateMessage`の特定のツリーに異なるキーボードアクセラレータが必要な場合、またはメッセージポンプにメッセージ処理を挿入する必要がある場合に使用します。 `PreTranslateMessage` は MFC ディスパッチ メッセージを変えます。 `PreTranslateMessage` をオーバーライドする場合、必要なレベルでのみ行います。 たとえば、特定のビューの子にのみ届くメッセージに関心がある場合、`CMainFrame::PreTranslateMessage` をオーバーライドする必要はありません。 代わりに、ビュー クラスの `PreTranslateMessage` をオーバーライドします。

   任意のウィンドウに送られる任意のメッセージを処理するために `PreTranslateMessage` を使って通常のディスパッチ パスを迂回しないようにします。 この目的には、[ウィンドウプロシージャ](../mfc/registering-window-classes.md)と MFC メッセージマップを使用します。

- `OnIdle`アイドル状態のイベントは、イベントと`WM_KEYDOWN` `WM_KEYUP`イベントの間など、予期しない時間に発生する可能性があります。 コードをトリガーするには、タイマーのほうがより効果的な場合があります。 偽のメッセージを生成したり、`OnIdle` のオーバーライドから常に `TRUE` を返したりすることによって、繰り返し `OnIdle` を強制的に呼び出すのを避けます。スレッドがスリープできなくなります。 ここでも、タイマーまたは個別のスレッドのほうが適切な場合があります。

##  <a name="vcovrsharedlibraries"></a>共有ライブラリ

望ましいのはコードを再利用することです。 ただし、他人のコードを使用する場合、パフォーマンスが重要な場面でどのように動作するかを正確に把握している必要があります。 それを確かめる最善の方法は、ソース コードに分け入るか、PView やパフォーマンス モニターなどのツールで測定することです。

##  <a name="_core_heaps"></a>頻繁

複数のヒープを思慮深く使用します。 `HeapCreate` および `HeapAlloc` で作成した追加のヒープにより、関連する割り当てのセットを管理し、破棄することができます。 過多のメモリをコミットしないようにします。 複数のヒープを使用する場合、最初にコミットするメモリの量に特に注意します。

複数のヒープを使用する代わりに、ヘルパー機能を使ってコードと既定のヒープを相互作用させることができます。 ヘルパー機能はカスタム割り当て戦略を促進して、アプリケーションのパフォーマンスを改善することができます。 たとえば、小さな割り当てを頻繁に行う場合、これらの割り当てを既定のヒープの一部にローカライズすることができます。 メモリの大きなブロックを割り当てた後、ヘルパー機能を使ってそのブロックからサブ割り当てすることができます。 そうするなら、割り当ては既定のヒープから来るため、未使用のメモリがある追加のヒープはなくなります。

ただし、場合によっては既定のヒープを使うことで参照場所を減らせる場合があります。 Process Viewer、Spy++、またはパフォーマンス モニターを使って、オブジェクトをヒープからヒープへ移動させる影響を測定します。

ヒープを測定して、ヒープ上のすべての割り当てを把握します。 C ランタイム[デバッグヒープルーチン](/visualstudio/debugger/crt-debug-heap-details)を使用して、ヒープのチェックポイントとダンプを行います。 出力を Microsoft Excel などのスプレッドシート プログラムに読み込ませ、ピボット テーブルを使って結果を表示できます。 割り当ての合計数、サイズ、および分布を確認します。 これらを、作業セットのサイズと比較します。 また、関連サイズのオブジェクトのクラスタリングも確認します。

さらに、パフォーマンス カウンターでメモリの使用量を監視できます。

##  <a name="_core_threads"></a>スレッド

バックグラウンド タスクの場合、スレッドを使用するよりも、イベントの効果的なアイドル処理のほうが速い可能性があります。 シングル スレッド プログラムのほうが参照場所を理解しやすくなります。

経験則として、ブロックするオペレーティング システムの通知がバックグラウンド作業のルートにある場合にのみ、スレッドを使用します。 そのような場合、イベントでメイン スレッドをブロックするのは実際的でないため、スレッドが最適なソリューションとなります。

また、スレッドは通信問題を引き起こす場合があります。 メッセージのリストまたは共有メモリの割り当てと使用によって、スレッド間の通信リンクを管理する必要があります。 通信リンクの管理には、競合状態やデッドロック問題を回避するために、通常は同期が必要です。 この複雑さのせいで、バグやパフォーマンスの問題が簡単に生じ得ます。

詳細については、「[アイドルループ処理](../mfc/idle-loop-processing.md)と[マルチスレッド](../parallel/multithreading-support-for-older-code-visual-cpp.md)」を参照してください。

##  <a name="_core_small_working_set"></a>小さいワーキングセット

作業セットが小さいと、参照場所が向上し、ページ フォールトが少なくなり、キャッシュ ヒットが増えます。 プロセス作業セットは、オペレーティング システムが参照場所を測定するために直接提供する最も近いメトリックです。

- ワーキングセットの上限と下限を設定するには、 [SetProcessWorkingSetSize](/windows/win32/api/winbase/nf-winbase-getprocessworkingsetsize)を使用します。

- ワーキングセットの上限と下限を取得するには、 [GetProcessWorkingSetSize](/windows/win32/api/winbase/nf-winbase-setprocessworkingsetsize)を使用します。

- 作業セットのサイズを表示するには、Spy++ を使用します。

## <a name="see-also"></a>関連項目

[コードの最適化](optimizing-your-code.md)
