---
title: ARM64 ABI 規則の概要
ms.date: 03/27/2019
ms.openlocfilehash: 07d58bbd64795235ad63a7b26b6f18fcffdcd1d2
ms.sourcegitcommit: 069e3833bd821e7d64f5c98d0ea41fc0c5d22e53
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/21/2019
ms.locfileid: "74303267"
---
# <a name="overview-of-arm64-abi-conventions"></a>ARM64 ABI 規則の概要

Windows 用の基本的なアプリケーションバイナリインターフェイス (ABI) は、64ビットモード (ARMv8 以降のアーキテクチャ) で ARM プロセッサをコンパイルして実行する場合、ほとんどの場合、ARM の標準 AArch64 EABI に従います。 この記事では、EABI に記載されている内容の重要な前提事項と変更点について説明します。 32ビット ABI の詳細については、「 [ARM abi 規則の概要](overview-of-arm-abi-conventions.md)」を参照してください。 標準 ARM EABI の詳細については、「 [Arm アーキテクチャ用のアプリケーションバイナリインターフェイス (ABI)](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.swdev.abi/index.html) 」 (外部リンク) を参照してください。

## <a name="definitions"></a>定義

64ビットサポートの導入により、ARM ではいくつかの用語が定義されています。

- **AArch32** – Thumb モードの実行を含む、ARM によって定義されたレガシ32ビット命令セットアーキテクチャ (ISA)。
- **AArch64** – ARM によって定義された新しい64ビット命令セットアーキテクチャ (ISA)。
- **ARMv7** – AArch32 のサポートのみを含む "7 世代" ARM ハードウェアの仕様です。 ARM ハードウェアのこのバージョンは、ARM でサポートされている最初のバージョンの Windows です。
- **ARMv8** – AArch32 と AArch64 の両方のサポートを含む "8 番目世代" ARM ハードウェアの仕様です。

Windows では、次の用語も使用します。

- **Arm** –32ビット ARM アーキテクチャ (AArch32) を参照します。 woa (arm) と呼ばれることもあります。
- **ARM32** –上記の ARM と同じです。このドキュメントでは、わかりやすくするために使用されています。
- **ARM64** –64ビット ARM アーキテクチャ (AArch64) を参照します。 WoA64 のようなものはありません。

最後に、データ型を参照するときに、ARM から次の定義が参照されます。

- **Short-vector** -SIMD で直接表現可能なデータ型。8バイトまたは16バイトの要素のベクターです。 これは、8バイトまたは16バイトのサイズに合わせて調整されます。各要素は1、2、4、または8バイトです。
- **Hfa (同種浮動小数点集計)** – 2 ~ 4 個の同一の浮動小数点メンバー (float または double) を持つデータ型。
- **Hva (同種の Short ベクター集計)** – 2 ~ 4 個の同一の short ベクターメンバーを持つデータ型。

## <a name="base-requirements"></a>基本要件

ARM64 バージョンの Windows 統制は、ARMv8 以降のアーキテクチャで常に実行されています。 浮動小数点とネオンの両方のサポートは、ハードウェアに存在するものと見なされます。

ARMv8 仕様では、AArch32 と AArch64 の両方に対して、新しいオプションの crypto および CRC ヘルパーオペコードが記述されています。 現在、これらのサポートは省略可能ですが、推奨されます。 これらのオペコードを利用するには、まず、アプリでランタイムの有無を確認する必要があります。

## <a name="endianness"></a>エンディアン

Windows の ARM32 バージョンと同様に、ARM64 はリトルエンディアンモードで実行されます。 AArch64 でカーネルモードをサポートしていないと、エンディアンの切り替えは実現できません。そのため、より簡単に適用できます。

## <a name="alignment"></a>アラインメント

ARM64 で実行されている Windows では、CPU ハードウェアは、不整合のあるアクセスを透過的に処理できます。 AArch32 の改善により、このサポートは、すべての整数アクセス (複数の単語によるアクセスを含む) および浮動小数点によるアクセスにも使用できるようになりました。

ただし、キャッシュされていない (デバイス) メモリへのアクセスは、常にアラインする必要があります。 コードが、キャッシュされていないメモリからの誤ったデータの読み取りまたは書き込みを行う可能性がある場合は、すべてのアクセスを揃える必要があります。

ローカルのレイアウトの既定の配置:

| サイズ (バイト) | 配置 (バイト単位) |
| - | - |
| 1 | 1 |
| 2 | 2 |
| 3、4 | 4 |
| > 4 | 8 |

Globals とスタティックの既定のレイアウトの配置:

| サイズ (バイト) | 配置 (バイト単位) |
| - | - |
| 1 | 1 |
| 2 - 7 | 4 |
| 8 - 63 | 8 |
| > = 64 | 16 |

## <a name="integer-registers"></a>整数レジスタ

AArch64 アーキテクチャでは、32の整数レジスタがサポートされています。

| 登録 | Volatile? | 役割 |
| - | - | - |
| x0 | Volatile | パラメーター/スクラッチレジスタ1、結果レジスタ |
| x1-x 7 | Volatile | パラメーター/ゼロ登録2-8 |
| x8-x15 | Volatile | スクラッチレジスタ |
| x16-x17 | Volatile | プロシージャ内呼び出しスクラッチレジスタ |
| x18 | 非 volatile | プラットフォームレジスタ: カーネルモードでは、は現在のプロセッサの KPCR を指します。ユーザーモードでは、は TEB を指します。 |
| x19-x28 | 非 volatile | スクラッチレジスタ |
| x29/fp | 非 volatile | フレーム ポインター |
| x30/lr | 非 volatile | リンクレジスタ |

各レジスタには、64ビットの完全な値 (x0-x30 を使用) または32ビット値 (w0-w30) としてアクセスできます。 32-ビット演算では、結果を最大64ビットまで拡張できます。

パラメーターレジスタの使用方法の詳細については、「パラメーターの引き渡し」セクションを参照してください。

AArch32 とは異なり、プログラムカウンター (PC) とスタックポインター (SP) はインデックス付きレジスタではありません。 アクセスの方法は制限されています。 また、x31 レジスタがないことにも注意してください。 このエンコードは、特別な目的で使用されます。

ETW などのサービスで高速スタックウォークとの互換性を確保するには、フレームポインター (x29) が必要です。 スタック上の前の {x29, x30} ペアをポイントする必要があります。

## <a name="floating-pointsimd-registers"></a>浮動小数点/SIMD レジスタ

AArch64 アーキテクチャでは、次に示すように、32の浮動小数点/SIMD レジスタもサポートされています。

| 登録 | Volatile? | 役割 |
| - | - | - |
| v0 | Volatile | パラメーター/スクラッチレジスタ1、結果レジスタ |
| v1-v7 | Volatile | パラメーター/スクラッチレジスタ2-8 |
| v8-v15 | 非 volatile | スクラッチレジスタ (下位64ビットのみが非揮発性) |
| v16-v31 | Volatile | スクラッチレジスタ |

各レジスタには、128ビットの完全な値 (v31 または q0) としてアクセスできます。 64ビット値 (d31 を使用)、32ビット値 (s31 を使用)、16ビット値 (h0 経由)、または8ビット値 (b0-b31 を使用) としてアクセスされる可能性があります ()。 128ビットより小さいアクセスは、完全な128ビットレジスタの下位ビットにのみアクセスします。 特に指定がない限り、残りのビットはそのまま残ります。 (AArch64 は AArch32 とは異なり、より小さいレジスタが大きなレジスタの上にパックされています)。

浮動小数点制御レジスタ (FPCR) には、その中のさまざまなビットフィールドに関する特定の要件があります。

| Bits | 意味 | Volatile? | 役割 |
| - | - | - | - |
| 26 | AHP | 不揮発性 | 代替の半精度制御。 |
| 25 | DN | 不揮発性 | 既定の NaN モードコントロール。 |
| 24 | FZ | 非 volatile | ゼロモードコントロールです。 |
| 23-22 | RMode | 非 volatile | 丸めモードコントロール。 |
| 15、12-8 | IDE/IXE/その他 | 不揮発性 | 例外トラップ有効化ビット。常に0である必要があります。 |

## <a name="system-registers"></a>システムレジスタ

AArch32 と同様、AArch64 仕様には、システム制御の "スレッド ID" レジスタが3つ用意されています。

| 登録 | 役割 |
| - | - |
| TPIDR_EL0 | 予約済み。 |
| TPIDRRO_EL0 | 現在のプロセッサの CPU 数を格納します。 |
| TPIDR_EL1 | 現在のプロセッサの KPCR 構造体をポイントします。 |

## <a name="floating-point-exceptions"></a>浮動小数点例外

AArch64 システムでは、IEEE 浮動小数点例外のサポートは省略可能です。 ハードウェアの浮動小数点例外を持つプロセッサバリアントの場合、Windows カーネルは例外をサイレントにキャッチし、FPCR レジスタで暗黙的に無効にします。 このトラップは、プロセッサバリアント間で正規化された動作を保証します。 それ以外の場合、例外をサポートしていないプラットフォームで開発されたコードは、サポートがあるプラットフォームで実行しているときに、予期しない例外が発生する可能性があります。

## <a name="parameter-passing"></a>パラメーター渡し

非可変個引数関数の場合、Windows ABI はパラメーターパッシングに ARM によって指定された規則に従います。 これらの規則は、AArch64 アーキテクチャのプロシージャ呼び出し標準から直接抜粋ですます。

### <a name="stage-a--initialization"></a>ステージ A –初期化

このステージは、引数の処理が開始される前に1回だけ実行されます。

1. 次の汎用レジスタ番号 (NGRN) は0に設定されます。

1. 次の SIMD および浮動小数点のレジスタ番号 (NSRN) が0に設定されています。

1. 次の積み上げ引数アドレス (NSAA) は、現在のスタックポインター値 (SP) に設定されます。

### <a name="stage-b--pre-padding-and-extension-of-arguments"></a>ステージ B –引数の事前埋め込みと拡張

一覧の引数ごとに、次の一覧の最初の照合ルールが適用されます。 一致するルールがない場合は、引数が変更されずに使用されます。

1. 引数の型が、呼び出し元と呼び出し先の両方で静的に決定できない複合型の場合、引数はメモリにコピーされ、引数はコピーへのポインターに置き換えられます。 (C/C++にはそのような型はありませんが、他の言語または言語拡張機能に存在します)。

1. 引数の型が HFA または HFA の場合、引数は変更されずに使用されます。

1. 引数の型が16バイトを超える複合型の場合、引数は呼び出し元によって割り当てられたメモリにコピーされ、引数はコピーへのポインターで置き換えられます。

1. 引数の型が複合型の場合、引数のサイズは8バイトの最も近い倍数に切り上げられます。

### <a name="stage-c--assignment-of-arguments-to-registers-and-stack"></a>ステージ C –レジスタとスタックへの引数の割り当て

リスト内の引数ごとに、引数が割り当てられるまで、次の規則が適用されます。 レジスタに引数が割り当てられている場合は、レジスタ内の未使用のビットの値が指定されていません。 引数がスタックスロットに割り当てられている場合、未使用の埋め込みバイトの値は未指定です。

1. 引数が半分、単精度、倍精度浮動小数点型、または Short 型の浮動小数点または短いベクター型で、NSRN が8未満の場合、引数はレジスタ v\[NSRN] の最下位ビットに割り当てられます。 NSRN は1ずつインクリメントされます。 引数が割り当てられました。

1. 引数が HFA または HFA であり、十分な未割り当ての SIMD および浮動小数点レジスタがある場合 (NSRN + メンバーの数が 8)、引数は SIMD および浮動小数点レジスタに割り当てられます。これは、HFA または HFA のメンバーごとに1つのレジスタに割り当てられます。 NSRN は、使用されているレジスタの数だけインクリメントされます。 引数が割り当てられました。

1. 引数が HFA または HFA の場合、NSRN は8に設定され、引数のサイズは最も近い8バイトの倍数に切り上げられます。

1. 引数が HFA、HFA、4精度浮動小数点型、または Short Vector 型の場合、NSAA は8より大きい値または引数の型の自然アラインメントに切り上げられます。

1. 引数が半精度または単精度浮動小数点型の場合、引数のサイズは8バイトに設定されます。 効果は、引数が64ビットレジスタの最下位ビットにコピーされ、残りのビットが未指定の値で埋められた場合と同じになります。

1. 引数が HFA、HFA、0.5、Single、Double、またはクアッドコアの浮動小数点または Short ベクター型である場合、引数は調整された NSAA のメモリにコピーされます。 NSAA が引数のサイズだけインクリメントされます。 引数が割り当てられました。

1. 引数が整数型またはポインター型の場合、引数のサイズは8バイト以下になり、NGRN は8バイト以下になります。この引数は、x\[NGRN] の最下位ビットにコピーされます。 NGRN は1ずつインクリメントされます。 引数が割り当てられました。

1. 引数のアラインメントが16の場合、NGRN は次の偶数に切り上げられます。

1. 引数が整数型の場合、引数のサイズは16に、NGRN は7未満の場合、引数は x\[NGRN] と x\[NGRN + 1] にコピーされます。 x\[NGRN] には、引数のメモリ表現の下位の文字が含まれている必要があります。 NGRN は2つずつインクリメントされます。 引数が割り当てられました。

1. 引数が複合型であり、引数の2つの単語のサイズが8から n を引いた値である場合、引数は、x\[NGRN] から始まる連続する汎用レジスタにコピーされます。 この引数は、二重単語でアラインされたアドレスからレジスタに読み込まれているかのように渡されます。また、メモリから連続してレジスタが読み込まれるように、LDR 命令の適切なシーケンスを使用します。 レジスタの未使用部分の内容は、この標準では指定されていません。 NGRN は、使用されるレジスタの数によってインクリメントされます。 引数が割り当てられました。

1. NGRN は8に設定されています。

1. NSAA は、8の大きい方、または引数の型の自然アラインメントに切り上げられます。

1. 引数が複合型の場合、引数は調整された NSAA のメモリにコピーされます。 NSAA が引数のサイズだけインクリメントされます。 引数が割り当てられました。

1. 引数のサイズが8バイト未満の場合、引数のサイズは8バイトに設定されます。 効果は、引数が64ビットレジスタの最下位ビットにコピーされ、残りのビットが未指定の値で埋められた場合と同じになります。

1. 引数は、調整された NSAA のメモリにコピーされます。 NSAA が引数のサイズだけインクリメントされます。 引数が割り当てられました。

### <a name="addendum-variadic-functions"></a>補遺: 可変個引数関数

可変個の引数を受け取る関数は、次のように、上記とは異なる方法で処理されます。

1. すべての複合複合は同様に扱われます。HFAs や HVAs に特別な処理はありません。

1. SIMD および浮動小数点レジスタは使用されません。

実質的には、2番目のルールと同じように、虚数スタックに引数を割り当てます。この場合、スタックの最初の64バイトが x 7 に読み込まれ、残りのスタック引数は正常に配置されます。

## <a name="return-values"></a>戻り値

整数値は、x0 で返されます。

浮動小数点値は、必要に応じて s0、d0、または v0 で返されます。

HFA と HFA の値は、必要に応じて s0-s3、d0-d3、または v0-v3 で返されます。

値によって返される型は、特定のプロパティがあるかどうかによって異なる方法で処理されます。 これらのプロパティがすべて含まれる型

- これらは C++ 14 標準定義によって*集計*されます。つまり、ユーザー指定のコンストラクターがなく、プライベートまたは保護された非静的データメンバー、基底クラス、および仮想関数もありません。
- 単純なコピー代入演算子を持っています。
- これには自明なデストラクターがあります。

次の戻り値のスタイルを使用します。

- 8バイト以下の型は、x0 で返されます。
- 16バイト以下の型は、x0 と x1 で返され、x0 には下位8バイトが含まれます。
- 16バイトを超える型の場合、呼び出し元は、十分なサイズのメモリブロックと、結果を保持するためのアラインメントを予約する必要があります。 メモリブロックのアドレスは、x8 の関数に追加の引数として渡す必要があります。 呼び出し先は、サブルーチンの実行中に、結果のメモリブロックを変更することができます。 この呼び出し先は、x8 に格納されている値を保持する必要はありません。

他のすべての型は、次の規則を使用します。

- 呼び出し元は、十分なサイズのメモリブロックと、結果を保持するためのアラインメントを予約する必要があります。 メモリブロックのアドレスは、x0 の関数に追加の引数として渡す必要があります。または、$this が x0 で渡される場合は x1 です。 呼び出し先は、サブルーチンの実行中に、結果のメモリブロックを変更することができます。 呼び出し先は、x0 内のメモリブロックのアドレスを返します。

## <a name="stack"></a>スタック

ARM による ABI に従うと、スタックは常に16バイトでアラインされたままである必要があります。 AArch64 には、SP が16バイトでアラインされていない場合にスタックアラインメントエラーが生成され、SP 相対の読み込みまたはストアが完了するというハードウェア機能が含まれています。 Windows は、この機能が常に有効になっている状態で実行されます。

4k 以上のスタックを割り当てる関数では、最後のページより前の各ページが順番に接していることを確認する必要があります。 この操作により、Windows がスタックを拡張するために使用するガードページを "leap" できなくなります。 通常、タッチは `__chkstk` ヘルパーによって行われます。これには、x15 で合計スタック割り当てを16で割ったカスタム呼び出し規約があります。

## <a name="red-zone"></a>赤色のゾーン

現在のスタックポインターのすぐ下にある16バイト領域は、分析および動的パッチ適用シナリオで使用するために予約されています。 この領域には、[sp, #-16] に2つのレジスタを格納し、それらを任意の目的で一時的に使用する、慎重に生成されたコードが許可されます。 Windows カーネルでは、例外または割り込みが発生した場合に、ユーザーモードとカーネルモードの両方で16バイトが上書きされないことが保証されます。

## <a name="kernel-stack"></a>カーネルスタック

Windows の既定のカーネルモードスタックは6ページ (24k) です。 カーネルモードで大きなスタックバッファーを使用する関数には、特に注意してください。 少し時間がかかる割り込みは、ヘッドルームがほとんどなく、スタックパニックのバグチェックを作成する可能性があります。

## <a name="stack-walking"></a>スタックウォーク

ウィンドウ内のコードは、フレームポインターが有効 ([/Oy-](reference/oy-frame-pointer-omission.md)) でコンパイルされ、高速なスタックウォークが可能になります。 一般に、x29 (fp) は、チェーン内の次のリンク (つまり、{fp, lr} のペア) を指します。これは、スタック上の前のフレームへのポインターと、戻り先のアドレスを示します。 また、プロファイルとトレースを向上させるために、フレームポインターも有効にすることをお勧めします。

## <a name="exception-unwinding"></a>例外のアンワインド

例外処理中のアンワインドは、アンワインドコードを使用することによって支援されます。 アンワインドコードは、実行可能ファイルの .xdata セクションに格納されているバイトのシーケンスです。 プロローグとエピローグの操作は抽象的な方法で記述されており、呼び出し元のスタックフレームへのバックアップの準備として、関数のプロローグの効果を元に戻すことができます。 アンワインドコードの詳細については、「 [ARM64 exception 処理](arm64-exception-handling.md)」を参照してください。

ARM EABI では、アンワインドコードを使用する例外アンワインドモデルも指定します。 ただし、示されている仕様は、Windows でのアンワインドには不十分です。これは、PC が関数プロローグまたはエピローグの途中にあるケースを処理する必要があります。

動的に生成されるコードは、`RtlAddFunctionTable` および関連する関数を介して動的関数テーブルで記述する必要があります。これにより、生成されたコードが例外処理に参加できるようになります。

## <a name="cycle-counter"></a>サイクルカウンター

すべての ARMv8 Cpu は、Windows がユーザーモードを含む任意の例外レベルで読み取り可能になるように構成された64ビットレジスタである、サイクルカウンターレジスタをサポートするために必要です。 これには、特殊な PMCCNTR_EL0 レジスタを使用してアクセスできます。また、アセンブリコードで MSR オペコードを使用C++するか、C/code に組み込まれている `_ReadStatusReg` を使用します。

ここに示すサイクルカウンターは、ウォールクロックではなく、実際のサイクルカウンターです。 カウント頻度は、プロセッサの頻度によって異なります。 サイクルカウンターの頻度を把握しておく必要がある場合は、cycle カウンターを使用しないでください。 代わりに、`QueryPerformanceCounter`を使用する必要がある、壁のクロック時間を測定する必要があります。

## <a name="see-also"></a>参照

[Visual C++ の ARM への移行に関する一般的な問題](common-visual-cpp-arm-migration-issues.md)<br/>
[ARM64 例外処理](arm64-exception-handling.md)
