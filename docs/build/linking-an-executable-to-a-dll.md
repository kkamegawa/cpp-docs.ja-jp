---
title: DLL と実行形式のリンク
ms.date: 08/22/2019
helpviewer_keywords:
- run time [C++], linking
- dynamic load linking [C++]
- linking [C++], DLLs
- DLLs [C++], linking
- implicit linking [C++]
- explicit linking [C++]
- executable files [C++], linking to DLLs
- loading DLLs [C++]
ms.assetid: 7592e276-dd6e-4a74-90c8-e1ee35598ea3
ms.openlocfilehash: 2f907fedcaaf9897749ee0eb6a7ea5a33e1af679
ms.sourcegitcommit: b8c22e6d555cf833510753cba7a368d57e5886db
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/29/2020
ms.locfileid: "76821383"
---
# <a name="link-an-executable-to-a-dll"></a>DLL と実行形式のリンク

実行可能ファイルを DLL とリンクするには、次の 2 つの方法があります。

- *暗黙のリンク*。オペレーティングシステムが DLL を使用する実行可能ファイルと同時に DLL を読み込みます。 クライアント実行可能ファイルは、関数が静的にリンクされ、実行可能ファイル内に含まれている場合と同じように、DLL のエクスポート関数を呼び出します。 暗黙のリンクは、*静的な読み込み*や*読み込み時の動的リンク*と呼ばれることもあります。

- *明示的なリンク*。オペレーティングシステムが実行時に必要に応じて DLL を読み込みます。 明示的リンクによって DLL を使用する実行可能ファイルは、明示的に DLL を読み込んでアンロードする必要があります。 また、DLL から使用される各関数にアクセスするための関数ポインターも設定する必要があります。 静的にリンクされたライブラリまたは暗黙的にリンクされた DLL の関数の呼び出しとは異なり、クライアントの実行可能ファイルは、明示的にリンクされた DLL 内のエクスポートされた関数を関数ポインターを介して呼び出す必要があります。 明示的なリンクは、*動的読み込み*または*実行時の動的リンク*と呼ばれることがあります。

実行可能ファイルは、いずれかのリンク方法を使用して同じ DLL にリンクすることができます。 さらに、これらのメソッドは相互に排他的ではありません。1つの実行可能ファイルは、暗黙的に DLL にリンクすることができ、別の実行可能ファイルに明示的にアタッチすることもできます。

<a name="determining-which-linking-method-to-use"></a>

## <a name="determine-which-linking-method-to-use"></a>リンク方式の使い分け

暗黙のリンクと明示的なリンクのどちらを使用するかは、アプリケーションに対して行う必要があるアーキテクチャ上の決定です。 どちらの方法にも利点と欠点があります。

### <a name="implicit-linking"></a>暗黙的リンク

アプリケーションのコードで DLL のエクスポート関数を呼び出すと、暗黙にリンクされます。 DLL 関数を呼び出す実行形式のソース コードをコンパイルまたはアセンブルすると、オブジェクト コード内に外部関数への参照が生成されます。 この外部参照を解決するには、アプリケーションをインポート ライブラリ (.lib) ファイルとリンクする必要があります。インポート ライブラリは、DLL の作成元が提供します。

インポート ライブラリには、DLL を読み込んで、DLL 内の関数呼び出しを実装するコードが含まれるだけです。 リンカーは、インポート ライブラリ内に外部関数を見つけると、その関数のコードは DLL 内にあるものと認識します。 リンカーは、単に DLL コードの場所を実行可能ファイルに記入することによって、外部参照を解決します。システムはプロセスの起動時にこの情報を利用します。

動的にリンクされた参照を含むプログラムが起動されると、プログラムの実行可能ファイル内の情報に従って、必要な DLL を探します。 DLL が見つからない場合、システムはプロセスを終了し、エラーを報告するダイアログボックスを表示します。 それ以外の場合、システムは DLL モジュールをプロセスのアドレス空間にマップします。

Dll のいずれかに、初期化および終了コード (`DllMain`など) のエントリポイント関数がある場合、オペレーティングシステムは関数を呼び出します。 エントリ ポイント関数に渡されるパラメーターの 1 つは、DLL がプロセスにアタッチされようとしていることを示すコードになります。 エントリポイント関数が TRUE を返さない場合、システムはプロセスを終了し、エラーを報告します。

最後に、システムはプロセスの実行可能コードを変更し、その DLL 関数の開始アドレスをセットします。

プログラムのコードの残りの部分と同様に、ローダーは、プロセスの起動時に DLL コードをプロセスのアドレス空間にマップします。 オペレーティングシステムは、必要な場合にのみ、メモリに読み込みます。 結果として、以前のバージョンの Windows での読み込みを制御するために .def ファイルによって使用される `PRELOAD` および `LOADONCALL` のコード属性に意味がなくなりました。

### <a name="explicit-linking"></a>明示的リンク

ほとんどのアプリケーションは、使用する最も簡単なリンク方法であるため、暗黙的なリンクを使用します。 しかし、明示的リンクが必要な場合もあります。 ここでは、明示的リンクを使う一般的な理由について説明します。

- アプリケーションは、実行時まで読み込まれる DLL の名前を認識していません。 たとえば、起動時にアプリケーションによって DLL の名前とエクスポートされた関数が構成ファイルから取得される場合があります。

- プロセスの起動時に DLL が見つからない場合、暗黙的なリンクを使用するプロセスはオペレーティングシステムによって終了されます。 この状況では、明示的なリンクを使用するプロセスは終了されず、エラーからの回復を試みることができます。 たとえば、プロセスがユーザーにエラーを通知して、ユーザーに DLL への別のパスを指定させることができます。

- リンク先の Dll に失敗した `DllMain` 関数がある場合は、暗黙的なリンクを使用するプロセスも終了します。 この状況では、明示的なリンクを使用するプロセスは終了しません。

- Windows は、アプリケーションの読み込み時にすべての DLL を読み込むため、暗黙的に多くの DLL とリンクするアプリケーションは、起動に時間がかかることがあります。 起動時のパフォーマンスを向上させるために、アプリケーションでは、読み込み直後に必要な Dll の暗黙のリンクのみを使用できます。 明示的リンクを使用して、必要な場合にのみ他の Dll を読み込むことができます。

- 明示的なリンクを使用すると、インポートライブラリを使用してアプリケーションをリンクする必要がなくなります。 DLL 内の変更によってエクスポート序数が変更された場合、アプリケーションは、序数値ではなく関数名を使用して `GetProcAddress` を呼び出すと、再リンクを行う必要はありません。 暗黙的リンクを使用するアプリケーションは、変更されたインポートライブラリに再リンクする必要があります。

明示的リンクの欠点は、次の 2 つです。

- DLL に `DllMain` エントリポイント関数がある場合、オペレーティングシステムは `LoadLibrary`を呼び出したスレッドのコンテキストで関数を呼び出します。 `FreeLibrary` 関数への対応する呼び出しがない `LoadLibrary` を以前に呼び出したため、DLL が既にプロセスにアタッチされている場合、エントリポイント関数は呼び出されません。 `LoadLibrary` (または `AfxLoadLibrary`) が呼び出されたときに既に存在するすべてのスレッドが初期化されていないので、明示的なリンクによって問題が発生する可能性があります。これは、DLL が `DllMain` 関数を使用してプロセスの各スレッドを初期化する場合です。

- DLL が静的エクステントデータを `__declspec(thread)`として宣言している場合、明示的にリンクされていると、保護エラーが発生する可能性があります。 `LoadLibrary`の呼び出しによって DLL が読み込まれると、コードがこのデータを参照するたびに保護エラーが発生します。 (静的エクステントデータには、グローバルとローカルの両方の静的項目が含まれます)。そのため、DLL を作成するときは、スレッドローカルストレージを使用しないようにする必要があります。 そうでない場合は、dll を動的に読み込むことによって発生する可能性のある落とし穴について、DLL のユーザーに通知します。 詳細については、「[ダイナミックリンクライブラリでのスレッドローカルストレージの使用」 (Windows SDK)](/windows/win32/Dlls/using-thread-local-storage-in-a-dynamic-link-library)を参照してください。

<a name="linking-implicitly"></a>

## <a name="how-to-use-implicit-linking"></a>暗黙的リンクの使用方法

暗黙的なリンクによって DLL を使用するには、クライアントの実行可能ファイルが DLL のプロバイダーからこれらのファイルを取得する必要があります。

- DLL 内のエクスポートされたデータ、関数、およびC++クラスの宣言を含む1つまたは複数のヘッダーファイル (.h ファイル)。 DLL によってエクスポートされたクラス、関数、およびデータはすべて、ヘッダーファイルで `__declspec(dllimport)` としてマークされている必要があります。 詳細については、「[dllexport、dllimport](../cpp/dllexport-dllimport.md)」をご覧ください。

- 実行可能ファイルにリンクするインポートライブラリ。 リンカーは、DLL のビルド時にインポートライブラリを作成します。 詳細については、「[リンカー入力としての LIB ファイル](reference/dot-lib-files-as-linker-input.md)」を参照してください。

- 実際の DLL ファイル。

暗黙のリンクによって DLL 内のデータ、関数、およびクラスを使用するには、クライアントソースファイルに、それらを宣言するヘッダーファイルを含める必要があります。 コーディングの観点からは、エクスポートされた関数の呼び出しは、他の関数呼び出しとまったく同じです。

クライアント実行可能ファイルをビルドするには、DLL のインポートライブラリにリンクする必要があります。 外部メイクファイルまたはビルドシステムを使用する場合は、リンクする他のオブジェクトファイルまたはライブラリと共にインポートライブラリを指定します。

オペレーティング システムは、呼び出し実行形式の読み込み時に、DLL ファイルを配置できる必要があります。 つまり、アプリケーションをインストールするときに、DLL の存在を配置または確認する必要があります。

<a name="linking-explicitly"></a>

## <a name="how-to-link-explicitly-to-a-dll"></a>DLL に明示的にリンクする方法

明示的リンクによって DLL を使用するには、アプリケーションが実行時に DLL を明示的に読み込むために関数呼び出しを行う必要があります。 DLL と明示的にリンクするには、アプリケーションは、以下の手順を実行します。

- [LoadLibraryEx](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexw)または同様の関数を呼び出して、DLL を読み込み、モジュールハンドルを取得します。

- [GetProcAddress](getprocaddress.md)を呼び出して、アプリケーションが呼び出す各エクスポート関数への関数ポインターを取得します。 アプリケーションはポインターを使用して DLL 関数を呼び出すため、コンパイラは外部参照を生成しないため、インポートライブラリとリンクする必要はありません。 ただし、呼び出す関数の呼び出しシグネチャを定義する `typedef` または `using` ステートメントが必要です。

- DLL の終了時に[FreeLibrary](freelibrary-and-afxfreelibrary.md)を呼び出します。

たとえば、このサンプル関数は `LoadLibrary` を呼び出して "Mydll.dll" という名前の DLL を読み込み、`GetProcAddress` を呼び出して "DLLFunc1" という名前の関数へのポインターを取得し、関数を呼び出して結果を保存した後、`FreeLibrary` を呼び出して DLL をアンロードします。

```C
#include "windows.h"

typedef HRESULT (CALLBACK* LPFNDLLFUNC1)(DWORD,UINT*);

HRESULT LoadAndCallSomeFunction(DWORD dwParam1, UINT * puParam2)
{
    HINSTANCE hDLL;               // Handle to DLL
    LPFNDLLFUNC1 lpfnDllFunc1;    // Function pointer
    HRESULT hrReturnVal;

    hDLL = LoadLibrary("MyDLL");
    if (NULL != hDLL)
    {
        lpfnDllFunc1 = (LPFNDLLFUNC1)GetProcAddress(hDLL, "DLLFunc1");
        if (NULL != lpfnDllFunc1)
        {
            // call the function
            hrReturnVal = lpfnDllFunc1(dwParam1, puParam2);
        }
        else
        {
            // report the error
            hrReturnVal = ERROR_DELAY_LOAD_FAILED;
        }
        FreeLibrary(hDLL);
    }
    else
    {
        hrReturnVal = ERROR_DELAY_LOAD_FAILED;
    }
    return hrReturnVal;
}
```

この例とは異なり、ほとんどの場合、`LoadLibrary` を呼び出し、特定の DLL に対してアプリケーションで1回だけ `FreeLibrary` する必要があります。 DLL 内の複数の関数を呼び出したり、DLL 関数を繰り返し呼び出したりする場合は特にそうです。

## <a name="what-do-you-want-to-know-more-about"></a>さらに詳しくは次のトピックをクリックしてください

- [インポート ライブラリとエクスポート ファイル](reference/working-with-import-libraries-and-export-files.md)

- [ダイナミックリンクライブラリの検索順序](/windows/win32/Dlls/dynamic-link-library-search-order)

## <a name="see-also"></a>関連項目

[Visual Studio での C/C++ Dll の作成](dlls-in-visual-cpp.md)
