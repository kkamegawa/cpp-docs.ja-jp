---
title: 最適化のベスト プラクティス
ms.date: 11/04/2016
helpviewer_keywords:
- Visual C++, optimization
- optimization, best practices
ms.assetid: f3433148-7255-4ca6-8a4f-7c31aac88508
ms.openlocfilehash: da493ceb1a0b751e302d296a9840b668e446ff62
ms.sourcegitcommit: fe1e21df175cd004d21c6e4659082efceb649a8b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/02/2019
ms.locfileid: "53978336"
---
# <a name="optimization-best-practices"></a>最適化のベスト プラクティス

このドキュメントでは、Visual C++ での最適化に関する推奨事項について説明します。

## <a name="compiler-and-linker-options"></a>コンパイラとリンカーのオプション

### <a name="profile-guided-optimization"></a>プロファイル ガイド付き最適化

Visual C がサポート*プロファイル ガイド付き最適化の*(PGO)。 この最適化では、アプリケーションのインストルメントされたバージョンのトレーニング実行からのプロファイル データを使用して、アプリケーションの最適化を行います。 PGO を使用すると時間がかかる場合があるため、すべての状況に適しているとは言えません。しかし、製品の最終リリース ビルドには PGO を使用することをお勧めします。 詳細については、次を参照してください。[ガイド付き最適化の](../../build/reference/profile-guided-optimizations.md)します。

さらに、*プログラム全体の最適化*(リンク時コード生成も認識しています)、 **/O1**と **/O2**最適化が改善されました。 通常、これらのオプションのいずれかを指定してコンパイルしたアプリケーションの処理速度は、以前のコンパイラでコンパイルした同じアプリケーションよりも速くなります。

詳細については、次を参照してください。 [/GL (Whole Program Optimization)](../../build/reference/gl-whole-program-optimization.md)と[/O1、/O2 (サイズの最小化、速度の最大化)](../../build/reference/o1-o2-minimize-size-maximize-speed.md)します。

### <a name="which-level-of-optimization-to-use"></a>使用する最適化のレベル

可能な限り、最終リリース ビルドは、PGO を使用してコンパイルする必要があります。 インストルメント化されたビルドを実行するにはインフラストラクチャが不十分であることや、シナリオにアクセスできないことが原因で、PGO を使用してビルドできない場合は、プログラム全体の最適化を使用してビルドすることをお勧めします。

**/Gy**スイッチも非常に便利です。 このスイッチを使用すると、関数ごとに個別の COMDAT が生成されます。その結果、参照されていない COMDAT を取り除いたり COMDAT を圧縮したりでき、リンカーの柔軟性が向上します。 使用する唯一の欠点 **/Gy**はデバッグに問題が発生します。 重要な影響を受けるわけではないので、通常は、このスイッチを使用することをお勧めします。 詳細については、「[/Gy (関数レベルのリンクの有効化)](../../build/reference/gy-enable-function-level-linking.md)」を参照してください。

64 ビット環境でリンクを使用する推奨は、 **/OPT:REF、ICF**リンカー オプション、および 32 ビット環境で **/OPT:REF**をお勧めします。 詳細については、次を参照してください。 [/OPT (最適化)](../../build/reference/opt-optimizations.md)します。

また、デバッグ シンボルを生成することを強くお勧めします。これは、最適化されたリリース ビルドの場合も同様です。 生成されたコードに影響を与えないし、する必要は多くの場合、アプリケーションをデバッグしやすくなります。

### <a name="floating-point-switches"></a>浮動小数点のスイッチ

**/Op**コンパイラ オプションが削除されているし、浮動小数点の最適化を処理する次の 4 つのコンパイラ オプションが追加されました。

|||
|-|-|
|**/fp: 正確な**|既定で推奨されているオプションです。ほとんどの場合は、これを使用します。|
|**/fp:fast**|パフォーマンスが最も重要視される場合 (ゲームなど) に推奨されます。 このオプションを使用すると、パフォーマンスが最も高速になります。|
|**/fp: strict**|浮動小数点の例外に関して厳密な対応が必要な場合や、IEEE に沿った動作が必要な場合に推奨されます。 このオプションを使用すると、パフォーマンスが最も低速になります。|
|**/fp: except [-]**|組み合わせて使用できる **/fp: 厳密な**または **/fp: 正確な**、なく **/fp:fast**します。|

詳細については、「[/fp (浮動小数点の動作の指定)](../../build/reference/fp-specify-floating-point-behavior.md)」を参照してください。

## <a name="optimization-declspecs"></a>最適化の declspec

このセクションでは、パフォーマンスを改善するためにプログラム内で使用できる、`__declspec(restrict)` および `__declspec(noalias)` という 2 つの declspec について説明します。

`restrict` declspec は、`__declspec(restrict) void *malloc(size_t size);` など、ポインターを返す関数宣言のみに適用できます。

`restrict` declspec は、エイリアスを使用しないポインターを返す関数で使用されます。 このキーワードは、現在のプログラムで既に使用されているポインター値を返さないため、解放済みのメモリを使用するなどの無効な操作を行う場合を除いて、C ランタイム ライブラリの `malloc` の実装に使用できます。

`restrict` declspec は、コンパイラが最適化を実行するための詳細情報をコンパイラに伝えます。 コンパイラにとって最も困難なことの 1 つは、どのポインターが他のポインターのエイリアスとなっているかを判断することですが、その際、この詳細情報はコンパイラにとって非常に役立ちます。

この情報はコンパイラでは前提とされ、コンパイラが検証することはありません。 プログラムでこの `restrict` declspec を不適切に使用すると、プログラムが不正な動作をするおそれがあります。

詳細については、次を参照してください。[制限](../../cpp/restrict.md)します。

また、`noalias` declspec も関数だけに適用され、その関数が準純粋関数であることを示します。 準純粋関数は、ローカル、引数、引数の第 1 レベルの間接参照だけを参照または変更する関数です。 この declspec はコンパイラでは前提とされます。準純粋関数がグローバル、またはポインター引数の第 2 レベルを間接参照する場合、コンパイラが生成するコードはアプリケーションを中断させる可能性があります。

詳細については、「[noalias](../../cpp/noalias.md)」を参照してください。

## <a name="optimization-pragmas"></a>最適化のプラグマ

コードを最適化する際に有用なプラグマもいくつかあります。 最初に、`#pragma optimize` について説明します。

```cpp
#pragma optimize("{opt-list}", on | off)
```

このプラグマを使用すると、関数ごとに特定の最適化レベルを設定できます。 このプラグマは、特定の関数を最適化してコンパイルするとアプリケーションがクラッシュするという特殊な状況に適しています。 このプラグマを使用すると、1 つの関数の最適化を無効にできます。

```cpp
#pragma optimize("", off)
int myFunc() {...}
#pragma optimize("", on)
```

詳細については、次を参照してください。[最適化](../../preprocessor/optimize.md)します。

コンパイラで実行する最適化のうち、最も重要な最適化の 1 つにインライン展開があります。ここでは、インライン展開の動作を変更できるプラグマをいくつか紹介します。

`#pragma inline_recursion` は、アプリケーションで再帰呼び出しをインライン展開できるようにするかどうかを指定する場合に役立ちます。 既定では、インライン展開は無効になっています。 関数が小さく、再帰の数が少ない場合は、このプラグマを有効にできます。 詳細については、次を参照してください。 [inline_recursion](../../preprocessor/inline-recursion.md)します。

インライン展開の深さを制限する場合に役立つ別のプラグマとして、`#pragma inline_depth` があります。 このプラグマは通常、プログラムまたは関数のサイズを制限する場合に役立ちます。 詳細については、次を参照してください。 [inline_depth](../../preprocessor/inline-depth.md)します。

## <a name="restrict-and-assume"></a>_ _restrict と\__assume

パフォーマンスに役立つ Visual C のキーワードのいくつか: [_ _restrict](../../cpp/extension-restrict.md)と[_assume](../../intrinsics/assume.md)します。

まず、`__restrict` と `__declspec(restrict)` が異なるものであることに注意する必要があります。 この 2 つのキーワードは多少関連がありますが、意味が異なります。 `__restrict` は、`const` や `volatile` のような型修飾子ですが、ポインター型に対してのみ使用できます。

変更されたポインター`__restrict`と呼ばれますが、 *_ _restrict ポインター*します。 _ _Restrict ポインターのポインターを介してのみアクセスできるは、 \__restrict ポインター。 つまり、によって示されるデータにアクセスする別のポインターを使用できません、 \__restrict ポインター。

`__restrict` は Visual C++ オプティマイザーにとって強力なツールになりますが、慎重に使用する必要があります。 誤って使用すると、オプティマイザーで最適化を実行した結果としてアプリケーションが破壊されることがあります。

`__restrict`キーワードに置き換えられます、 **/Oa**以前のバージョンから切り替えます。

`__assume`開発者がいくつかの変数の値に関する仮定をコンパイラに指示できます。

たとえば、`__assume(a < 5);` とすると、そのコード行では `a` 変数の値が 5 未満であることがオプティマイザーに伝えられます。 これも、コンパイラにとっての前提になります。 プログラム内のこの時点で `a` が実際には 6 である場合、コンパイラでプログラムを最適化すると、意図したとおりに動作しない可能性があります。 `__assume` は、switch ステートメントや条件式の前で使用するのが最も効果的です。

`__assume` には、いくつかの制約があります。 まず、このキーワードは `__restrict` と同様に推奨されているだけなので、コンパイラに無視される可能性があります。 また、`__assume` は、現在、変数を定数と比較する場合にのみ機能します。 assume(a < b) など、シンボルどうしの不等式には応用できません。

## <a name="intrinsic-support"></a>組み込みのサポート

組み込みとは、呼び出しに関する情報がコンパイラに組み込まれている関数呼び出しです。コンパイラはライブラリ内の関数を呼び出すのではなく、その関数のコードを出力します。 ヘッダー ファイル\<intrin.h > の各プラットフォームのサポートされているハードウェアの使用可能な組み込みのすべてが含まれています。

組み込みにより、プログラマは、アセンブリを使用しなくても深い部分までコーディングできます。 組み込みを使用することには、いくつかの利点があります。

- 使用しているコードの移植性が高まります。 組み込みのいくつかは、複数の CPU アーキテクチャで使用できます。

- コードは依然として C/C++ で記述されているため、簡単に理解できます。

- コードはコンパイラの最適化による恩恵を受けることができます。 コンパイラが進歩すると、組み込みのコード生成も進歩します。

詳細については、次を参照してください。[コンパイラ組み込み](../../intrinsics/compiler-intrinsics.md)します。

## <a name="exceptions"></a>例外

例外を使用すると、それによってパフォーマンスに影響があります。 コンパイラによる特定の最適化を防ぐ try ブロックを使用する場合に、いくつかの制限が導入されました。 x86 プラットフォームで try ブロックを使用すると、コードの実行時に追加のステータス情報を生成する必要があるために、パフォーマンスがさらに低下します。 64 ビット プラットフォームでは、try ブロックによってパフォーマンスが大きく低下することはありませんが、例外がスローされると、ハンドラーの検出とスタックのアンワインドの処理に負荷がかかります。

したがって、try ブロックと catch ブロックは、本当に必要である場合を除いて使用しないことをお勧めします。 例外を使用する必要がある場合は、できるだけ同期例外を使用してください。 詳細については、「 [Structured Exception Handling (C/C++)](../../cpp/structured-exception-handling-c-cpp.md)」を参照してください。

最後に、例外をスローするのは、例外の場合だけにしてください。 通常の制御フローに例外を使用すると、パフォーマンスが低下します。

## <a name="see-also"></a>関連項目

- [コードの最適化](../../build/reference/optimizing-your-code.md)
