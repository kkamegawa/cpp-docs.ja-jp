---
title: 装飾名
ms.date: 09/05/2018
helpviewer_keywords:
- decorated names, definition
- name decoration [C++]
- names [C++], decorated
ms.assetid: a4e9ae8e-b239-4454-b401-4102793cb344
ms.openlocfilehash: e3950f79c4c88d031e04d0d145e0a03c9ebc0a37
ms.sourcegitcommit: da32511dd5baebe27451c0458a95f345144bd439
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/07/2019
ms.locfileid: "65221794"
---
# <a name="decorated-names"></a>装飾名

C および C++ プログラム内の関数、データ、オブジェクトは、内部ではそれぞれの装飾名で表されます。 A*装飾名*でエンコードされた文字列オブジェクト、データ、または関数定義のコンパイル時に、コンパイラによって作成します。 これにより、呼び出し規約、型、関数のパラメーター、およびその他の情報が、名前と共に記録されます。 呼ばれるこの名前の装飾*名前マングル*、により、リンカーの適切な関数を検索および実行可能ファイルをリンクするときのオブジェクトします。

装飾の名前付け規則は、Visual Studio でのさまざまなバージョンが変更され、別のターゲット アーキテクチャで異なるも指定できます。 C、Visual Studio を使用して作成されたソース ファイルと正しくリンクしてC++同じコンパイラ ツールセット、フラグ、およびターゲット アーキテクチャを使用して Dll とライブラリをコンパイルする必要があります。 

> [!NOTE]
> Visual Studio 2015 でビルドされたライブラリは、Visual Studio 2017 または Visual Studio 2019 でビルドされたアプリケーションで使用できます。

##  <a name="Using"></a> 装飾名の使用

正常にコンパイルされ、リンクされるコードを記述するために、通常は装飾名を把握している必要はありません。 装飾名は、コンパイラおよびリンカー内部の実装の詳細です。 通常、ツールは非装飾形式の名前を処理できます。 ただし、リンカーやその他のツールに関数名を指定するときは、装飾名が必要な場合もあります。 たとえば、オーバーロードされた C++ 関数、名前空間のメンバー、クラス コンストラクター、デストラクターと、特殊メンバー関数を一致させるには、装飾名を指定する必要があります。 オプション フラグや、装飾名を必要とするその他の状況の詳細については、使用しているツールおよびオプションに関するドキュメントを参照してください。

関数名、クラス、呼び出し規約、戻り値の型、またはいずれかのパラメーターを変更する場合、装飾名も同様に変更されます。 この場合、新しい装飾名を取得し、それを装飾名が指定されているすべての場所で使用する必要があります。

名前の装飾は、他のプログラミング言語で記述されたコードにリンクする場合や、他のコンパイラを使用する場合にも重要です。 コンパイラによって、使用する名前装飾規約は異なります。 実行可能ファイルを別の言語で記述されたコードにリンクする場合、エクスポートおよびインポートされた名前と呼び出し規約を一致させるには、特別な配慮が必要です。 アセンブリ言語のコードでは、MSVC を使用して記述されたソース コードにリンクする、MSVC の装飾名と呼び出し規則を使用する必要があります。

##  <a name="Format"></a> 形式は、C++ の装飾名

C++ の関数の装飾名には、次の情報が含まれます。

- 関数名。

- 関数をメンバーに持つクラス (その関数がメンバー関数の場合)。 これには、関数を含むクラスの外側のクラスなども含まれます。

- 関数が属している名前空間 (その関数が名前空間の一部である場合)。

- 関数のパラメーターの型。

- 呼び出し規則

- 関数の戻り値の型。

装飾名では、関数とクラスの名前はエンコードされます。 装飾名の残りの部分は、コンパイラとリンカーに対してのみ内部的な意味を持つコードです。 C++ の非装飾名および装飾名の例を次に示します。

|非装飾名|装飾名|
|----------------------|--------------------|
|`int a(char){int i=3;return i;};`|`?a@@YAHD@Z`|
|`void __stdcall b::c(float){};`|`?c@b@@AAGXM@Z`|

##  <a name="FormatC"></a> 形式は、C の装飾名

C の関数の装飾形式は、次の表に示すように、その宣言で使用される呼び出し規則によって決まります。 これは、C++ のコードが `extern "C"` リンケージを持つように宣言されている場合に使用される装飾形式でも同様です。 既定の呼び出し規約は `__cdecl` です。 64 ビット環境では、関数は装飾されません。

|呼び出し規則|[装飾]|
|------------------------|----------------|
|`__cdecl`|先頭にアンダー スコア (**_**)|
|`__stdcall`|先頭にアンダー スコア (**_**)、末尾にサインオン (**\@**) 後に 10 進数のパラメーター リスト内のバイト数|
|`__fastcall`|先頭および末尾にアット マーク (**\@**) 後にパラメーター リスト内のバイト数を表す 10 進数|
|`__vectorcall`|2 つの末尾にアット マーク (**\@\@**) 後に、パラメーター リストのバイト数の 10 進数|

##  <a name="Viewing"></a> 装飾名の確認

データ、オブジェクト、関数定義、または関数プロトタイプを含むソース ファイルをコンパイルした後に、装飾形式のシンボル名を取得できます。 プログラム内の修飾名を確認するために、次のいずれかのメソッドを使用できます。

#### <a name="to-use-a-listing-to-view-decorated-names"></a>リスティング ファイルを使用して装飾名を確認するには

1. データ、オブジェクト、または関数の定義またはでプロトタイプを含むソース ファイルをコンパイルすることで、一覧を生成、[リスティング ファイルの種類](fa-fa-listing-file.md)アセンブリ コードとソース コードに設定するコンパイラ オプション (**/FAs**)。

   たとえば、入力`cl /c /FAs example.cpp`リスティング ファイルを生成する開発者コマンド プロンプトで example.asm します。

2. 結果として得られるリスティング ファイルから、先頭が PUBLIC で、末尾にはセミコロンと非装飾のデータまたは関数名が続く行を見つけます。 PUBLIC とセミコロンの間にあるシンボルが、装飾名です。

#### <a name="to-use-dumpbin-to-view-decorated-names"></a>DUMPBIN を使用して装飾名を確認するには

1. .Obj または .lib ファイルにエクスポートされたシンボルを表示するには、次のように入力します。 `dumpbin /symbols` `objfile`開発者コマンド プロンプトでします。

2. 装飾形式のシンボルを見つけるには、かっこに囲まれた非装飾名を探します。 装飾名はパイプの後に、同じ行には (&#124;) 文字と非装飾名の前にします。

##  <a name="Undecorated"></a> 装飾されていない表示名

undname.exe を使用すると、装飾名を非装飾形式に変換できます。 変換の動作を次の例に示します。

```
C:\>undname ?func1@a@@AAEXH@Z
Microsoft (R) C++ Name Undecorator
Copyright (C) Microsoft Corporation. All rights reserved.

Undecoration of :- "?func1@a@@AAEXH@Z"
is :- "private: void __thiscall a::func1(int)"
```

## <a name="see-also"></a>関連項目

[追加の MSVC ビルド ツール](c-cpp-build-tools.md)<br/>
[extern を使用したリンケージの指定](../../cpp/using-extern-to-specify-linkage.md)
