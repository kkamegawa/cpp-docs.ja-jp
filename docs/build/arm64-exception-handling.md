---
title: ARM64 例外処理
description: ARM64 で windows によって使用される例外処理規則およびデータについて説明します。
ms.date: 11/19/2018
ms.openlocfilehash: 2304c04c5e9be31299e30bb48771f7c9777d1cd5
ms.sourcegitcommit: b9aaaebe6e7dc5a18fe26f73cc7cf5fce09262c1
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/20/2020
ms.locfileid: "77504484"
---
# <a name="arm64-exception-handling"></a>ARM64 例外処理

Windows on ARM64 では、ハードウェアによって生成される非同期例外と、ソフトウェアによって生成される同期例外に対して、同じ構造化例外処理機構を使用します。 言語固有の例外ハンドラーは、言語ヘルパー関数を使用することで、Windows 構造化例外処理に付加して構築します。 このドキュメントでは、ARM64 上の Windows での例外処理、および Microsoft ARM アセンブラーと MSVC コンパイラによって生成されるコードで使用される言語ヘルパーについて説明します。

## <a name="goals-and-motivation"></a>目標と動機

例外アンワインドデータ規則およびこの説明は、次のことを目的としています。

1. すべてのケースでコードプローブを使用しないアンワインドを可能にするために、十分な説明を提供します。

   - コードを分析するには、コードがページングされている必要があります。 これにより、(トレース、サンプリング、デバッグ) が役に立つ状況ではアンワインドができなくなります。

   - コードの分析は複雑です。コンパイラは、アンワインダーがデコードできる命令だけを生成するように注意する必要があります。

   - アンワインドコードを使用してアンワインドを完全に記述できない場合、場合によっては命令のデコードに戻る必要があります。 これにより、全体的な複雑さが増します。また、この方法は避けることをお勧めします。

1. 中程度のプロローグと中でアンワインドをサポートします。

   - アンワインドは、例外処理よりも多くの Windows で使用されます。 プロローグまたはエピローグコードシーケンスの途中であっても、コードを正確にアンワインドできることが重要です。

1. 容量を最小限にします。

   - アンワインドコードは、バイナリサイズを大幅に増やすために集計することはできません。

   - アンワインドコードはメモリ内でロックされる可能性が高いため、フットプリントが小さいと、読み込まれた各バイナリのオーバーヘッドが最小限に抑えられます。

## <a name="assumptions"></a>前提条件

これらの前提は、例外処理の説明で作成されます。

1. Prologs とエピローグは互いにミラー化される傾向があります。 この共通の特徴を利用することで、アンワインドを記述するために必要なメタデータのサイズを大幅に削減できます。 関数の本体内では、プロローグの演算が元に戻されるかどうか、またはエピローグの演算が順方向で実行されるかどうかは関係ありません。 両方の場合で同じ結果となります。

1. 関数は、全体を比較的小さくする傾向があります。 領域の最適化には、データの最も効率的なパッキングを実現するために、この事実に依存するものがあります。

1. エピローグに条件付きコードはありません。

1. 専用フレームポインターレジスタ: sp がプロローグ内の別のレジスタ (x29) に保存されている場合、そのレジスタは関数全体にとどまります。 これは、元の sp がいつでも復旧できることを意味します。

1. Sp を別のレジスタに保存しない限り、スタックポインターのすべての操作は、プロローグとエピローグ内で厳密に行われます。

1. スタックフレームのレイアウトは、次のセクションで説明するように構成されています。

## <a name="arm64-stack-frame-layout"></a>ARM64 スタックフレームのレイアウト

![スタックフレームのレイアウト](media/arm64-exception-handling-stack-frame.png "スタック フレームのレイアウト")

フレームチェーン関数の場合、fp と lr のペアは、最適化の考慮事項に応じて、ローカル変数領域内の任意の位置に保存できます。 目標は、フレームポインター (x29) またはスタックポインター (sp) に基づく1つの命令によって到達できるローカルの数を最大化することです。 ただし `alloca` 関数の場合は、それを連結する必要があり、x29 はスタックの一番下を指す必要があります。 レジスタペアのアドレス指定モードのカバレッジを向上させるために、不揮発性レジスタの保存領域がローカル領域スタックの最上位に配置されます。 ここでは、最も効率的なプロローグシーケンスをいくつか紹介します。 明確でキャッシュの局所性を向上させるために、呼び出し先に保存されたレジスタをすべての標準プロローグに格納する順序は、"拡大" しています。 次の `#framesz` は、スタック全体のサイズを表します (alloca area を除く)。 `#localsz` と `#outsz` は、それぞれローカル領域のサイズ (\<x29、lr > ペアの保存領域を含む)、および出力パラメーターのサイズを表します。

1. チェーン、#localsz \<= 512

    ```asm
        stp    x19,x20,[sp,#-96]!        // pre-indexed, save in 1st FP/INT pair
        stp    d8,d9,[sp,#16]            // save in FP regs (optional)
        stp    x0,x1,[sp,#32]            // home params (optional)
        stp    x2,x3,[sp,#48]
        stp    x4,x5,[sp,#64]
        stp    x6,x7,[sp,#72]
        stp    x29,lr,[sp,#-localsz]!   // save <x29,lr> at bottom of local area
        mov    x29,sp                   // x29 points to bottom of local
        sub    sp,sp,#outsz             // (optional for #outsz != 0)
    ```

1. チェーン、#localsz > 512

    ```asm
        stp    x19,x20,[sp,#-96]!        // pre-indexed, save in 1st FP/INT pair
        stp    d8,d9,[sp,#16]            // save in FP regs (optional)
        stp    x0,x1,[sp,#32]            // home params (optional)
        stp    x2,x3,[sp,#48]
        stp    x4,x5,[sp,#64]
        stp    x6,x7,[sp,#72]
        sub    sp,sp,#(localsz+outsz)   // allocate remaining frame
        stp    x29,lr,[sp,#outsz]       // save <x29,lr> at bottom of local area
        add    x29,sp,#outsz            // setup x29 points to bottom of local area
    ```

1. チェーン解除、リーフ関数 (lr 未保存)

    ```asm
        stp    x19,x20,[sp,#-80]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    x21,x22,[sp,#16]
        str    x23,[sp,#32]
        stp    d8,d9,[sp,#40]           // save FP regs (optional)
        stp    d10,d11,[sp,#56]
        sub    sp,sp,#(framesz-80)      // allocate the remaining local area
    ```

   すべてのローカルは、SP に基づいてアクセスされます。 \<x29、lr > は前のフレームを指します。 フレームサイズ \<= 512 の場合、"sub sp,..."regs に保存された領域をスタックの一番下に移動した場合は、最適化できます。 欠点は、上記の他のレイアウトと一致しないことと、保存されている regs が regs と、インデックス付きオフセットアドレス指定モードの範囲の一部であることです。

1. 非チェーン型の非リーフ関数 (lr は保存された Int 領域に保存されます)

    ```asm
        stp    x19,x20,[sp,#-80]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    x21,x22,[sp,#16]         // ...
        stp    x23,lr,[sp,#32]          // save last Int reg and lr
        stp    d8,d9,[sp,#48]           // save FP reg-pair (optional)
        stp    d10,d11,[sp,#64]         // ...
        sub    sp,sp,#(framesz-80)      // allocate the remaining local area
    ```

   または、偶数の数値を保存した場合は、

    ```asm
        stp    x19,x20,[sp,#-80]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    x21,x22,[sp,#16]         // ...
        str    lr,[sp,#32]              // save lr
        stp    d8,d9,[sp,#40]           // save FP reg-pair (optional)
        stp    d10,d11,[sp,#56]         // ...
        sub    sp,sp,#(framesz-80)      // allocate the remaining local area
    ```

   保存された x19 のみ:

    ```asm
        sub    sp,sp,#16                // reg save area allocation*
        stp    x19,lr,[sp]              // save x19, lr
        sub    sp,sp,#(framesz-16)      // allocate the remaining local area
    ```

   事前にインデックス化された lr stp はアンワインドコードで表すことができないため、reg 保存領域の割り当ては、stp には折りたたまれません。 \*

   すべてのローカルは、SP に基づいてアクセスされます。 \<x29 > は、前のフレームを指します。

1. チェーン、#framesz \<= 512、#outsz = 0

    ```asm
        stp    x29,lr,[sp,#-framesz]!       // pre-indexed, save <x29,lr>
        mov    x29,sp                       // x29 points to bottom of stack
        stp    x19,x20,[sp,#(framesz-32)]   // save INT pair
        stp    d8,d9,[sp,#(framesz-16)]     // save FP pair
    ```

   上記の最初のプロローグの例と比較して、ここでの利点は、すべての登録保存命令が1つのスタック割り当て命令の後に実行できるようになることです。 つまり、命令レベルの並列化を妨げる sp への不正な依存はありません。

1. チェーン、フレームサイズ > 512 (alloca のない関数の場合は省略可能)

    ```asm
        stp    x29,lr,[sp,#-80]!            // pre-indexed, save <x29,lr>
        stp    x19,x20,[sp,#16]             // save in INT regs
        stp    x21,x22,[sp,#32]             // ...
        stp    d8,d9,[sp,#48]               // save in FP regs
        stp    d10,d11,[sp,#64]
        mov    x29,sp                       // x29 points to top of local area
        sub    sp,sp,#(framesz-80)          // allocate the remaining local area
    ```

   最適化のために、x29 をローカル領域内の任意の位置に配置することで、"reg ペア" とインデックス付きのオフセットアドレス指定モードのより優れたカバレッジを実現できます。 フレームポインターの下にあるローカルは、SP に基づいてアクセスできます。

1. > Alloca () の有無にかかわらず、チェーン、フレームサイズは4K です。

    ```asm
        stp    x29,lr,[sp,#-80]!            // pre-indexed, save <x29,lr>
        stp    x19,x20,[sp,#16]             // save in INT regs
        stp    x21,x22,[sp,#32]             // ...
        stp    d8,d9,[sp,#48]               // save in FP regs
        stp    d10,d11,[sp,#64]
        mov    x29,sp                       // x29 points to top of local area
        mov    x15,#(framesz/16)
        bl     __chkstk
        sub    sp,sp,x15,lsl#4              // allocate remaining frame
                                            // end of prolog
        ...
        sub    sp,sp,#alloca                // more alloca() in body
        ...
                                            // beginning of epilog
        mov    sp,x29                       // sp points to top of local area
        ldp    d10,d11,[sp,#64]
        ...
        ldp    x29,lr,[sp],#80              // post-indexed, reload <x29,lr>
    ```

## <a name="arm64-exception-handling-information"></a>ARM64 例外処理情報

### <a name="pdata-records"></a>pdata レコード

Pdata レコードは、PE バイナリ内のすべてのスタック操作関数を記述する固定長項目の順序付けられた配列です。 "スタック操作" という語句は重要であり、ローカルストレージを必要とせず、非揮発性レジスタを保存/復元する必要がないリーフ関数は、pdata レコードを必要としません。 これらのレコードは、スペースを節約するために明示的に省略する必要があります。 これらの関数のいずれかからアンワインドすると、LR から直接戻り先アドレスを取得し、呼び出し元に移動できます。

ARM64 の各 pdata レコードの長さは8バイトです。 各レコードの一般的な形式では、最初の単語の先頭にある関数の32ビット RVA、.xdata ブロックへのポインターを含む2番目の単語、または正規関数アンワインドシーケンスを記述したパックされた単語が配置されます。

![pdata レコードのレイアウト](media/arm64-exception-handling-pdata-record.png "pdata レコードのレイアウト")

フィールドは次のとおりです。

- **関数の開始 rva**は、関数の開始の32ビット rva です。

- **Flag**は、2番目の pdata の残りの30ビットを解釈する方法を示す2ビットフィールドです。 **フラグ**が0の場合、残りのビットは**例外情報 RVA**を形成します (2 つの最下位ビットが暗黙的に0になります)。 **フラグ**が0以外の場合、残りのビットは、パックされた**アンワインドデータ**構造体を形成します。

- **例外情報 RVA**は、.xdata セクションに格納されている可変長例外情報構造体のアドレスです。 このデータは、4 バイトでアラインされている必要があります。

- パックされた**アンワインドデータ**は、正規の形式を想定して、関数からのアンワインドに必要な操作の圧縮された説明です。 この場合、.xdata レコードは必要ありません。

### <a name="xdata-records"></a>.xdata レコード

パックされたアンワインド形式では関数のアンワインドの記述に十分でない場合、可変長の .xdata レコードを作成する必要があります。 このレコードのアドレスは、.pdata レコードの第 2 ワードに格納されています。 .Xdata の形式は、パックされた可変長の単語のセットです。

![.xdata レコードのレイアウト](media/arm64-exception-handling-xdata-record.png ".xdata レコードのレイアウト")

このデータは、次の4つのセクションに分かれています。

1. 構造体の全体のサイズを記述し、キー関数のデータを提供する、1または2語のヘッダー。 2番目の単語は、**エピローグカウント**と**コード単語**の両方のフィールドが0に設定されている場合にのみ存在します。 ヘッダーには、次のビットフィールドがあります。

   a. **関数の長さ**は18ビットのフィールドです。 関数の合計長を4で割った値をバイト単位で示します。 関数が1M を超える場合は、複数の pdata および .xdata レコードを使用して関数を記述する必要があります。 詳細については、「 [Large functions](#large-functions) 」セクションを参照してください。

   b. **は2ビットフィールドです。** これは、残りの .xdata のバージョンを表します。 現時点では、バージョン0のみが定義されているため、1-3 の値は使用できません。

   c. **X**は1ビットフィールドです。 例外データの存在 (1) または欠勤 (0) を示します。

   d. **E**は1ビットのフィールドです。 これは、1つのエピローグを記述する情報がヘッダー (1) にパックされることを示します。これは、後で追加のスコープワードを必要としません (0)。

   e. **エピローグカウント**は、 **E**ビットの状態に応じて2つの意味を持つ5ビットフィールドです。

      1. **E**が0の場合は、セクション2で説明されているエピローグスコープの合計数を指定します。 関数に31を超えるスコープが存在する場合は、 **[コード単語]** フィールドを0に設定して、拡張機能の単語が必要であることを示す必要があります。

      2. **E**が1の場合、このフィールドは、1つだけを記述し、エピローグを示す最初のアンワインドコードのインデックスを指定します。

   f. **コードワード**は、セクション3のすべてのアンワインドコードを格納するために必要な32ビットワードの数を指定する5ビットフィールドです。 31を超える単語が必要な場合 (つまり、アンワインドコードバイトが124を超える場合)、このフィールドは0である必要があります。これは、拡張機能の単語が必要であることを示します。

   g. 拡張された**エピローグカウント**と**拡張コードワード**はそれぞれ、16ビットフィールドと8ビットフィールドです。 非常に多くのエピローグをエンコードするための領域、またはアンワインドコードワードの数が非常に多いことを示します。 これらのフィールドを含む拡張機能の単語は、最初のヘッダーワードの**エピローグカウント**と**コード単語**の両方のフィールドが0の場合にのみ存在します。

1. **エピローグカウント**が0でない場合、エピローグスコープについての情報の一覧 (パック 1) は、ヘッダーと省略可能な拡張ヘッダーの後に表示されます。 これらは、開始オフセットが増加する順に格納されています。 各スコープには、次のビットが含まれます。

   a. **エピローグ開始オフセット**は、関数の開始を基準とするエピローグのオフセット (バイト単位) を4で割った18ビットフィールドです。

   b. **Res**は、将来の拡張のために予約された4ビットのフィールドです。 この値は 0 である必要があります。

   c. **エピローグ開始インデックス**は10ビットフィールド (**拡張コードワード**よりも2ビット) です。 このは、このエピローグを記述する最初のアンワインドコードのバイトインデックスを示します。

1. エピローグスコープの一覧は、アンワインドコードを含むバイト配列になります。詳細については、後のセクションで詳しく説明します。 この配列は、最も近いフルワード境界の末尾に埋め込まれます。 アンワインドコードは、この配列に書き込まれます。 関数の本体に最も近いものから開始し、関数の端に向かって移動します。 各アンワインドコードのバイトはビッグエンディアン順に格納されるので、最初に最も重要なバイトから順にフェッチできます。これにより、操作と残りのコードの長さが識別されます。

1. 最後に、アンワインドコードバイトの後、ヘッダーの**X**ビットが1に設定されている場合、は例外ハンドラー情報を取得します。 これは、例外ハンドラー自体のアドレスを提供する単一の**例外ハンドラー RVA**で構成されます。 その直後に、例外ハンドラーに必要な可変長のデータが続きます。

.Xdata レコードは、最初の8バイトをフェッチし、それを使用してレコードの完全なサイズを計算することができるように設計されています。これは、次のような可変サイズの例外データの長さを差し引いたものです。 次のコードスニペットは、レコードのサイズを計算します。

```cpp
ULONG ComputeXdataSize(PULONG *Xdata)
{
    ULONG EpilogScopes;
    ULONG Size;
    ULONG UnwindWords;

    if ((Xdata[0] >> 27) != 0) {
        Size = 4;
        EpilogScopes = (Xdata[0] >> 22) & 0x1f;
        UnwindWords = (Xdata[0] >> 27) & 0x0f;
    } else {
        Size = 8;
        EpilogScopes = Xdata[1] & 0xffff;
        UnwindWords = (Xdata[1] >> 16) & 0xff;
    }

    Size += 4 * EpilogScopes;
    Size += 4 * UnwindWords;
    if (Xdata[0] & (1 << 20)) {
        Size += 4;        // exception handler RVA
    }
    return Size;
}
```

プロローグと各エピローグにはアンワインドコードへの独自のインデックスがありますが、テーブルはそれらの間で共有されます。 すべてが同じコードを共有できるようにすることができます (一般的ではありません)。 (例については、「例」[セクションの](#examples)例2を参照してください)。この場合、コンパイラの作成者は特に、特定の関数のアンワインドコードの合計数を制限する255であるため、この場合は最適化する必要があります。

### <a name="unwind-codes"></a>アンワインドコード

アンワインドコードの配列は、プロローグの効果を元に戻す方法を正確に示すシーケンスのプールであり、操作を元に戻す必要がある順序で格納されます。 アンワインドコードは、バイトの文字列としてエンコードされた小さな命令セットと考えることができます。 実行が完了すると、呼び出し元の関数の戻り先アドレスは lr register に含まれます。 また、関数が呼び出されたときに、すべての非 volatile レジスタが値に復元されます。

例外が関数本体内でのみ発生することが保証され、プロローグまたはエピローグ内では発生しない場合は、1つのシーケンスだけが必要になります。 ただし、Windows のアンワインドモデルでは、部分的に実行されたプロローグまたはエピローグ内からコードをアンワインドできる必要があります。 この要件を満たすために、アンワインドコードは、プロローグとエピローグ内の関連する各オペコードに1:1 を明確にマップできるように、慎重に設計されています。 この設計には、いくつかの影響があります。

1. アンワインドコードの数をカウントすることによって、プロローグとエピローグの長さを計算することができます。

1. エピローグスコープの開始後に命令の数をカウントすることにより、同じ数のアンワインドコードをスキップできます。 次に、シーケンスの残りの部分を実行して、エピローグによって実行される部分的に実行されたアンワインドを完了できます。

1. プロローグの終了前に命令の数をカウントすることにより、同じ数のアンワインドコードをスキップできます。 その後、シーケンスの残りの部分を実行して、実行を完了したプロローグの部分のみを元に戻すことができます。

アンワインドコードは、次の表に従ってエンコードされます。 すべてのアンワインドコードは、大きなスタックを割り当てるものを除き、1バイト/2 バイトです。 完全には、アンワインドコードが21個あります。 各アンワインドコードは、プロローグ/エピローグ内の命令を1つだけマップし、部分的に実行されるプロローグとエピローグのアンワインドを可能にします。

|アンワインドコード|ビットと解釈|
|-|-|
|`alloc_s`|000xxxxx: サイズ \< 512 (2 ^ 5 * 16) の小さいスタックを割り当てます。|
|`save_r19r20_x`|    001zzzzz: \<x19、x20 > pair を `[sp-#Z*8]!`に保存し、インデックスが作成されたオフセット > =-248 |
|`save_fplr`|        01zzzzzz: \<x29、lr > pair を `[sp+#Z*8]`、offset \<= 504 に保存します。 |
|`save_fplr_x`|        10zzzzzz: \<x29、lr > pair を `[sp-(#Z+1)*8]!`に保存し、インデックスが作成されたオフセット > =-512 |
|`alloc_m`|        11000xxx' xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx: サイズ \< 16k (2 ^ 11 * 16) の大きなスタックを割り当てます。 |
|`save_regp`|        110010xx'xxzzzzzz: x (19 + #X) ペアを `[sp+#Z*8]`、オフセット \<= 504 に保存します。 |
|`save_regp_x`|        110011xx'xxzzzzzz: ペアの x (19 + #X) `[sp-(#Z+1)*8]!`、インデックス番号が付けられたオフセット > =-512 |
|`save_reg`|        110100xx'xxzzzzzz: reg x (19 + #X) を `[sp+#Z*8]`、offset \<= 504 に保存します。 |
|`save_reg_x`|        1101010x'xxxzzzzz: reg x (19 + #X) を `[sp-(#Z+1)*8]!`、インデックス番号が付けられたオフセット > =-256 として保存します。 |
|`save_lrpair`|         1101011x'xxzzzzzz: save pair \<x (19 + 2 * #X)、lr > at `[sp+#Z*8]`、offset \<= 504 |
|`save_fregp`|        1101100x'xxzzzzzz: ペア d (8 + #X) を `[sp+#Z*8]`、オフセット \<= 504 に保存します。 |
|`save_fregp_x`|        1101101x'xxzzzzzz: ペア d (8 + #X)、`[sp-(#Z+1)*8]!`、インデックス番号が付けられたオフセット > =-512 |
|`save_freg`|        1101110x'xxzzzzzz: reg d (8 + #X) を `[sp+#Z*8]`、offset \<= 504 に保存します。 |
|`save_freg_x`|        11011110 ' xxxzzzzz: `[sp-(#Z+1)*8]!`での reg d (8 + #X) の保存、インデックスが作成されたオフセット > =-256 |
|`alloc_l`|         11100000 ' xxxxxxxx'xxxxxxxx'xxxxxxxx: サイズ \< 256 m (2 ^ 24 * 16) の大きなスタックを割り当てます |
|`set_fp`|        11100001: x29: を設定: `mov x29,sp` |
|`add_fp`|        11100010 ' xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx: set up x29 with: `add x29,sp,#x*8` |
|`nop`|            11100011: アンワインド操作は必要ありません。 |
|`end`|            11100100: アンワインドコードの終わりです。 エピローグの ret を意味します。 |
|`end_c`|        11100101: 現在のチェーンスコープのアンワインドコードの終わりです。 |
|`save_next`|        11100110: 次の非 volatile Int または FP レジスタペアを保存します。 |
|`arithmetic(add)`|    11100111 ' 000zxxxx: cookie reg (z) を lr (0 = x28, 1 = sp); に追加します。`add lr, lr, reg(z)` |
|`arithmetic(sub)`|    11100111 ' 001zxxxx: lr のサブ cookie reg (z) (0 = x28, 1 = sp);`sub lr, lr, reg(z)` |
|`arithmetic(eor)`|    11100111 ' 010zxxxx:/lr と cookie reg (z) (0 = x28, 1 = sp);`eor lr, lr, reg(z)` |
|`arithmetic(rol)`|    11100111 ' 0110xxxx: lr のシミュレートされた と cookie reg (x28);xip0 = neg x28;`ror lr, xip0` |
|`arithmetic(ror)`|    11100111 ' 100zxxxx: ror lr with cookie reg (z) (0 = x28, 1 = sp);`ror lr, lr, reg(z)` |
| |            11100111: xxxz----: ---- reserved |
| |              11101xxx: asm ルーチンに対してのみ生成されたカスタムスタックケースに対して予約されています |
| |              11101000: MSFT_OP_TRAP_FRAME のカスタムスタック |
| |              11101001: MSFT_OP_MACHINE_FRAME のカスタムスタック |
| |              11101010: MSFT_OP_CONTEXT のカスタムスタック |
| |              11101100: MSFT_OP_CLEAR_UNWOUND_TO_CALL のカスタムスタック |
| |              1111xxxx: 予約済み |

複数のバイトを含む大きな値を使用する手順では、最上位ビットが最初に格納されます。 この設計により、コードの最初のバイトだけを検索することで、アンワインドコードの合計サイズをバイト単位で検索できるようになります。 各アンワインドコードは、プロローグまたはエピローグ内の命令に厳密にマップされているため、プロローグまたはエピローグのサイズを計算できます。 シーケンスの先頭から末尾まで調べて、参照テーブルまたは類似のデバイスを使用して、対応するオペコードがどれだけの時間になるかを判断することができます。

プロローグ内では、インデックス付きのオフセットアドレス指定は許可されていません。 すべてのオフセット範囲 (#Z) は、`save_r19r20_x`を除く STP/STR アドレス指定のエンコーディングと一致します。これは、すべての保存領域 (10 Int レジスタ + 8 FP レジスタ + 8 入力レジスタ) に対して248が十分であることを示します。

`save_next` は、Int または FP 揮発性レジスタペアの保存に従う必要があります: `save_regp`、`save_regp_x`、`save_fregp`、`save_fregp_x`、`save_r19r20_x`、またはその他の `save_next`。 次のレジスタペアは、"拡大しています" 順序で次の16バイトスロットに保存されます。 `save_next` は、最後の Int レジスタペアを表す `save-next` の後に最初の FP レジスタペアを参照します。

通常の戻り値とジャンプ命令のサイズは同じであるため、末尾呼び出しのシナリオでは、分離された `end` アンワインドコードは必要ありません。

`end_c` は、最適化のために連続していない関数フラグメントを処理するように設計されています。 現在のスコープ内のアンワインドコードの末尾に、実際の `end`で終了した別の一連のアンワインドコードが続くことを示す `end_c`。 `end_c` と `end` 間のアンワインドコードは、親領域 ("ファントム" プロローグ) のプロローグ操作を表します。  詳細と例については、以下のセクションで説明します。

### <a name="packed-unwind-data"></a>パックしたアンワインドデータ

プロローグとエピローグが以下に示す正規の形式に従う関数の場合は、パックされたアンワインドデータを使用できます。 これにより、.xdata レコード全体が不要になり、アンワインドデータを提供するコストが大幅に削減されます。 標準のプロローグとエピローグは、単純な関数の共通要件を満たすように設計されています。1つは例外ハンドラーを必要とせず、セットアップと破棄操作を標準の順序で実行します。

パックされたアンワインドデータを含む pdata レコードの形式は次のようになります。

![パックされたアンワインドデータを含む pdata レコード](media/arm64-exception-handling-packed-unwind-data.png "パックされたアンワインドデータを含む pdata レコード")

フィールドは次のとおりです。

- **関数の開始 rva**は、関数の開始の32ビット rva です。
- **フラグ**は、前に説明した2ビットフィールドで、次の意味があります。
  - 00 = パックされたアンワインドデータは使用されません。残りのビットは、.xdata レコードをポイントします。
  - 01 = 1 つのプロローグで使用されるパックされたアンワインドデータと、スコープの先頭と末尾のエピローグ
  - 10 = プロローグとエピローグのないコードに使用される、パックされたアンワインドデータ。 個別の関数セグメントを記述する場合に便利です。
  - 11 = 予約済み。
- **関数の長さ**は、関数全体の長さ (バイト単位) を4で割った11ビットのフィールドです。 関数が8k よりも大きい場合は、.xdata レコードを使用する必要があります。
- **フレームサイズ**は、この関数に割り当てられているスタックのバイト数を16で割った値を表す9ビットフィールドです。 スタックを超える (8k バイト) バイトを割り当てる関数は、.xdata レコードを使用する必要があります。 ローカル変数領域、出力パラメーター領域、呼び出し先-保存された Int と FP 領域、およびホームパラメーター領域が含まれますが、動的割り当て領域は除外されます。
- **CR**は、関数にフレームチェーンと戻りリンクを設定するための追加命令が含まれているかどうかを示す2ビットフラグです。
  - 00 = チェーン化されていない関数、\<x29、lr > pair はスタックに保存されていません。
  - 01 = 連結されていない関数、\<lr > がスタックに保存されています
  - 10 = 予約済み。
  - 11 = チェーン関数。ストア/ロードペア命令は、プロローグ/エピローグ \<x29、lr で使用され >
- **H**は、関数が関数の先頭に格納することによって整数パラメーターレジスタ (x0 x 7) のホームにするかどうかを示す1ビットフラグです。 (0 = ホームレジスタ、1 = 自宅レジスタ)。
- **区分**は、標準のスタックの場所に保存された非 volatile 整数レジスタ (x19-x28) の数を示す4ビットフィールドです。
- **Regf**は、標準のスタック位置に保存された非 volatile FP レジスタ (d8 d15) の数を示す3ビットフィールドです。 (RegF = 0: FP レジスタは保存されません。RegF > 0: RegF + 1 FP レジスタが保存されます)。 パックされたアンワインドデータは、1つの FP レジスタだけを保存する関数には使用できません。

カテゴリ1、2 (送信パラメーターエリアなし) に分類される正規プロローグ、3および4は、パックされたアンワインド形式で表すことができます。  正規関数のエピローグは同様の形式に従います。ただし、 **H**は無効であり、`set_fp` 命令は省略され、各手順の手順と命令の順序はエピローグで逆になります。 .Xdata のアルゴリズムは、次の表に記載されている手順に従います。

手順 0: 各領域のサイズの事前計算

手順 1: Int 呼び出し先に保存されたレジスタを保存します。

手順 2: この手順は、前半のセクションの type 4 に固有です。 lr は、Int 領域の最後に保存されます。

手順 3: FP 呼び出し先を保存しました-保存されたレジスタ。

手順 4: ホームパラメーター領域に入力引数を保存します。

手順 5: 残りのスタックを割り当てます。これには、ローカル領域、\<x29、lr > のペア、および出力パラメーター領域が含まれます。 5a は正規型1に対応しています。 5b と5c は正規型2用です。 5d と5e は、type 3 と type 4 の両方を対象としています。

画面#|フラグの値|指示の数|オペコード|アンワインドコード
-|-|-|-|-
0|||`#intsz = RegI * 8;`<br/>`if (CR==01) #intsz += 8; // lr`<br/>`#fpsz = RegF * 8;`<br/>`if(RegF) #fpsz += 8;`<br/>`#savsz=((#intsz+#fpsz+8*8*H)+0xf)&~0xf)`<br/>`#locsz = #famsz - #savsz`|
1|0 <**区分**< = 10|区分/2 +**区分**%2|`stp x19,x20,[sp,#savsz]!`<br/>`stp x21,x22,[sp,#16]`<br/>`...`|`save_regp_x`<br/>`save_regp`<br/>`...`
2|**CR**= = 01 *|1|`str lr,[sp,#(intsz-8)]`\*|`save_reg`
3|0 < **Regf** < = 7|(RegF + 1)/2 +<br/>(RegF + 1) %2)|`stp d8,d9,[sp,#intsz]`\*\*<br/>`stp d10,d11,[sp,#(intsz+16)]`<br/>`...`<br/>`str d(8+RegF),[sp,#(intsz+fpsz-8)]`|`save_fregp`<br/>`...`<br/>`save_freg`
4|**H** = = 1|4|`stp x0,x1,[sp,#(intsz+fpsz)]`<br/>`stp x2,x3,[sp,#(intsz+fpsz+16)]`<br/>`stp x4,x5,[sp,#(intsz+fpsz+32)]`<br/>`stp x6,x7,[sp,#(intsz+fpsz+48)]`|`nop`<br/>`nop`<br/>`nop`<br/>`nop`
5a|**CR** = = 11 & & #locsz<br/> < = 512|2|`stp x29,lr,[sp,#-locsz]!`<br/>`mov x29,sp`\*\*\*|`save_fplr_x`<br/>`set_fp`
5b|**CR** = = 11 & &<br/>512 < #locsz <= 4080|3|`sub sp,sp,#locsz`<br/>`stp x29,lr,[sp,0]`<br/>`add x29,sp,0`|`alloc_m`<br/>`save_fplr`<br/>`set_fp`
5c|**CR** = = 11 & & #locsz > 4080|4|`sub sp,sp,4080`<br/>`sub sp,sp,#(locsz-4080)`<br/>`stp x29,lr,[sp,0]`<br/>`add x29,sp,0`|`alloc_m`<br/>`alloc_s`/`alloc_m`<br/>`save_fplr`<br/>`set_fp`
5d|(**Cr** = = 00 \|\| **cr**= = 01) & &<br/>#locsz < = 4080|1|`sub sp,sp,#locsz`|`alloc_s`/`alloc_m`
5e|(**Cr** = = 00 \|\| **cr**= = 01) & &<br/>#locsz > 4080|2|`sub sp,sp,4080`<br/>`sub sp,sp,#(locsz-4080)`|`alloc_m`<br/>`alloc_s`/`alloc_m`

\* **CR** = = 01 と**区分**が奇数の場合、手順 1. のステップ2と最後の save_rep は1つの save_regp にマージされます。

\*\***区分** == **CR** = = 0、および**Regf** ! = 0 の場合、浮動小数点の最初の stp は前置デクリメントを行います。

\*\*\* エピローグに `mov x29,sp` に対応する命令がありません。 関数で x29 から sp を復元する必要がある場合は、パックされたアンワインドデータを使用できません。

### <a name="unwinding-partial-prologs-and-epilogs"></a>部分プロローグとエピローグのアンワインド

最も一般的なアンワインドの状況は、例外または呼び出しが関数の本体で発生し、プロローグとすべてのエピローグから離れている状況です。 このような場合、アンワインドは簡単です。アンワインダーは、インデックス0から始まるアンワインド配列内のコードの実行を開始し、終了オペコードが検出されるまで続行します。

プロローグまたはエピローグの実行中に例外または割り込みが発生した場合は、適切にアンワインドする方が困難です。 このような状況では、スタックフレームが部分的に構築されるだけです。 問題は、何が行われたかを正確に特定することです。

たとえば、次のプロローグとエピローグシーケンスを使用します。

```asm
0000:    stp    x29,lr,[sp,#-256]!          // save_fplr_x  256 (pre-indexed store)
0004:    stp    d8,d9,[sp,#224]             // save_fregp 0, 224
0008:    stp    x19,x20,[sp,#240]           // save_regp 0, 240
000c:    mov    x29,sp                      // set_fp
         ...
0100:    mov    sp,x29                      // set_fp
0104:    ldp    x19,x20,[sp,#240]           // save_regp 0, 240
0108:    ldp    d8,d9,[sp,224]              // save_fregp 0, 224
010c:    ldp    x29,lr,[sp],#256            // save_fplr_x  256 (post-indexed load)
0110:    ret    lr                          // end
```

各オペコードの横には、この操作を説明する適切なアンワインドコードがあります。 プロローグの一連のアンワインドコードが、エピローグのアンワインドコードの正確なミラーイメージであることを確認できます (エピローグの最終命令をカウントしません)。 これは一般的な状況であり、プロローグのアンワインドコードがプロローグの実行順序と逆の順序で格納されていることを常に前提としています。

したがって、プロローグとエピローグの両方で、アンワインドコードの共通セットが残されています。

`set_fp`、`save_regp 0,240`、`save_fregp,0,224`、`save_fplr_x_256`、`end`

エピローグは通常の順序であるため簡単です。 エピローグ内のオフセット 0 (関数内のオフセット0x100 から開始) から開始すると、クリーンアップがまだ行われていないため、完全なアンワインドシーケンスが実行されることが予想されます。 (エピローグのオフセット 2) で1つの命令が見つかった場合、最初のアンワインドコードをスキップして、正常にアンワインドできます。 この状況を一般化し、オペコードとアンワインドコードの間に1:1 のマッピングを想定します。 次に、エピローグ内の命令*n*からアンワインドを開始するには、最初の*n 個*のアンワインドコードをスキップし、そこから実行を開始する必要があります。

これにより、逆の場合を除き、同じようなロジックがプロローグに対して機能することがわかります。 プロローグ内のオフセット0からアンワインドを開始する場合は、何も実行しません。 の1つの命令であるオフセット2からアンワインドする場合は、アンワインドシーケンスの実行を開始からアンワインドコードを1つ実行します。 (コードは逆の順序で格納されていることに注意してください)。ここでも一般化することができます。プロローグで命令 n からアンワインドを開始する場合は、コード一覧の末尾から n アンワインドコードの実行を開始する必要があります。

プロローグコードとエピローグコードが正確に一致するとは限りません。 そのため、アンワインド配列にはいくつかのコードシーケンスが含まれている必要があります。 コードの処理を開始する位置のオフセットを決定するには、次のロジックを使用します。

1. 関数の本体からアンワインドする場合は、インデックス0でアンワインドコードの実行を開始し、"end" オペコードを押すまで続行します。

1. エピローグ内からアンワインドする場合は、エピローグスコープで提供されるエピローグ固有の開始インデックスを開始点として使用します。 問題の PC がエピローグの先頭からのバイト数を計算します。 次に、アンワインドコードを前方に進め、既に実行されているすべての命令が考慮されるまでアンワインドコードをスキップします。 その後、その時点からを実行します。

1. プロローグ内からアンワインドする場合は、開始点として index 0 を使用します。 シーケンスからプロローグコードの長さを計算した後、問題のある PC がプロローグの終わりからのバイト数を計算します。 次に、アンワインドコードを前方に進め、未実行の命令がすべて考慮されるまでアンワインドコードをスキップします。 その後、その時点からを実行します。

これらのルールは、プロローグのアンワインドコードが常に配列内の最初のコードである必要があることを意味します。 また、これらは、本体内からのアンワインドの一般的なケースでアンワインドするために使用されるコードでもあります。 エピローグ固有のコードシーケンスは、の直後に記述する必要があります。

### <a name="function-fragments"></a>関数フラグメント

コードの最適化などの理由から、関数を分離されたフラグメント (リージョンとも呼ばれます) に分割することをお勧めします。 Split の場合、結果として得られる各関数フラグメントには、独自の pdata (および場合によっては .xdata) レコードが必要です。

独自のプロローグを持つ分離されたセカンダリフラグメントごとに、プロローグでスタック調整が行われないことが想定されています。 セカンダリリージョンに必要なすべてのスタック領域は、その親リージョン (またはホスト領域と呼ばれます) によって事前に割り当てられている必要があります。 これにより、スタックポインターの操作は、関数の元のプロローグで厳密に維持されます。

関数フラグメントの典型的な例としては、コンパイラによってコードの領域がホスト関数から移動されることがあります。 コードの分離によって発生する可能性のある異常なケースが3つあります。

#### <a name="example"></a>例

- (リージョン 1: 開始)

    ```asm
        stp     x29,lr,[sp,#-256]!      // save_fplr_x  256 (pre-indexed store)
        stp     x19,x20,[sp,#240]       // save_regp 0, 240
        mov     x29,sp                  // set_fp
        ...
    ```

- (リージョン 1: 終了)

- (リージョン 3: 開始)

    ```asm
        ...
    ```

- (リージョン 3: 終了)

- (リージョン 2: 開始)

    ```asm
        ...
        mov     sp,x29                  // set_fp
        ldp     x19,x20,[sp,#240]       // save_regp 0, 240
        ldp     x29,lr,[sp],#256        // save_fplr_x  256 (post-indexed load)
        ret     lr                      // end
    ```

- (リージョン 2: 終了)

1. プロローグのみ (region 1: すべてのエピローグが分離されたリージョンにあります):

   プロローグだけを記述する必要があります。 これは、pdata 形式では表現できません。 .Xdata の場合は、エピローグカウントを0に設定して表すことができます。 上の例の「region 1」を参照してください。

   アンワインドコード: `set_fp`、`save_regp 0,240`、`save_fplr_x_256`、`end`。

1. エピローグ only (region 2: プロローグはホストリージョンにあります)

   時間コントロールがこの領域に移動すると、すべてのプロローグコードが実行されていることが前提となります。 部分アンワインドは、通常の関数と同じようにエピローグで発生する可能性があります。 この種類の領域を圧縮して表すことはできません。 .Xdata レコードでは、"ファントム" プロローグを使用してエンコードし、`end_c` と `end` アンワインドコードペアで囲むことができます。  先頭の `end_c` は、プロローグのサイズが0であることを示します。 `set_fp`する1つのエピローグポイントのエピローグ開始インデックス。

   領域2のアンワインドコード: `end_c`、`set_fp`、`save_regp 0,240`、`save_fplr_x_256`、`end`。

1. プロローグまたはエピローグがありません (リージョン 3: プロローグとすべてのエピローグが他のフラグメントに含まれています):

   設定フラグ = 10 を使用して、より小さい形式を適用できます。 .Xdata レコードでは、エピローグカウント = 1 です。 アンワインドコードは上記のリージョン2のコードと同じですが、エピローグ開始インデックスも `end_c`を指しています。 部分アンワインドは、このコード領域では発生しません。

関数フラグメントのもう1つの複雑なケースとして、"圧縮ラッピング" があります。 コンパイラは、呼び出し先に保存されたレジスタの一部を関数エントリプロローグの外部に保存しないようにすることができます。

- (リージョン 1: 開始)

    ```asm
        stp     x29,lr,[sp,#-256]!      // save_fplr_x  256 (pre-indexed store)
        stp     x19,x20,[sp,#240]       // save_regp 0, 240
        mov     x29,sp                  // set_fp
        ...
    ```

- (リージョン 2: 開始)

    ```asm
        stp     x21,x22,[sp,#224]       // save_regp 2, 224
        ...
        ldp     x21,x22,[sp,#224]       // save_regp 2, 224
    ```

- (リージョン 2: 終了)

    ```asm
        ...
        mov     sp,x29                  // set_fp
        ldp     x19,x20,[sp,#240]       // save_regp 0, 240
        ldp     x29,lr,[sp],#256        // save_fplr_x  256 (post-indexed load)
        ret     lr                      // end
    ```

- (リージョン 1: 終了)

領域1のプロローグには、スタック領域が事前に割り当てられています。 リージョン2には、ホスト関数から移動しても、同じアンワインドコードがあることがわかります。

領域 1: `set_fp`、`save_regp 0,240`、`save_fplr_x_256``end`、エピローグ開始インデックスポイントを使用して、通常どおりに `set_fp` します。

領域 2: `save_regp 2, 224`、`end_c`、`set_fp`、`save_regp 0,240`、`save_fplr_x_256`、`end`。 エピローグ開始インデックスは、最初のアンワインドコード `save_regp 2, 224`を指します。

### <a name="large-functions"></a>大規模な関数

フラグメントを使用すると、.xdata ヘッダーのビットフィールドによって制限された1M を超える関数を記述できます。 このような非常に大きな関数を記述するには、1M より小さいフラグメントに分割する必要があります。 各フラグメントは、エピローグを複数の部分に分割しないように調整する必要があります。

関数の最初のフラグメントのみがプロローグを含みます。他のすべてのフラグメントは、プロローグがないとマークされています。 存在するエピローグの数によっては、各フラグメントに0個以上のエピローグが含まれる場合があります。 フラグメント内の各エピローグスコープは、関数の先頭ではなく、フラグメントの開始を基準とした開始オフセットを指定することに注意してください。

フラグメントにプロローグがなく、エピローグもない場合でも、関数本体内からアンワインドする方法を記述するために、独自の pdata (および .xdata) レコードが必要になります。

## <a name="examples"></a>例

### <a name="example-1-frame-chained-compact-form"></a>例 1: フレームチェーン、コンパクトな形式

```asm
|Foo|     PROC
|$LN19|
    str     x19,[sp,#-0x10]!        // save_reg_x
    sub     sp,sp,#0x810            // alloc_m
    stp     fp,lr,[sp]              // save_fplr
    mov     fp,sp                   // set_fp
                                    //  end of prolog
    ...

|$pdata$Foo|
    DCD     imagerel     |$LN19|
    DCD     0x416101ed
    ;Flags[SingleProEpi] functionLength[492] RegF[0] RegI[1] H[0] frameChainReturn[Chained] frameSize[2080]
```

### <a name="example-2-frame-chained-full-form-with-mirror-prolog--epilog"></a>例 2: フレームチェーン、完全な形式でミラープロローグを & エピローグ

```asm
|Bar|     PROC
|$LN19|
    stp     x19,x20,[sp,#-0x10]!    // save_regp_x
    stp     fp,lr,[sp,#-0x90]!      // save_fplr_x
    mov     fp,sp                   // set_fp
                                    // end of prolog
    ...
                                    // begin of epilog, a mirror sequence of Prolog
    mov     sp,fp
    ldp     fp,lr,[sp],#0x90
    ldp     x19,x20,[sp],#0x10
    ret     lr

|$pdata$Bar|
    DCD     imagerel     |$LN19|
    DCD     imagerel     |$unwind$cse2|
|$unwind$Bar|
    DCD     0x1040003d
    DCD     0x1000038
    DCD     0xe42291e1
    DCD     0xe42291e1
    ;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[6660]
    ;Epilog Start Index[0], Epilog Start Offset[56]
    ;set_fp
    ;save_fplr_x
    ;save_r19r20_x
    ;end
```

エピローグ開始インデックス [0] は、同じプロローグアンワインドコードのシーケンスを指しています。

### <a name="example-3-variadic-unchained-function"></a>例 3: 可変個引数アンチェーン関数

```asm
|Delegate| PROC
|$LN4|
    sub     sp,sp,#0x50
    stp     x19,lr,[sp]
    stp     x0,x1,[sp,#0x10]        // save incoming register to home area
    stp     x2,x3,[sp,#0x20]        // ...
    stp     x4,x5,[sp,#0x30]
    stp     x6,x7,[sp,#0x40]        // end of prolog
    ...
    ldp     x19,lr,[sp]             // beginning of epilog
    add     sp,sp,#0x50
    ret     lr

    AREA    |.pdata|, PDATA
|$pdata$Delegate|
    DCD     imagerel |$LN4|
    DCD     imagerel |$unwind$Delegate|

    AREA    |.xdata|, DATA
|$unwind$Delegate|
    DCD     0x18400012
    DCD     0x200000f
    DCD     0xe3e3e3e3
    DCD     0xe40500d6
    DCD     0xe40500d6
    ;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[18]
    ;Epilog Start Index[4], Epilog Start Offset[15]
    ;nop        // nop for saving in home area
    ;nop        // ditto
    ;nop        // ditto
    ;nop        // ditto
    ;save_lrpair
    ;alloc_s
    ;end
```

エピローグ開始インデックス [4] は、プロローグアンワインドコードの中間を指します (アンワインド配列を部分的に再利用します)。

## <a name="see-also"></a>参照

[ARM64 ABI 規則の概要](arm64-windows-abi-conventions.md)<br/>
[ARM 例外処理](arm-exception-handling.md)
