---
title: IEEE 浮動小数点表現
ms.date: 05/06/2019
helpviewer_keywords:
- float keyword
- real*8 value
- floating-point numbers, IEEE representation
- double data type, floating-point representation
- IEEE floating point representation
- real*10 value
- long double
- real*4 value
ms.assetid: 537833e8-fe05-49fc-8169-55fd0314b195
ms.openlocfilehash: de132dcf28747cd866229cff8972e2aed271a047
ms.sourcegitcommit: 9d4ffb8e6e0d70520a1e1a77805785878d445b8a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/20/2019
ms.locfileid: "69630355"
---
# <a name="ieee-floating-point-representation"></a>IEEE 浮動小数点表現

Microsoft C++ (MSVC) は、IEEE 数値標準に準拠しています。 IEEE-754 標準では、ハードウェアで実数を表す方法である浮動小数点形式について説明しています。 MSVC コンパイラの対象となるハードウェアで表現可能な浮動小数点数には、少なくとも5つの内部形式がありますが、コンパイラはこれらのうち2つのみを使用します。 MSVC では、*単精度*(4 バイト) と*倍精度*(8 バイト) の形式が使用されます。 単精度は、キーワード**float**を使用して宣言されます。 倍精度は、キーワード**double**を使用して宣言されます。 また、IEEE 規格では、*半精度*(2 バイト) 形式と*倍精度*(16 バイト) 形式が指定されています。また、一部の C とC++コンパイラは long として実装する、*倍精度浮動*小数点数 (10 バイト) の形式も指定します。 **double**データ型。 MSVC コンパイラでは、 **long double**データ型は個別の型として扱われますが、ストレージ型は**double**型にマップされます。 ただし、ハードウェアでサポートされている場合は、2つの拡張有効桁数 (10 バイト) 形式を含む、他の形式を使用した計算に対する組み込みおよびアセンブリ言語のサポートがあります。

値は次のように格納されます。

|値|格納|
|-----------|---------------|
|単精度 (single-precision)|符号ビット、8ビット指数、23ビット有効桁|
|倍精度|符号ビット、11ビット指数、52ビット有効桁|
|倍精度浮動小数点数|符号ビット、15ビット指数、64ビット有効桁|

単精度と倍精度の形式では、小数部の先頭が1であることを前提としています。これは、メモリに格納されていない*有効桁*(*仮数*とも呼ばれます) と呼ばれ、有効桁数は実際には24または53になります。ビットは、23または52ビットだけが格納されています。 倍精度浮動小数点形式は、実際にはこのビットを格納します。

指数は、可能な値の半分にバイアスされます。 これは、実際の指数を取得するために、格納されている指数からこのバイアスを減算することを意味します。 格納された指数がバイアスより小さい場合、実際には負の指数になります。

指数は次のようにバイアスされます。

|累乗|バイアス|
|--------------|---------------|
|8ビット (単精度)|127|
|11ビット (倍精度)|1023|
|15ビット (倍精度浮動小数点数)|16383|

これらの指数は10の累乗ではありません。2の累乗です。 つまり、8ビットの格納された指数は、-127 ~ 127 の範囲で、0 ~ 254 として格納されます。 値 2<sup>127</sup>は、単精度の実際の制限である 10<sup>38</sup>にほぼ相当します。

有効桁は、1.XXX という形式のバイナリ部分として格納されます。 この分数の値は1以上2未満です。 実数は常に正規化された*形式*で格納されることに注意してください。つまり、有効桁の上位ビットが常に1になるように、有効桁は左シフトされます。 このビットは常に1であるため、単精度と倍精度の両方の形式で (格納されていない) と見なされます。 二項 (10 進数ではない) ポイントは、先頭の1の右側にあるものと見なされます。

さまざまなサイズの場合、形式は次のようになります。

|Format|バイト1|バイト2|バイト3|バイト4|[...]|バイト n|
|------------|------------|------------|------------|------------|---------|------------|
|単精度 (single-precision)| `SXXXXXXX`|`XMMMMMMM`|`MMMMMMMM`|`MMMMMMMM`|||
|倍精度|`SXXXXXXX`|`XXXXMMMM`|`MMMMMMMM`|`MMMMMMMM`|[...]|`MMMMMMMM`|
|倍精度浮動小数点数|`SXXXXXXX`|`XXXXXXXX`|`1MMMMMMM`|`MMMMMMMM`|[...]|`MMMMMMMM`|

`S`は符号ビット`X`、はバイアスをかける指数ビット`M`、は有効桁ビットを表します。 左端のビットは単精度と倍精度の形式であることに注意してくださいが、倍精度浮動小数点形式のバイト3の "1" として指定されています。

バイナリポイントを適切にシフトするには、最初に指数部のバイアスを解除した後、適切なビット数になるようにバイナリポイントを右または左に移動します。

## <a name="special-values"></a>特別な値

浮動小数点形式には、特別に処理されるいくつかの値が含まれます。

### <a name="zero"></a>Zero

0を正規化することはできません。これにより、単精度または倍精度の値の正規化された形式では表現できなくなります。 すべてゼロの特殊ビットパターンは0を表します。 符号ビットが設定された0を0として表すこともできますが、-0 と0は常に等しいとして比較されます。

### <a name="infinities"></a>無限大

\+ ∞値と−∞値は、すべての指数とすべてゼロの有効桁で表されます。 正と負の両方の無限大は、符号ビットを使用して表すことができます。

### <a name="subnormals"></a>Subnormals

最小の正規化された数値よりも小さい数値を表すことができます。 これらの数値は、 *subnormal*または*denormal* numbers と呼ばれます。 指数部がすべてゼロで、有効桁が0以外の場合、有効桁の暗黙的な先頭ビットはゼロであり、1ではないと見なされます。 有効桁内の先頭の0の数が上がると、subnormal 数の精度が低下します。

### <a name="nan---not-a-number"></a>NaN-非数

IEEE 浮動小数点形式では、0/0 などの実数以外の値を表すことができます。 この種類の値は、 *NaN*と呼ばれます。 NaN は、すべての指数と0以外の有効桁で表されます。 Nan、 *quiet* Nan、QNaNs、*シグナリング*Nan、または snans の2種類があります。 Quiet Nan には、有効桁内に先頭の1があり、通常は式を通じて伝達されます。 これらは、無限大で除算した結果や、無限大を0で乗算した結果など、不確定な値を表します。 シグナリング Nan には、有効桁の先頭に0があります。 これらは、浮動小数点ハードウェア例外を通知するために、無効な操作に使用されます。

## <a name="examples"></a>使用例

単精度形式の例を次に示します。

- 値2の場合、符号ビットは0、格納された指数は128、または 127 + 1 のバイナリで 1000 0000。 格納されているバイナリ有効桁は (1) です。000 0000 0000 0000 0000 0000。暗黙的な先頭が1で、バイナリポイントがあるため、実際の有効桁は1になります。

   |値|[数式]|バイナリ表現|16 進数|
   |-|-|-|-|
   |2|1 * 2<sup>1</sup>|0100 0000 0000 0000 0000 0000 0000 0000|0x40000000|

- 値-2。 符号ビットが設定されている点を除いて、+ 2 と同じです。 これは、すべての IEEE 形式の浮動小数点数の負の値の場合に当てはまります。

   |値|[数式]|バイナリ表現|16 進数|
   |-|-|-|-|
   |-2|-1 * 2<sup>1</sup>|1100 0000 0000 0000 0000 0000 0000 0000|0xC0000000|

- 値4。 同じ有効桁、指数部は1ずつ増加します (バイアスされた値は129または 100 0000 1 (バイナリ)。

   |値|[数式]|バイナリ表現|16 進数|
   |-|-|-|-|
   |4|1 * 2<sup>2</sup>|0100 0000 1000 0000 0000 0000 0000 0000|0x40800000|

- 値6。 同じ指数、有効桁が半分の大きさになります。 (1)100 0000 ...0000 0000。これはバイナリの分数であるため、小数部の桁の値は1/2、1/4、1/8 などであるため、1 1/2 はです。

   |値|[数式]|バイナリ表現|16 進数|
   |-|-|-|-|
   |6|1.5 * 2<sup>2</sup>|0100 0000 1100 0000 0000 0000 0000 0000|0x40C00000|

- 値1。 2の他の累乗と同じ有効桁、バイアスをかける指数は、127の場合は2未満、バイナリの場合は 011 1111 1 になります。

   |値|[数式]|バイナリ表現|16 進数|
   |-|-|-|-|
   |1|1 * 2<sup>0</sup>|0011 1111 1000 0000 0000 0000 0000 0000|0x3F800000|

- 値0.75。 バイアスをかける指数は126、011 1111 0 はバイナリで、有効桁は (1) です。100 0000 ...0000 0000 (1 1/2)。

   |値|[数式]|バイナリ表現|16 進数|
   |-|-|-|-|
   |0.75|1.5 * 2<sup>-1</sup>|0011 1111 0100 0000 0000 0000 0000 0000|0x3F400000|

- 値2.5。 2とまったく同じですが、1/4 を表すビットが有効桁に設定されている点が異なります。

   |値|[数式]|バイナリ表現|16 進数|
   |-|-|-|-|
   |2.5|1.25 * 2<sup>1</sup>|0100 0000 0010 0000 0000 0000 0000 0000|0x40200000|

- 1/10 は、バイナリの繰り返しの分数です。 有効桁は1.6 のようなものであり、バイアスをかける指数は、1.6 が16で除算されることを示しています (これは、10進数の123であるバイナリでは 011 1101 1 です)。 実際の指数は 123-127 =-4 です。これは、乗算に使用する係数が 2<sup>-4</sup> = 1/16 であることを意味します。 格納されている有効桁が最後のビットで切り上げられていることに注意してください。表現できない数値を可能な限り正確に表現しようとします。 (1/10 と1/100 がバイナリで正確に表現できない理由は、1/3 が10進数で正確に表現できないという理由に似ています)。

   |値|[数式]|バイナリ表現|16 進数|
   |-|-|-|-|
   |0.1|1.6 * 2<sup>-4</sup>|0011 1101 1100 1100 1100 1100 1100 1101|0x3DCCCCCD|

- ゼロは、式を使用して表現可能な最小の正の値 (すべてゼロ) にする特殊なケースです。

   |値|[数式]|バイナリ表現|16 進数|
   |-|-|-|-|
   |0|1 * 2<sup>-128</sup>|0000 0000 0000 0000 0000 0000 0000 0000|0x00000000|

## <a name="see-also"></a>関連項目

[浮動小数点数の精度の低下](why-floating-point-numbers-may-lose-precision.md)