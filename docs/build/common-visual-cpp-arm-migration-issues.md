---
title: Visual C++ の ARM への移行に関する一般的な問題
ms.date: 05/06/2019
ms.assetid: 0f4c434e-0679-4331-ba0a-cc15dd435a46
ms.openlocfilehash: 518b8872b301a8fcfc0f154cb3d5d0299efb0975
ms.sourcegitcommit: 069e3833bd821e7d64f5c98d0ea41fc0c5d22e53
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/21/2019
ms.locfileid: "74303222"
---
# <a name="common-visual-c-arm-migration-issues"></a>Visual C++ の ARM への移行に関する一般的な問題

Microsoft C++コンパイラ (MSVC) を使用する場合、同じC++ソースコードでは、x86 または x64 アーキテクチャと比べて、ARM アーキテクチャで異なる結果が生成される可能性があります。

## <a name="sources-of-migration-issues"></a>移行に関する問題の原因

X86 または x64 アーキテクチャから ARM アーキテクチャにコードを移行するときに発生する可能性のある多くの問題は、未定義の、実装定義、または未指定の動作を呼び出す可能性があるソースコードの構造に関連しています。

*未定義の動作*は、 C++標準で定義されていない動作であり、妥当な結果を得られない演算 (浮動小数点値を符号なし整数に変換したり、負の数または昇格された型のビット数を超える位置によって値をシフトしたりするなど) によって発生します。

*実装で定義さ*れた動作はC++ 、標準では、コンパイラベンダーがとドキュメントを定義するために必要とする動作です。 プログラムは、実装によって定義された動作に安全に依存できます。ただし、移植できない場合もあります。 実装定義の動作の例としては、組み込みデータ型のサイズとその配置要件があります。 実装定義の動作によって影響を受ける可能性がある操作の例として、可変個引数リストへのアクセスがあります。

*指定*されていないC++動作とは、標準が意図的に非決定的なままになる動作のことです。 動作は非決定的であると見なされますが、特定できない動作の特定の呼び出しは、コンパイラの実装によって決まります。 ただし、コンパイラベンダーが結果を事前に決めたり、比較可能な呼び出し間での一貫した動作を保証したりする必要はありません。また、ドキュメントの要件はありません。 指定されていない動作の例として、関数呼び出しの引数を含むサブ式が評価される順序があります。

移行に関するその他の問題は、標準とは異なる方法で、 C++ ARM と x86 または x64 アーキテクチャのハードウェアの違いに起因する可能性があります。 たとえば、x86 および x64 アーキテクチャの強力なメモリモデルは、過去の特定の種類のスレッド間通信を容易にするために使用された追加のプロパティを `volatile`修飾変数に提供します。 ただし、ARM アーキテクチャの弱いメモリモデルでは、この使用がサポートさC++れていないため、標準では必要ありません。

> [!IMPORTANT]
>  `volatile` には、x86 と x64 でのスレッド間通信の制限された形式の実装に使用できるいくつかのプロパティがありますが、これらの追加のプロパティは、一般にスレッド間通信を実装するのに十分ではありません。 標準C++では、適切な同期プリミティブを使用して、そのような通信を実装することをお勧めします。

プラットフォームが異なれば、これらの種類の動作が異なる可能性があるため、プラットフォーム間でのソフトウェアの移植は困難であり、特定のプラットフォームの動作に依存するとバグが発生しやすくなります。 これらの種類の動作の多くは確認できますが、安定していると思われるかもしれませんが、それらに依存していると、少なくともポータブルではなく、未定義または未指定の動作の場合もエラーになります。 このドキュメントで説明されている動作は、依存しないようにする必要があり、将来のコンパイラまたは CPU 実装で変更される可能性があります。

## <a name="example-migration-issues"></a>移行に関する問題の例

このドキュメントの残りの部分では、これらC++の言語要素のさまざまな動作によって、さまざまなプラットフォームで異なる結果が生成されるしくみについて説明します。

### <a name="conversion-of-floating-point-to-unsigned-integer"></a>浮動小数点値から符号なし整数への変換

ARM アーキテクチャでは、浮動小数点値が32ビット整数に変換され、浮動小数点値が整数で表現できる範囲外の場合に、整数が表すことができる最も近い値になります。 X86 および x64 アーキテクチャでは、整数が符号なしである場合、または整数が符号付きの場合は-2147483648 に設定されます。 これらのアーキテクチャでは、浮動小数点値から小さい整数型への変換は直接サポートされていません。代わりに、変換は32ビットに対して実行され、結果は小さいサイズに切り捨てられます。

ARM アーキテクチャでは、鮮やかさと切り捨ての組み合わせにより、符号なしの型への変換によって32ビットの整数が生成されるときに、より小さな符号なしの型が正しく生成されますが、より大きい値については切り捨てられた結果が生成されることを意味します。小さい型は、完全な32ビット整数を表すことができますが、小さすぎる可能性があります。 変換は32ビット符号付き整数に対して正しく処理されますが、飽和状態の整数の切り捨ては、負の値の場合は-1、負の値の場合は0になります。 より小さな符号付き整数への変換では、予測できない切り捨て結果が生成されます。

X86 および x64 アーキテクチャでは、符号なし整数の変換と、オーバーフローにおける符号付き整数の変換についてのラップの組み合わせと、オーバーフローにおける符号付き整数変換の明示的な評価を組み合わせて使用します。大きすぎます。

これらのプラットフォームは、NaN (非数) から整数型への変換を処理する方法にも違いがあります。 ARM では、NaN は0x00000000 に変換されます。x86 と x64 では、0x80000000 に変換されます。

浮動小数点変換は、値が変換先の整数型の範囲内にあることがわかっている場合にのみ使用できます。

### <a name="shift-operator---behavior"></a>シフト演算子 (\<\< > >) の動作

ARM アーキテクチャでは、パターンの繰り返しを開始する前に値を左または右に255ビットまでシフトできます。 X86 および x64 アーキテクチャでは、パターンのソースが64ビットの変数でない限り、32のすべての倍数でパターンが繰り返されます。この場合、このパターンは、x64 では64のすべての倍数、x86 では256の倍数 (ソフトウェア実装が採用されている) で繰り返されます。 たとえば、値1が32で左にシフトされた32ビット変数の場合、ARM では結果は0になり、x86 では結果は1になります。 x64 の場合、結果は1になります。 ただし、値のソースが64ビットの変数の場合、3つのすべてのプラットフォームでの結果は4294967296になります。また、値は、x64 で64位置にシフトされるまで、または ARM と x86 上の256位置に移動するまで、"ラップされません" になります。

ソース型のビット数を超えるシフト演算の結果は未定義であるため、コンパイラはすべての状況で一貫した動作を行う必要はありません。 たとえば、シフトの両方のオペランドがコンパイル時にわかっている場合、コンパイラは内部ルーチンを使用してプログラムを最適化し、シフトの結果を事前計算してから、シフト演算の代わりに結果を置き換えることができます。 シフト量が大きすぎる場合、または負の場合は、内部ルーチンの結果が、CPU によって実行されるのと同じシフト式の結果と異なる可能性があります。

### <a name="variable-arguments-varargs-behavior"></a>可変個引数 (varargs) の動作

ARM アーキテクチャでは、スタックで渡される可変個引数リストのパラメーターはアラインメントの対象となります。 たとえば、64ビットのパラメーターは64ビットの境界上にアラインされます。 X86 と x64 では、スタックで渡される引数はアラインメントとパックの対象になりません。 この違いにより、`printf` などの可変個引数関数は、可変個のアーキテクチャの一部の値のサブセットで動作する場合でも、可変個の引数リストの必要なレイアウトが正確に一致しない場合に、ARM の埋め込みとして意図されたメモリアドレスを読み取ることができます。 次の例について考えます。

```C
// notice that a 64-bit integer is passed to the function, but '%d' is used to read it.
// on x86 and x64 this may work for small values because %d will "parse" the low-32 bits of the argument.
// on ARM the calling convention will align the 64-bit value and the code will print a random value
printf("%d\n", 1LL);
```

この場合、引数のアラインメントが考慮されるように正しい書式指定が使用されていることを確認することで、バグを修正できます。 このコードは正しいものです。

```C
// CORRECT: use %I64d for 64-bit integers
printf("%I64d\n", 1LL);
```

### <a name="argument-evaluation-order"></a>引数の評価順序

ARM、x86、および x64 のプロセッサは異なるため、コンパイラの実装にはさまざまな要件があり、最適化についても異なる可能性があります。 このため、呼び出し規則や最適化の設定などの他の要素と共に、コンパイラは異なるアーキテクチャで異なる順序で、または他の要因が変更されたときに関数の引数を評価する場合があります。 これにより、特定の評価順序に依存するアプリの動作が予期せず変更される可能性があります。

この種のエラーは、関数の引数に副作用がある場合に発生する可能性があります。これは、同じ呼び出しで関数の他の引数に影響を与えます。 通常、この種の依存関係は簡単に回避できますが、識別しにくい依存関係や演算子のオーバーロードによって隠されることがあります。 次のコード例を考えてみます。

```cpp
handle memory_handle;

memory_handle->acquire(*p);
```

これは明確に定義されていますが、`->` と `*` がオーバーロードされた演算子の場合、このコードは次のようなものに変換されます。

```cpp
Handle::acquire(operator->(memory_handle), operator*(p));
```

また、`operator->(memory_handle)` と `operator*(p)`の間に依存関係がある場合は、元のコードが依存関係がないように見える場合でも、コードは特定の評価順序に依存する可能性があります。

### <a name="volatile-keyword-default-behavior"></a>volatile キーワードの既定の動作

MSVC コンパイラでは、コンパイラスイッチを使用して指定できる `volatile` ストレージ修飾子の2つの異なる解釈がサポートされています。 [/Volatile: ms](reference/volatile-volatile-keyword-interpretation.md)スイッチは、強力な順序を保証する Microsoft 拡張 volatile セマンティクスを選択します。これは、これらのアーキテクチャに対する強力なメモリモデルにより、x86 と x64 の従来のケースでした。 [/Volatile: iso](reference/volatile-volatile-keyword-interpretation.md)スイッチは、厳密なC++順序を保証しない厳密な標準 volatile セマンティクスを選択します。

Arm のアーキテクチャでは、arm プロセッサには弱い順序付けされたメモリモデルがあるため、既定値は **/volatile: iso**です。 arm ソフトウェアは **/volatile: ms**の拡張セマンティクスに依存していないため、通常はのソフトウェアとのインターフェイスを必要としません。 ただし、拡張されたセマンティクスを使用するために ARM プログラムをコンパイルする必要がある場合もあります。 たとえば、ISO C++セマンティクスを使用するようにプログラムを移植できない場合や、ドライバーソフトウェアが正常に機能するためには、従来のセマンティクスに従う必要がある場合があります。 このような場合は、 **/volatile: ms**スイッチを使用できます。ただし、ARM ターゲットに対して従来の volatile セマンティクスを再作成するには、コンパイラが `volatile` 変数の読み取りまたは書き込みのたびにメモリバリアを挿入して、厳密な順序を適用する必要があります。これにより、パフォーマンスに悪影響を及ぼす可能性があります。

X86 および x64 アーキテクチャでは、MSVC を使用してこれらのアーキテクチャ用に既に作成されているソフトウェアの多くが依存しているため、既定値は **/volatile: ms**です。 X86 および x64 プログラムをコンパイルするときに、 **/volatile: iso**スイッチを指定すると、従来の volatile セマンティクスに対する不要な依存を回避し、移植性を高めることができます。

## <a name="see-also"></a>参照

[ARM プロセッサ用の Visual C ++ の構成する](configuring-programs-for-arm-processors-visual-cpp.md)
